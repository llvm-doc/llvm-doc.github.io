<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="keywords" content="LLVM,Low Level Virtual Machine,C++,doxygen,API,documentation"/>
<meta name="description" content="C++ source code API documentation for LLVM."/>
<title>LLVM: ReaderWriter.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head><body>
<p class="title">LLVM API Documentation</p>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('ReaderWriter_8h_source.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">ReaderWriter.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="ReaderWriter_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//===-- llvm/Bitcode/ReaderWriter.h - Bitcode reader/writers ----*- C++ -*-===//</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">//                     The LLVM Compiler Infrastructure</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// This file is distributed under the University of Illinois Open Source</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">// License. See LICENSE.TXT for details.</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">// This header defines interfaces to read and write LLVM bitcode files/streams.</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="preprocessor">#ifndef LLVM_BITCODE_READERWRITER_H</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="preprocessor">#define LLVM_BITCODE_READERWRITER_H</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespacellvm.html">llvm</a> {</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  <span class="keyword">class </span>BitstreamWriter;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;  <span class="keyword">class </span>MemoryBuffer;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;  <span class="keyword">class </span>DataStreamer;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  <span class="keyword">class </span>LLVMContext;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  <span class="keyword">class </span>Module;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  <span class="keyword">class </span>ModulePass;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  <span class="keyword">class </span>raw_ostream;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment">  /// getLazyBitcodeModule - Read the header of the specified bitcode buffer</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">  /// and prepare for lazy deserialization of function bodies.  If successful,</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment">  /// this takes ownership of &#39;buffer&#39; and returns a non-null pointer.  On</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment">  /// error, this returns null, *does not* take ownership of Buffer, and fills</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment">  /// in *ErrMsg with an error description if ErrMsg is non-null.</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment"></span>  Module *<a class="code" href="namespacellvm.html#a3cc0a2948405bdbf435922d6f82629be">getLazyBitcodeModule</a>(MemoryBuffer *Buffer,</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;                               LLVMContext &amp;Context,</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;                               std::string *ErrMsg = 0);</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment">  /// getStreamedBitcodeModule - Read the header of the specified stream</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">  /// and prepare for lazy deserialization and streaming of function bodies.</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">  /// On error, this returns null, and fills in *ErrMsg with an error</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment">  /// description if ErrMsg is non-null.</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment"></span>  Module *<a class="code" href="namespacellvm.html#ab598ee6a8b28a19c652ec4d79ce5c638">getStreamedBitcodeModule</a>(<span class="keyword">const</span> std::string &amp;name,</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                                   DataStreamer *streamer,</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                                   LLVMContext &amp;Context,</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;                                   std::string *ErrMsg = 0);</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="comment">  /// getBitcodeTargetTriple - Read the header of the specified bitcode</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment">  /// buffer and extract just the triple information. If successful,</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment">  /// this returns a string and *does not* take ownership</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment">  /// of &#39;buffer&#39;. On error, this returns &quot;&quot;, and fills in *ErrMsg</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment">  /// if ErrMsg is non-null.</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment"></span>  std::string <a class="code" href="namespacellvm.html#aa16e2368db88e9853b721131771ec5ef">getBitcodeTargetTriple</a>(MemoryBuffer *Buffer,</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                                     LLVMContext &amp;Context,</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;                                     std::string *ErrMsg = 0);</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment">  /// ParseBitcodeFile - Read the specified bitcode file, returning the module.</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment">  /// If an error occurs, this returns null and fills in *ErrMsg if it is</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment">  /// non-null.  This method *never* takes ownership of Buffer.</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment"></span>  Module *<a class="code" href="namespacellvm.html#adeb6bbe8b1bed333ee7608e1939153c0">ParseBitcodeFile</a>(MemoryBuffer *Buffer, LLVMContext &amp;Context,</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                           std::string *ErrMsg = 0);</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment">  /// WriteBitcodeToFile - Write the specified module to the specified</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment">  /// raw output stream.  For streams where it matters, the given stream</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment">  /// should be in &quot;binary&quot; mode.</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="namespacellvm.html#a979cf64d92322765aef149bc5b002cbb">WriteBitcodeToFile</a>(<span class="keyword">const</span> Module *<a class="code" href="Target_2X86_2README_8txt.html#ac88fe1d3a61b056a4f64fbbb156a62ff">M</a>, raw_ostream &amp;Out);</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment">  /// createBitcodeWriterPass - Create and return a pass that writes the module</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment">  /// to the specified ostream.</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="comment"></span>  ModulePass *<a class="code" href="namespacellvm.html#a6115cdf8a40a025f0762810724201aec">createBitcodeWriterPass</a>(raw_ostream &amp;Str);</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment">  /// isBitcodeWrapper - Return true if the given bytes are the magic bytes</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="comment">  /// for an LLVM IR bitcode wrapper.</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00074"></a><span class="lineno"><a class="line" href="namespacellvm.html#ac4600455d814c9fad71f2da0ab5d7b33">   74</a></span>&#160;<span class="comment"></span>  <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#ac4600455d814c9fad71f2da0ab5d7b33">isBitcodeWrapper</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *BufPtr,</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *BufEnd) {</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <span class="comment">// See if you can find the hidden message in the magic bytes :-).</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="comment">// (Hint: it&#39;s a little-endian encoding.)</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="keywordflow">return</span> BufPtr != BufEnd &amp;&amp;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;           BufPtr[0] == 0xDE &amp;&amp;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;           BufPtr[1] == 0xC0 &amp;&amp;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;           BufPtr[2] == 0x17 &amp;&amp;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;           BufPtr[3] == 0x0B;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  }</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="comment">  /// isRawBitcode - Return true if the given bytes are the magic bytes for</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="comment">  /// raw LLVM IR bitcode (without a wrapper).</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00088"></a><span class="lineno"><a class="line" href="namespacellvm.html#a585f7962eb9ceeacf6dac007d78e5189">   88</a></span>&#160;<span class="comment"></span>  <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#a585f7962eb9ceeacf6dac007d78e5189">isRawBitcode</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *BufPtr,</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *BufEnd) {</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="comment">// These bytes sort of have a hidden message, but it&#39;s not in</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="comment">// little-endian this time, and it&#39;s a little redundant.</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <span class="keywordflow">return</span> BufPtr != BufEnd &amp;&amp;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;           BufPtr[0] == <span class="charliteral">&#39;B&#39;</span> &amp;&amp;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;           BufPtr[1] == <span class="charliteral">&#39;C&#39;</span> &amp;&amp;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;           BufPtr[2] == 0xc0 &amp;&amp;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;           BufPtr[3] == 0xde;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  }</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="comment">  /// isBitcode - Return true if the given bytes are the magic bytes for</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="comment">  /// LLVM IR bitcode, either with or without a wrapper.</span></div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00102"></a><span class="lineno"><a class="line" href="namespacellvm.html#ae0ccf1c0633b02c90c21118d0c1c7ec4">  102</a></span>&#160;<span class="comment"></span>  <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#ae0ccf1c0633b02c90c21118d0c1c7ec4">isBitcode</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *BufPtr,</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *BufEnd) {</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacellvm.html#ac4600455d814c9fad71f2da0ab5d7b33">isBitcodeWrapper</a>(BufPtr, BufEnd) ||</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;           <a class="code" href="namespacellvm.html#a585f7962eb9ceeacf6dac007d78e5189">isRawBitcode</a>(BufPtr, BufEnd);</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  }</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="comment">  /// SkipBitcodeWrapperHeader - Some systems wrap bc files with a special</span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment">  /// header for padding or other reasons.  The format of this header is:</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment">  /// struct bc_header {</span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment">  ///   uint32_t Magic;         // 0x0B17C0DE</span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="comment">  ///   uint32_t Version;       // Version, currently always 0.</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="comment">  ///   uint32_t BitcodeOffset; // Offset to traditional bitcode file.</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment">  ///   uint32_t BitcodeSize;   // Size of traditional bitcode file.</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment">  ///   ... potentially other gunk ...</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">  /// };</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment">  /// This function is called when we find a file with a matching magic number.</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment">  /// In this case, skip down to the subsection of the file that is actually a</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment">  /// BC file.</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment">  /// If &#39;VerifyBufferSize&#39; is true, check that the buffer is large enough to</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="comment">  /// contain the whole bitcode file.</span></div><div class="line"><a name="l00124"></a><span class="lineno"><a class="line" href="namespacellvm.html#ac0fd79668dfc1a7627b754817553138f">  124</a></span>&#160;<span class="comment"></span>  <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#ac0fd79668dfc1a7627b754817553138f">SkipBitcodeWrapperHeader</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *&amp;BufPtr,</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *&amp;BufEnd,</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;                                       <span class="keywordtype">bool</span> VerifyBufferSize) {</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="keyword">enum</span> {</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;      KnownHeaderSize = 4*4,  <span class="comment">// Size of header we read.</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;      OffsetField = 2*4,      <span class="comment">// Offset in bytes to Offset field.</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;      SizeField = 3*4         <span class="comment">// Offset in bytes to Size field.</span></div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    };</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    <span class="comment">// Must contain the header!</span></div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    <span class="keywordflow">if</span> (BufEnd-BufPtr &lt; KnownHeaderSize) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    <span class="keywordtype">unsigned</span> Offset = ( BufPtr[OffsetField  ]        |</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                       (BufPtr[OffsetField+1] &lt;&lt; 8)  |</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;                       (BufPtr[OffsetField+2] &lt;&lt; 16) |</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;                       (BufPtr[OffsetField+3] &lt;&lt; 24));</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <span class="keywordtype">unsigned</span> Size   = ( BufPtr[SizeField    ]        |</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;                       (BufPtr[SizeField  +1] &lt;&lt; 8)  |</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;                       (BufPtr[SizeField  +2] &lt;&lt; 16) |</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;                       (BufPtr[SizeField  +3] &lt;&lt; 24));</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;    <span class="comment">// Verify that Offset+Size fits in the file.</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    <span class="keywordflow">if</span> (VerifyBufferSize &amp;&amp; Offset+Size &gt; <span class="keywordtype">unsigned</span>(BufEnd-BufPtr))</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    BufPtr += Offset;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    BufEnd = BufPtr+Size;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  }</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;} <span class="comment">// End llvm namespace</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="preprocessor">#endif</span></div><div class="ttc" id="namespacellvm_html"><div class="ttname"><a href="namespacellvm.html">llvm</a></div><div class="ttdoc">List of target independent CodeGen pass IDs. </div><div class="ttdef"><b>Definition:</b> <a href="APFloat_8h_source.html#l00022">APFloat.h:22</a></div></div>
<div class="ttc" id="namespacellvm_html_a3cc0a2948405bdbf435922d6f82629be"><div class="ttname"><a href="namespacellvm.html#a3cc0a2948405bdbf435922d6f82629be">llvm::getLazyBitcodeModule</a></div><div class="ttdeci">Module * getLazyBitcodeModule(MemoryBuffer *Buffer, LLVMContext &amp;Context, std::string *ErrMsg=0)</div><div class="ttdef"><b>Definition:</b> <a href="BitcodeReader_8cpp_source.html#l03275">BitcodeReader.cpp:3275</a></div></div>
<div class="ttc" id="namespacellvm_html_ac4600455d814c9fad71f2da0ab5d7b33"><div class="ttname"><a href="namespacellvm.html#ac4600455d814c9fad71f2da0ab5d7b33">llvm::isBitcodeWrapper</a></div><div class="ttdeci">bool isBitcodeWrapper(const unsigned char *BufPtr, const unsigned char *BufEnd)</div><div class="ttdef"><b>Definition:</b> <a href="ReaderWriter_8h_source.html#l00074">ReaderWriter.h:74</a></div></div>
<div class="ttc" id="namespacellvm_html_aa16e2368db88e9853b721131771ec5ef"><div class="ttname"><a href="namespacellvm.html#aa16e2368db88e9853b721131771ec5ef">llvm::getBitcodeTargetTriple</a></div><div class="ttdeci">std::string getBitcodeTargetTriple(MemoryBuffer *Buffer, LLVMContext &amp;Context, std::string *ErrMsg=0)</div><div class="ttdef"><b>Definition:</b> <a href="BitcodeReader_8cpp_source.html#l03337">BitcodeReader.cpp:3337</a></div></div>
<div class="ttc" id="namespacellvm_html_a6115cdf8a40a025f0762810724201aec"><div class="ttname"><a href="namespacellvm.html#a6115cdf8a40a025f0762810724201aec">llvm::createBitcodeWriterPass</a></div><div class="ttdeci">ModulePass * createBitcodeWriterPass(raw_ostream &amp;Str)</div><div class="ttdef"><b>Definition:</b> <a href="BitcodeWriterPass_8cpp_source.html#l00039">BitcodeWriterPass.cpp:39</a></div></div>
<div class="ttc" id="namespacellvm_html_ae0ccf1c0633b02c90c21118d0c1c7ec4"><div class="ttname"><a href="namespacellvm.html#ae0ccf1c0633b02c90c21118d0c1c7ec4">llvm::isBitcode</a></div><div class="ttdeci">bool isBitcode(const unsigned char *BufPtr, const unsigned char *BufEnd)</div><div class="ttdef"><b>Definition:</b> <a href="ReaderWriter_8h_source.html#l00102">ReaderWriter.h:102</a></div></div>
<div class="ttc" id="namespacellvm_html_a585f7962eb9ceeacf6dac007d78e5189"><div class="ttname"><a href="namespacellvm.html#a585f7962eb9ceeacf6dac007d78e5189">llvm::isRawBitcode</a></div><div class="ttdeci">bool isRawBitcode(const unsigned char *BufPtr, const unsigned char *BufEnd)</div><div class="ttdef"><b>Definition:</b> <a href="ReaderWriter_8h_source.html#l00088">ReaderWriter.h:88</a></div></div>
<div class="ttc" id="namespacellvm_html_ab598ee6a8b28a19c652ec4d79ce5c638"><div class="ttname"><a href="namespacellvm.html#ab598ee6a8b28a19c652ec4d79ce5c638">llvm::getStreamedBitcodeModule</a></div><div class="ttdeci">Module * getStreamedBitcodeModule(const std::string &amp;name, DataStreamer *streamer, LLVMContext &amp;Context, std::string *ErrMsg=0)</div><div class="ttdef"><b>Definition:</b> <a href="BitcodeReader_8cpp_source.html#l03297">BitcodeReader.cpp:3297</a></div></div>
<div class="ttc" id="namespacellvm_html_ac0fd79668dfc1a7627b754817553138f"><div class="ttname"><a href="namespacellvm.html#ac0fd79668dfc1a7627b754817553138f">llvm::SkipBitcodeWrapperHeader</a></div><div class="ttdeci">bool SkipBitcodeWrapperHeader(const unsigned char *&amp;BufPtr, const unsigned char *&amp;BufEnd, bool VerifyBufferSize)</div><div class="ttdef"><b>Definition:</b> <a href="ReaderWriter_8h_source.html#l00124">ReaderWriter.h:124</a></div></div>
<div class="ttc" id="namespacellvm_html_adeb6bbe8b1bed333ee7608e1939153c0"><div class="ttname"><a href="namespacellvm.html#adeb6bbe8b1bed333ee7608e1939153c0">llvm::ParseBitcodeFile</a></div><div class="ttdeci">Module * ParseBitcodeFile(MemoryBuffer *Buffer, LLVMContext &amp;Context, std::string *ErrMsg=0)</div><div class="ttdef"><b>Definition:</b> <a href="BitcodeReader_8cpp_source.html#l03316">BitcodeReader.cpp:3316</a></div></div>
<div class="ttc" id="Target_2X86_2README_8txt_html_ac88fe1d3a61b056a4f64fbbb156a62ff"><div class="ttname"><a href="Target_2X86_2README_8txt.html#ac88fe1d3a61b056a4f64fbbb156a62ff">M</a></div><div class="ttdeci">We currently emits eax Perhaps this is what we really should generate is Is imull three or four cycles eax eax The current instruction priority is based on pattern complexity The former is more complex because it folds a load so the latter will not be emitted Perhaps we should use AddedComplexity to give LEA32r a higher priority We should always try to match LEA first since the LEA matching code does some estimate to determine whether the match is profitable if we care more about code then imull is better It s two bytes shorter than movl leal On a Pentium M</div><div class="ttdef"><b>Definition:</b> <a href="Target_2X86_2README_8txt_source.html#l00297">Target/X86/README.txt:297</a></div></div>
<div class="ttc" id="namespacellvm_html_a979cf64d92322765aef149bc5b002cbb"><div class="ttname"><a href="namespacellvm.html#a979cf64d92322765aef149bc5b002cbb">llvm::WriteBitcodeToFile</a></div><div class="ttdeci">void WriteBitcodeToFile(const Module *M, raw_ostream &amp;Out)</div><div class="ttdef"><b>Definition:</b> <a href="BitcodeWriter_8cpp_source.html#l02009">BitcodeWriter.cpp:2009</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<hr>
<p class="footer">
Generated on Sat Nov 10 2018 23:00:57 for <a href="http://llvm.org/">LLVM</a> by
<a href="http://www.doxygen.org"><img src="doxygen.png" alt="Doxygen"
align="middle" border="0"/>1.8.11</a><br>
Copyright &copy; 2003-2013 University of Illinois at Urbana-Champaign.
All Rights Reserved.</p>
<hr>
<!--#include virtual="/attrib.incl" -->
</body>
</html>
