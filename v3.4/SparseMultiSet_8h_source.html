<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="keywords" content="LLVM,Low Level Virtual Machine,C++,doxygen,API,documentation"/>
<meta name="description" content="C++ source code API documentation for LLVM."/>
<title>LLVM: SparseMultiSet.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head><body>
<p class="title">LLVM API Documentation</p>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('SparseMultiSet_8h_source.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">SparseMultiSet.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="SparseMultiSet_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//===--- llvm/ADT/SparseMultiSet.h - Sparse multiset ------------*- C++ -*-===//</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">//                     The LLVM Compiler Infrastructure</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// This file is distributed under the University of Illinois Open Source</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">// License. See LICENSE.TXT for details.</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">// This file defines the SparseMultiSet class, which adds multiset behavior to</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">// the SparseSet.</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">// A sparse multiset holds a small number of objects identified by integer keys</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">// from a moderately sized universe. The sparse multiset uses more memory than</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">// other containers in order to provide faster operations. Any key can map to</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">// multiple values. A SparseMultiSetNode class is provided, which serves as a</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">// convenient base class for the contents of a SparseMultiSet.</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#ifndef LLVM_ADT_SPARSEMULTISET_H</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#define LLVM_ADT_SPARSEMULTISET_H</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="SparseSet_8h.html">llvm/ADT/SparseSet.h</a>&quot;</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespacellvm.html">llvm</a> {</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment">/// Fast multiset implementation for objects that can be identified by small</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">/// unsigned keys.</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment">/// SparseMultiSet allocates memory proportional to the size of the key</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment">/// universe, so it is not recommended for building composite data structures.</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment">/// It is useful for algorithms that require a single set with fast operations.</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment">/// Compared to DenseSet and DenseMap, SparseMultiSet provides constant-time</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment">/// fast clear() as fast as a vector.  The find(), insert(), and erase()</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment">/// operations are all constant time, and typically faster than a hash table.</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">/// The iteration order doesn&#39;t depend on numerical key values, it only depends</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">/// on the order of insert() and erase() operations.  Iteration order is the</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment">/// insertion order. Iteration is only provided over elements of equivalent</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment">/// keys, but iterators are bidirectional.</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="comment">/// Compared to BitVector, SparseMultiSet&lt;unsigned&gt; uses 8x-40x more memory, but</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="comment">/// offers constant-time clear() and size() operations as well as fast iteration</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment">/// independent on the size of the universe.</span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment">/// SparseMultiSet contains a dense vector holding all the objects and a sparse</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment">/// array holding indexes into the dense vector.  Most of the memory is used by</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment">/// the sparse array which is the size of the key universe. The SparseT template</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment">/// parameter provides a space/speed tradeoff for sets holding many elements.</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment">/// When SparseT is uint32_t, find() only touches up to 3 cache lines, but the</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment">/// sparse array uses 4 x Universe bytes.</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment">/// When SparseT is uint8_t (the default), find() touches up to 3+[N/256] cache</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment">/// lines, but the sparse array is 4x smaller.  N is the number of elements in</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment">/// the set.</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment">/// For sets that may grow to thousands of elements, SparseT should be set to</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment">/// uint16_t or uint32_t.</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment">/// Multiset behavior is provided by providing doubly linked lists for values</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment">/// that are inlined in the dense vector. SparseMultiSet is a good choice when</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment">/// one desires a growable number of entries per key, as it will retain the</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment">/// SparseSet algorithmic properties despite being growable. Thus, it is often a</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment">/// better choice than a SparseSet of growable containers or a vector of</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment">/// vectors. SparseMultiSet also keeps iterators valid after erasure (provided</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="comment">/// the iterators don&#39;t point to the element erased), allowing for more</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="comment">/// intuitive and fast removal.</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment">/// @tparam ValueT      The type of objects in the set.</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="comment">/// @tparam KeyFunctorT A functor that computes an unsigned index from KeyT.</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="comment">/// @tparam SparseT     An unsigned integer type. See above.</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment"></span><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ValueT,</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;         <span class="keyword">typename</span> KeyFunctorT = <a class="code" href="structllvm_1_1identity.html">llvm::identity&lt;unsigned&gt;</a>,</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;         <span class="keyword">typename</span> SparseT = uint8_t&gt;</div><div class="line"><a name="l00078"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html">   78</a></span>&#160;<span class="keyword">class </span><a class="code" href="classllvm_1_1SparseMultiSet.html">SparseMultiSet</a> {<span class="comment"></span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="comment">  /// The actual data that&#39;s stored, as a doubly-linked list implemented via</span></div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="comment">  /// indices into the DenseVector.  The doubly linked list is implemented</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="comment">  /// circular in Prev indices, and INVALID-terminated in Next indices. This</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="comment">  /// provides efficient access to list tails. These nodes can also be</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="comment">  /// tombstones, in which case they are actually nodes in a single-linked</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="comment">  /// freelist of recyclable slots.</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="comment"></span>  <span class="keyword">struct </span>SMSNode {</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> INVALID = ~0U;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    ValueT Data;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="keywordtype">unsigned</span> Prev;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <span class="keywordtype">unsigned</span> Next;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    SMSNode(ValueT D, <span class="keywordtype">unsigned</span> <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>, <span class="keywordtype">unsigned</span> <a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>) : Data(D), Prev(P), Next(N) { }</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="comment">    /// List tails have invalid Nexts.</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment"></span>    <span class="keywordtype">bool</span> isTail()<span class="keyword"> const </span>{</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;      <span class="keywordflow">return</span> Next == INVALID;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    }</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="comment">    /// Whether this node is a tombstone node, and thus is in our freelist.</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="comment"></span>    <span class="keywordtype">bool</span> isTombstone()<span class="keyword"> const </span>{</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;      <span class="keywordflow">return</span> Prev == INVALID;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    }</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="comment">    /// Since the list is circular in Prev, all non-tombstone nodes have a valid</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="comment">    /// Prev.</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="comment"></span>    <span class="keywordtype">bool</span> isValid()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> Prev != INVALID; }</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  };</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  <span class="keyword">typedef</span> <span class="keyword">typename</span> KeyFunctorT::argument_type KeyT;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  <span class="keyword">typedef</span> <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;SMSNode, 8&gt;</a> <a class="code" href="classllvm_1_1SmallVector.html">DenseT</a>;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  DenseT Dense;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  SparseT *Sparse;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  <span class="keywordtype">unsigned</span> Universe;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  KeyFunctorT KeyIndexOf;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  <a class="code" href="structllvm_1_1SparseSetValFunctor.html">SparseSetValFunctor&lt;KeyT, ValueT, KeyFunctorT&gt;</a> ValIndexOf;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">  /// We have a built-in recycler for reusing tombstone slots. This recycler</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment">  /// puts a singly-linked free list into tombstone slots, allowing us quick</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment">  /// erasure, iterator preservation, and dense size.</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment"></span>  <span class="keywordtype">unsigned</span> FreelistIdx;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  <span class="keywordtype">unsigned</span> NumFree;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  <span class="keywordtype">unsigned</span> sparseIndex(<span class="keyword">const</span> ValueT &amp;Val)<span class="keyword"> const </span>{</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    assert(ValIndexOf(Val) &lt; Universe &amp;&amp;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;           <span class="stringliteral">&quot;Invalid key in set. Did object mutate?&quot;</span>);</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    <span class="keywordflow">return</span> ValIndexOf(Val);</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;  }</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  <span class="keywordtype">unsigned</span> sparseIndex(<span class="keyword">const</span> SMSNode &amp;<a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> sparseIndex(N.Data); }</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  <span class="comment">// Disable copy construction and assignment.</span></div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  <span class="comment">// This data structure is not meant to be used that way.</span></div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  <a class="code" href="classllvm_1_1SparseMultiSet.html#a85861f4b52d943fe6c6911b2c60625ab">SparseMultiSet</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1SparseMultiSet.html">SparseMultiSet</a>&amp;) <a class="code" href="Compiler_8h.html#aacca75352b8e153274310c374564eb01">LLVM_DELETED_FUNCTION</a>;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  <a class="code" href="classllvm_1_1SparseMultiSet.html">SparseMultiSet</a> &amp;operator=(<span class="keyword">const</span> <a class="code" href="classllvm_1_1SparseMultiSet.html">SparseMultiSet</a>&amp;) <a class="code" href="Compiler_8h.html#aacca75352b8e153274310c374564eb01">LLVM_DELETED_FUNCTION</a>;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="comment">  /// Whether the given entry is the head of the list. List heads&#39;s previous</span></div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="comment">  /// pointers are to the tail of the list, allowing for efficient access to the</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="comment">  /// list tail. D must be a valid entry node.</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> isHead(<span class="keyword">const</span> SMSNode &amp;D)<span class="keyword"> const </span>{</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    assert(D.isValid() &amp;&amp; <span class="stringliteral">&quot;Invalid node for head&quot;</span>);</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <span class="keywordflow">return</span> Dense[D.Prev].isTail();</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  }</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="comment">  /// Whether the given entry is a singleton entry, i.e. the only entry with</span></div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="comment">  /// that key.</span></div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> isSingleton(<span class="keyword">const</span> SMSNode &amp;N)<span class="keyword"> const </span>{</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    assert(N.isValid() &amp;&amp; <span class="stringliteral">&quot;Invalid node for singleton&quot;</span>);</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    <span class="comment">// Is N its own predecessor?</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    <span class="keywordflow">return</span> &amp;Dense[N.Prev] == &amp;<a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;  }</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment">  /// Add in the given SMSNode. Uses a free entry in our freelist if</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment">  /// available. Returns the index of the added node.</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment"></span>  <span class="keywordtype">unsigned</span> addValue(<span class="keyword">const</span> ValueT&amp; V, <span class="keywordtype">unsigned</span> Prev, <span class="keywordtype">unsigned</span> Next) {</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;    <span class="keywordflow">if</span> (NumFree == 0) {</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;      Dense.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(SMSNode(V, Prev, Next));</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;      <span class="keywordflow">return</span> Dense.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a22a311dfe4c28a897de8a9365a4f0a84">size</a>() - 1;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    }</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    <span class="comment">// Peel off a free slot</span></div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    <span class="keywordtype">unsigned</span> Idx = FreelistIdx;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    <span class="keywordtype">unsigned</span> NextFree = Dense[Idx].Next;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    assert(Dense[Idx].isTombstone() &amp;&amp; <span class="stringliteral">&quot;Non-tombstone free?&quot;</span>);</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    Dense[Idx] = SMSNode(V, Prev, Next);</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    FreelistIdx = NextFree;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    --NumFree;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    <span class="keywordflow">return</span> Idx;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;  }</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="comment">  /// Make the current index a new tombstone. Pushes it onto the freelist.</span></div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> makeTombstone(<span class="keywordtype">unsigned</span> Idx) {</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    Dense[Idx].Prev = SMSNode::INVALID;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    Dense[Idx].Next = FreelistIdx;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    FreelistIdx = Idx;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    ++NumFree;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  }</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00179"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#a60e716d1343927746b0f9f9cdcbc9e94">  179</a></span>&#160;  <span class="keyword">typedef</span> ValueT <a class="code" href="classllvm_1_1SparseMultiSet.html#a60e716d1343927746b0f9f9cdcbc9e94">value_type</a>;</div><div class="line"><a name="l00180"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#a60a82e2dbc82339b5e527a38fb0677f8">  180</a></span>&#160;  <span class="keyword">typedef</span> ValueT &amp;<a class="code" href="classllvm_1_1SparseMultiSet.html#a60a82e2dbc82339b5e527a38fb0677f8">reference</a>;</div><div class="line"><a name="l00181"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#a7b2bf65ef72ddaadb5a2a6c274af2a6e">  181</a></span>&#160;  <span class="keyword">typedef</span> <span class="keyword">const</span> ValueT &amp;<a class="code" href="classllvm_1_1SparseMultiSet.html#a7b2bf65ef72ddaadb5a2a6c274af2a6e">const_reference</a>;</div><div class="line"><a name="l00182"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#ab3bce59716d1338c5ec42309029704e6">  182</a></span>&#160;  <span class="keyword">typedef</span> ValueT *<a class="code" href="classllvm_1_1SparseMultiSet.html#ab3bce59716d1338c5ec42309029704e6">pointer</a>;</div><div class="line"><a name="l00183"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#a05191a6f8484d590cc004027e3e61144">  183</a></span>&#160;  <span class="keyword">typedef</span> <span class="keyword">const</span> ValueT *<a class="code" href="classllvm_1_1SparseMultiSet.html#a05191a6f8484d590cc004027e3e61144">const_pointer</a>;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#a85861f4b52d943fe6c6911b2c60625ab">  185</a></span>&#160;  <a class="code" href="classllvm_1_1SparseMultiSet.html#a85861f4b52d943fe6c6911b2c60625ab">SparseMultiSet</a>()</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    : Sparse(0), Universe(0), FreelistIdx(SMSNode::INVALID), NumFree(0) { }</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#ad48508707ac902124dfd05481728014f">  188</a></span>&#160;  <a class="code" href="classllvm_1_1SparseMultiSet.html#ad48508707ac902124dfd05481728014f">~SparseMultiSet</a>() { <a class="code" href="namespacellvm_1_1LibFunc.html#abf8f6830387f338fed0bce2e65108c6fa60e05e8cf4600d05ec9251b750544c7c">free</a>(Sparse); }</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="comment">  /// Set the universe size which determines the largest key the set can hold.</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="comment">  /// The universe must be sized before any elements can be added.</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment">  /// @param U Universe size. All object keys must be less than U.</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00195"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#af781b01667ff848f2b07b4b51660a714">  195</a></span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#af781b01667ff848f2b07b4b51660a714">setUniverse</a>(<span class="keywordtype">unsigned</span> U) {</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    <span class="comment">// It&#39;s not hard to resize the universe on a non-empty set, but it doesn&#39;t</span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    <span class="comment">// seem like a likely use case, so we can add that code when we need it.</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    assert(<a class="code" href="classllvm_1_1SparseMultiSet.html#a56623897a22446f188d99b1ae7a004ac">empty</a>() &amp;&amp; <span class="stringliteral">&quot;Can only resize universe on an empty map&quot;</span>);</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="comment">// Hysteresis prevents needless reallocations.</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="keywordflow">if</span> (U &gt;= Universe/4 &amp;&amp; U &lt;= Universe)</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;      <span class="keywordflow">return</span>;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    <a class="code" href="namespacellvm_1_1LibFunc.html#abf8f6830387f338fed0bce2e65108c6fa60e05e8cf4600d05ec9251b750544c7c">free</a>(Sparse);</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;    <span class="comment">// The Sparse array doesn&#39;t actually need to be initialized, so malloc</span></div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="comment">// would be enough here, but that will cause tools like valgrind to</span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    <span class="comment">// complain about branching on uninitialized data.</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    Sparse = <span class="keyword">reinterpret_cast&lt;</span>SparseT*<span class="keyword">&gt;</span>(<a class="code" href="namespacellvm_1_1LibFunc.html#abf8f6830387f338fed0bce2e65108c6fa3ad9aa19face37d539b9fbe4130e1c6f">calloc</a>(U, <span class="keyword">sizeof</span>(SparseT)));</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    Universe = U;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;  }</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="comment">  /// Our iterators are iterators over the collection of objects that share a</span></div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="comment">  /// key.</span></div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="comment"></span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> SMSPtrTy&gt;</div><div class="line"><a name="l00213"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html">  213</a></span>&#160;  <span class="keyword">class </span><a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html">iterator_base</a> : <span class="keyword">public</span> std::iterator&lt;std::bidirectional_iterator_tag,</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                                             ValueT&gt; {</div><div class="line"><a name="l00215"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a25bc042c8c060f73bc6a5ad866eeda53">  215</a></span>&#160;    <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classllvm_1_1SparseMultiSet.html">SparseMultiSet</a>;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    SMSPtrTy SMS;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    <span class="keywordtype">unsigned</span> Idx;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    <span class="keywordtype">unsigned</span> SparseIdx;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html">iterator_base</a>(SMSPtrTy <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>, <span class="keywordtype">unsigned</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">I</a>, <span class="keywordtype">unsigned</span> SI)</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;      : SMS(P), Idx(I), SparseIdx(SI) { }</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="comment">    /// Whether our iterator has fallen outside our dense vector.</span></div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="comment"></span>    <span class="keywordtype">bool</span> isEnd()<span class="keyword"> const </span>{</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;      <span class="keywordflow">if</span> (Idx == SMSNode::INVALID)</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;      assert(Idx &lt; SMS-&gt;Dense.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a22a311dfe4c28a897de8a9365a4f0a84">size</a>() &amp;&amp; <span class="stringliteral">&quot;Out of range, non-INVALID Idx?&quot;</span>);</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    }</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="comment">    /// Whether our iterator is properly keyed, i.e. the SparseIdx is valid</span></div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="comment"></span>    <span class="keywordtype">bool</span> isKeyed()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> SparseIdx &lt; SMS-&gt;Universe; }</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    <span class="keywordtype">unsigned</span> Prev()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> SMS-&gt;Dense[Idx].Prev; }</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    <span class="keywordtype">unsigned</span> Next()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> SMS-&gt;Dense[Idx].Next; }</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    <span class="keywordtype">void</span> setPrev(<span class="keywordtype">unsigned</span> <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>) { SMS-&gt;Dense[Idx].Prev = <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>; }</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    <span class="keywordtype">void</span> setNext(<span class="keywordtype">unsigned</span> N) { SMS-&gt;Dense[Idx].Next = <a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>; }</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;  <span class="keyword">public</span>:</div><div class="line"><a name="l00242"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a9f33c6f0c3b8a457af259add31335cce">  242</a></span>&#160;    <span class="keyword">typedef</span> std::iterator&lt;std::bidirectional_iterator_tag, ValueT&gt; <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a9f33c6f0c3b8a457af259add31335cce">super</a>;</div><div class="line"><a name="l00243"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a0365e14859d40f92a05acaac517094e3">  243</a></span>&#160;    <span class="keyword">typedef</span> <span class="keyword">typename</span> super::value_type <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a0365e14859d40f92a05acaac517094e3">value_type</a>;</div><div class="line"><a name="l00244"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a649c4b7d00e65192814844a03605caa1">  244</a></span>&#160;    <span class="keyword">typedef</span> <span class="keyword">typename</span> super::difference_type <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a649c4b7d00e65192814844a03605caa1">difference_type</a>;</div><div class="line"><a name="l00245"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a4bb0ab76d97bd15bcd884ffedbedf3c3">  245</a></span>&#160;    <span class="keyword">typedef</span> <span class="keyword">typename</span> super::pointer <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a4bb0ab76d97bd15bcd884ffedbedf3c3">pointer</a>;</div><div class="line"><a name="l00246"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#aaadb87b8b56aed717dee2e82373bc64a">  246</a></span>&#160;    <span class="keyword">typedef</span> <span class="keyword">typename</span> super::reference <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#aaadb87b8b56aed717dee2e82373bc64a">reference</a>;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;</div><div class="line"><a name="l00248"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a40fd54d421bd36f861db8d56e817b43c">  248</a></span>&#160;    <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a40fd54d421bd36f861db8d56e817b43c">iterator_base</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html">iterator_base</a> &amp;RHS)</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;      : SMS(RHS.SMS), Idx(RHS.Idx), SparseIdx(RHS.SparseIdx) { }</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;</div><div class="line"><a name="l00251"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#afafb4cb5eaafd087d1518f488ebcd5b2">  251</a></span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html">iterator_base</a> &amp;<a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#afafb4cb5eaafd087d1518f488ebcd5b2">operator=</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html">iterator_base</a> &amp;RHS) {</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;      SMS = RHS.SMS;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;      Idx = RHS.Idx;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;      SparseIdx = RHS.SparseIdx;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;      <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    }</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div><div class="line"><a name="l00258"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a4c31ff4b5054b9fd7350b5d41fa963ea">  258</a></span>&#160;    reference <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a4c31ff4b5054b9fd7350b5d41fa963ea">operator*</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;      assert(isKeyed() &amp;&amp; SMS-&gt;sparseIndex(SMS-&gt;Dense[Idx].Data) == SparseIdx &amp;&amp;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;             <span class="stringliteral">&quot;Dereferencing iterator of invalid key or index&quot;</span>);</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;      <span class="keywordflow">return</span> SMS-&gt;Dense[Idx].Data;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    }</div><div class="line"><a name="l00264"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a3cfb35c0ca65fa9277bd50b812bb4bc9">  264</a></span>&#160;    pointer <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a3cfb35c0ca65fa9277bd50b812bb4bc9">operator-&gt;</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;operator*(); }</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment">    /// Comparison operators</span></div><div class="line"><a name="l00267"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#af6af1649895276003eb58aebede8686e">  267</a></span>&#160;<span class="comment"></span>    <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#af6af1649895276003eb58aebede8686e">operator==</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html">iterator_base</a> &amp;RHS)<span class="keyword"> const </span>{</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;      <span class="comment">// end compares equal</span></div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;      <span class="keywordflow">if</span> (SMS == RHS.SMS &amp;&amp; Idx == RHS.Idx) {</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        assert((isEnd() || SparseIdx == RHS.SparseIdx) &amp;&amp;</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;               <span class="stringliteral">&quot;Same dense entry, but different keys?&quot;</span>);</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;      }</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    }</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;</div><div class="line"><a name="l00278"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#af9458343f244f31363e1a2ef1d48367a">  278</a></span>&#160;    <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#af9458343f244f31363e1a2ef1d48367a">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html">iterator_base</a> &amp;RHS)<span class="keyword"> const </span>{</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;      <span class="keywordflow">return</span> !<a class="code" href="namespacellvm.html#a162c90bc179a6359438d060722bee35f">operator==</a>(RHS);</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    }</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="comment">    /// Increment and decrement operators</span></div><div class="line"><a name="l00283"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a3e19644ee8a7fadddca08081de300200">  283</a></span>&#160;<span class="comment"></span>    <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html">iterator_base</a> &amp;<a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a3e19644ee8a7fadddca08081de300200">operator--</a>() { <span class="comment">// predecrement - Back up</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;      assert(isKeyed() &amp;&amp; <span class="stringliteral">&quot;Decrementing an invalid iterator&quot;</span>);</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;      assert((isEnd() || !SMS-&gt;isHead(SMS-&gt;Dense[Idx])) &amp;&amp;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;             <span class="stringliteral">&quot;Decrementing head of list&quot;</span>);</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;      <span class="comment">// If we&#39;re at the end, then issue a new find()</span></div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;      <span class="keywordflow">if</span> (isEnd())</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        Idx = SMS-&gt;findIndex(SparseIdx).Prev();</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        Idx = Prev();</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;      <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    }</div><div class="line"><a name="l00296"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a9c7fc0e07b570a2773e4dce72cce553b">  296</a></span>&#160;    <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html">iterator_base</a> &amp;<a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a9c7fc0e07b570a2773e4dce72cce553b">operator++</a>() { <span class="comment">// preincrement - Advance</span></div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;      assert(!isEnd() &amp;&amp; isKeyed() &amp;&amp; <span class="stringliteral">&quot;Incrementing an invalid/end iterator&quot;</span>);</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;      Idx = Next();</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;      <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    }</div><div class="line"><a name="l00301"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#ae25c4a3950e490375740861d3fd254e3">  301</a></span>&#160;    <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html">iterator_base</a> <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#ae25c4a3950e490375740861d3fd254e3">operator--</a>(<span class="keywordtype">int</span>) { <span class="comment">// postdecrement</span></div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;      <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html">iterator_base</a> <a class="code" href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">I</a>(*<span class="keyword">this</span>);</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;      --*<span class="keyword">this</span>;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">I</a>;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    }</div><div class="line"><a name="l00306"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a21292ed929dc2a97f2e897aaa2b6d300">  306</a></span>&#160;    <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html">iterator_base</a> <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a21292ed929dc2a97f2e897aaa2b6d300">operator++</a>(<span class="keywordtype">int</span>) { <span class="comment">// postincrement</span></div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;      <a class="code" href="classllvm_1_1SparseMultiSet_1_1iterator__base.html">iterator_base</a> <a class="code" href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">I</a>(*<span class="keyword">this</span>);</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;      ++*<span class="keyword">this</span>;</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">I</a>;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    }</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;  };</div><div class="line"><a name="l00312"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#a5a05b79eda02945cb09d6202624f7fa4">  312</a></span>&#160;  <span class="keyword">typedef</span> iterator_base&lt;SparseMultiSet *&gt; <a class="code" href="classllvm_1_1SparseMultiSet.html#a5a05b79eda02945cb09d6202624f7fa4">iterator</a>;</div><div class="line"><a name="l00313"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#aad80836d7fbed3e386912eb8596e2743">  313</a></span>&#160;  <span class="keyword">typedef</span> iterator_base&lt;const SparseMultiSet *&gt; <a class="code" href="classllvm_1_1SparseMultiSet.html#aad80836d7fbed3e386912eb8596e2743">const_iterator</a>;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;  <span class="comment">// Convenience types</span></div><div class="line"><a name="l00316"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#ae9320934e3ae489cb0f70d01dd0bd053">  316</a></span>&#160;  <span class="keyword">typedef</span> std::pair&lt;iterator, iterator&gt; <a class="code" href="classllvm_1_1SparseMultiSet.html#ae9320934e3ae489cb0f70d01dd0bd053">RangePair</a>;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="comment">  /// Returns an iterator past this container. Note that such an iterator cannot</span></div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<span class="comment">  /// be decremented, but will compare equal to other end iterators.</span></div><div class="line"><a name="l00320"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#a6123d1aa335e5d9c6299050c2cc5193e">  320</a></span>&#160;<span class="comment"></span>  iterator <a class="code" href="classllvm_1_1SparseMultiSet.html#a6123d1aa335e5d9c6299050c2cc5193e">end</a>() { <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a5a05b79eda02945cb09d6202624f7fa4">iterator</a>(<span class="keyword">this</span>, SMSNode::INVALID, SMSNode::INVALID); }</div><div class="line"><a name="l00321"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#aeb3fe6e0de21d69233fc63b2d26f9aa7">  321</a></span>&#160;  const_iterator <a class="code" href="classllvm_1_1SparseMultiSet.html#aeb3fe6e0de21d69233fc63b2d26f9aa7">end</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#aad80836d7fbed3e386912eb8596e2743">const_iterator</a>(<span class="keyword">this</span>, SMSNode::INVALID, SMSNode::INVALID);</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;  }</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="comment">  /// Returns true if the set is empty.</span></div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="comment">  /// This is not the same as BitVector::empty().</span></div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00329"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#a56623897a22446f188d99b1ae7a004ac">  329</a></span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a56623897a22446f188d99b1ae7a004ac">empty</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a6a93435ad61b876b5542533316a8920a">size</a>() == 0; }</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="comment">  /// Returns the number of elements in the set.</span></div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="comment">  /// This is not the same as BitVector::size() which returns the size of the</span></div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="comment">  /// universe.</span></div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00336"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#a6a93435ad61b876b5542533316a8920a">  336</a></span>&#160;<span class="comment"></span>  <span class="keywordtype">unsigned</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a6a93435ad61b876b5542533316a8920a">size</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    assert(NumFree &lt;= Dense.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a22a311dfe4c28a897de8a9365a4f0a84">size</a>() &amp;&amp; <span class="stringliteral">&quot;Out-of-bounds free entries&quot;</span>);</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    <span class="keywordflow">return</span> Dense.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a22a311dfe4c28a897de8a9365a4f0a84">size</a>() - NumFree;</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;  }</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="comment">  /// Clears the set.  This is a very fast constant time operation.</span></div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00343"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#a2554bf4e6f211e29c3e80fd4c9141c79">  343</a></span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a2554bf4e6f211e29c3e80fd4c9141c79">clear</a>() {</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <span class="comment">// Sparse does not need to be cleared, see find().</span></div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    Dense.<a class="code" href="classllvm_1_1SmallVectorImpl.html#aac0ea55010b7b1a301e65a0baea057aa">clear</a>();</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    NumFree = 0;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    FreelistIdx = SMSNode::INVALID;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;  }</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="comment">  /// Find an element by its index.</span></div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;<span class="comment">  /// @param   Idx A valid index to find.</span></div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="comment">  /// @returns An iterator to the element identified by key, or end().</span></div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00355"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#a16a780296035cd55839932310e5dc672">  355</a></span>&#160;<span class="comment"></span>  iterator <a class="code" href="classllvm_1_1SparseMultiSet.html#a16a780296035cd55839932310e5dc672">findIndex</a>(<span class="keywordtype">unsigned</span> Idx) {</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    assert(Idx &lt; Universe &amp;&amp; <span class="stringliteral">&quot;Key out of range&quot;</span>);</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    assert(std::numeric_limits&lt;SparseT&gt;::is_integer &amp;&amp;</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;           !std::numeric_limits&lt;SparseT&gt;::is_signed &amp;&amp;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;           <span class="stringliteral">&quot;SparseT must be an unsigned integer type&quot;</span>);</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> Stride = std::numeric_limits&lt;SparseT&gt;::max() + 1u;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a> = Sparse[Idx], e = Dense.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a22a311dfe4c28a897de8a9365a4f0a84">size</a>(); <a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a> &lt; e; <a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a> += Stride) {</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> FoundIdx = sparseIndex(Dense[<a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a>]);</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;      <span class="comment">// Check that we&#39;re pointing at the correct entry and that it is the head</span></div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;      <span class="comment">// of a valid list.</span></div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;      <span class="keywordflow">if</span> (Idx == FoundIdx &amp;&amp; Dense[i].isValid() &amp;&amp; isHead(Dense[i]))</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a5a05b79eda02945cb09d6202624f7fa4">iterator</a>(<span class="keyword">this</span>, i, Idx);</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;      <span class="comment">// Stride is 0 when SparseT &gt;= unsigned.  We don&#39;t need to loop.</span></div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;      <span class="keywordflow">if</span> (!Stride)</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;        <span class="keywordflow">break</span>;</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    }</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a6123d1aa335e5d9c6299050c2cc5193e">end</a>();</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;  }</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;<span class="comment">  /// Find an element by its key.</span></div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;<span class="comment">  /// @param   Key A valid key to find.</span></div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;<span class="comment">  /// @returns An iterator to the element identified by key, or end().</span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00379"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#a007d043f89bfaefaec158a7e93b39832">  379</a></span>&#160;<span class="comment"></span>  iterator <a class="code" href="classllvm_1_1SparseMultiSet.html#a007d043f89bfaefaec158a7e93b39832">find</a>(<span class="keyword">const</span> KeyT &amp;Key) {</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a16a780296035cd55839932310e5dc672">findIndex</a>(KeyIndexOf(Key));</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;  }</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;</div><div class="line"><a name="l00383"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#abb5808737d5bc560a7c8f797433e8182">  383</a></span>&#160;  const_iterator <a class="code" href="classllvm_1_1SparseMultiSet.html#abb5808737d5bc560a7c8f797433e8182">find</a>(<span class="keyword">const</span> KeyT &amp;Key)<span class="keyword"> const </span>{</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    iterator <a class="code" href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">I</a> = <span class="keyword">const_cast&lt;</span><a class="code" href="classllvm_1_1SparseMultiSet.html">SparseMultiSet</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;<a class="code" href="classllvm_1_1SparseMultiSet.html#a16a780296035cd55839932310e5dc672">findIndex</a>(KeyIndexOf(Key));</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#aad80836d7fbed3e386912eb8596e2743">const_iterator</a>(I.SMS, I.Idx, KeyIndexOf(Key));</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;  }</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;<span class="comment">  /// Returns the number of elements identified by Key. This will be linear in</span></div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;<span class="comment">  /// the number of elements of that key.</span></div><div class="line"><a name="l00390"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#ac8d3a507aeb3c626ad4ac4b28312b191">  390</a></span>&#160;<span class="comment"></span>  <span class="keywordtype">unsigned</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#ac8d3a507aeb3c626ad4ac4b28312b191">count</a>(<span class="keyword">const</span> KeyT &amp;Key)<span class="keyword"> const </span>{</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    <span class="keywordtype">unsigned</span> <a class="code" href="namespacellvm_1_1AArch64ISD.html#a246d89cb58f606179b1435937830bbdca84e96c468affe3b1fd3076b4fc5d063e">Ret</a> = 0;</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    <span class="keywordflow">for</span> (const_iterator It = <a class="code" href="classllvm_1_1SparseMultiSet.html#a007d043f89bfaefaec158a7e93b39832">find</a>(Key); It != <a class="code" href="classllvm_1_1SparseMultiSet.html#a6123d1aa335e5d9c6299050c2cc5193e">end</a>(); ++It)</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;      ++Ret;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacellvm_1_1AArch64ISD.html#a246d89cb58f606179b1435937830bbdca84e96c468affe3b1fd3076b4fc5d063e">Ret</a>;</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;  }</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="comment">  /// Returns true if this set contains an element identified by Key.</span></div><div class="line"><a name="l00399"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#af23cb8c07f7bd9c7df0a85434aa8a0c2">  399</a></span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#af23cb8c07f7bd9c7df0a85434aa8a0c2">contains</a>(<span class="keyword">const</span> KeyT &amp;Key)<span class="keyword"> const </span>{</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a007d043f89bfaefaec158a7e93b39832">find</a>(Key) != <a class="code" href="classllvm_1_1SparseMultiSet.html#a6123d1aa335e5d9c6299050c2cc5193e">end</a>();</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;  }</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;<span class="comment">  /// Return the head and tail of the subset&#39;s list, otherwise returns end().</span></div><div class="line"><a name="l00404"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#a9bbecf0bb2b7cc5819bb54f53fbf4622">  404</a></span>&#160;<span class="comment"></span>  iterator <a class="code" href="classllvm_1_1SparseMultiSet.html#a9bbecf0bb2b7cc5819bb54f53fbf4622">getHead</a>(<span class="keyword">const</span> KeyT &amp;Key) { <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a007d043f89bfaefaec158a7e93b39832">find</a>(Key); }</div><div class="line"><a name="l00405"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#aa107631835001303a52fc79b695d2f41">  405</a></span>&#160;  iterator <a class="code" href="classllvm_1_1SparseMultiSet.html#aa107631835001303a52fc79b695d2f41">getTail</a>(<span class="keyword">const</span> KeyT &amp;Key) {</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    iterator <a class="code" href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">I</a> = <a class="code" href="classllvm_1_1SparseMultiSet.html#a007d043f89bfaefaec158a7e93b39832">find</a>(Key);</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    <span class="keywordflow">if</span> (I != <a class="code" href="classllvm_1_1SparseMultiSet.html#a6123d1aa335e5d9c6299050c2cc5193e">end</a>())</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;      I = <a class="code" href="classllvm_1_1SparseMultiSet.html#a5a05b79eda02945cb09d6202624f7fa4">iterator</a>(<span class="keyword">this</span>, I.Prev(), KeyIndexOf(Key));</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">I</a>;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;  }</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="comment">  /// The bounds of the range of items sharing Key K. First member is the head</span></div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="comment">  /// of the list, and the second member is a decrementable end iterator for</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="comment">  /// that key.</span></div><div class="line"><a name="l00415"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#ac92517e8c9066cbd446b0589a50c16f6">  415</a></span>&#160;<span class="comment"></span>  RangePair <a class="code" href="classllvm_1_1SparseMultiSet.html#ac92517e8c9066cbd446b0589a50c16f6">equal_range</a>(<span class="keyword">const</span> KeyT &amp;K) {</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    iterator <a class="code" href="Target_2ARM_2README_8txt.html#a90cca76dd78688687e0d697679dbc799">B</a> = <a class="code" href="classllvm_1_1SparseMultiSet.html#a007d043f89bfaefaec158a7e93b39832">find</a>(K);</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    iterator E = <a class="code" href="classllvm_1_1SparseMultiSet.html#a5a05b79eda02945cb09d6202624f7fa4">iterator</a>(<span class="keyword">this</span>, SMSNode::INVALID, B.SparseIdx);</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    <span class="keywordflow">return</span> make_pair(B, E);</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;  }</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;<span class="comment">  /// Insert a new element at the tail of the subset list. Returns an iterator</span></div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;<span class="comment">  /// to the newly added entry.</span></div><div class="line"><a name="l00423"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#a8586fb88f0c2e2236a1552292cba1dd3">  423</a></span>&#160;<span class="comment"></span>  iterator <a class="code" href="classllvm_1_1SparseMultiSet.html#a8586fb88f0c2e2236a1552292cba1dd3">insert</a>(<span class="keyword">const</span> ValueT &amp;Val) {</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    <span class="keywordtype">unsigned</span> Idx = sparseIndex(Val);</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    iterator <a class="code" href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">I</a> = <a class="code" href="classllvm_1_1SparseMultiSet.html#a16a780296035cd55839932310e5dc672">findIndex</a>(Idx);</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <span class="keywordtype">unsigned</span> NodeIdx = addValue(Val, SMSNode::INVALID, SMSNode::INVALID);</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    <span class="keywordflow">if</span> (I == <a class="code" href="classllvm_1_1SparseMultiSet.html#a6123d1aa335e5d9c6299050c2cc5193e">end</a>()) {</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;      <span class="comment">// Make a singleton list</span></div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;      Sparse[Idx] = NodeIdx;</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;      Dense[NodeIdx].Prev = NodeIdx;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a5a05b79eda02945cb09d6202624f7fa4">iterator</a>(<span class="keyword">this</span>, NodeIdx, Idx);</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    }</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;    <span class="comment">// Stick it at the end.</span></div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    <span class="keywordtype">unsigned</span> HeadIdx = I.Idx;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    <span class="keywordtype">unsigned</span> TailIdx = I.Prev();</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    Dense[TailIdx].Next = NodeIdx;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;    Dense[HeadIdx].Prev = NodeIdx;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    Dense[NodeIdx].Prev = TailIdx;</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a5a05b79eda02945cb09d6202624f7fa4">iterator</a>(<span class="keyword">this</span>, NodeIdx, Idx);</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;  }</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;<span class="comment">  /// Erases an existing element identified by a valid iterator.</span></div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;<span class="comment">  /// This invalidates iterators pointing at the same entry, but erase() returns</span></div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;<span class="comment">  /// an iterator pointing to the next element in the subset&#39;s list. This makes</span></div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;<span class="comment">  /// it possible to erase selected elements while iterating over the subset:</span></div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;<span class="comment">  ///   tie(I, E) = Set.equal_range(Key);</span></div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;<span class="comment">  ///   while (I != E)</span></div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;<span class="comment">  ///     if (test(*I))</span></div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;<span class="comment">  ///       I = Set.erase(I);</span></div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;<span class="comment">  ///     else</span></div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;<span class="comment">  ///       ++I;</span></div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;<span class="comment">  /// Note that if the last element in the subset list is erased, this will</span></div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;<span class="comment">  /// return an end iterator which can be decremented to get the new tail (if it</span></div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="comment">  /// exists):</span></div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;<span class="comment">  ///  tie(B, I) = Set.equal_range(Key);</span></div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="comment">  ///  for (bool isBegin = B == I; !isBegin; /* empty */) {</span></div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;<span class="comment">  ///    isBegin = (--I) == B;</span></div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;<span class="comment">  ///    if (test(I))</span></div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;<span class="comment">  ///      break;</span></div><div class="line"><a name="l00468"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">  468</a></span>&#160;<span class="comment">  ///    I = erase(I);</span></div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;<span class="comment">  ///  }</span></div><div class="line"><a name="l00470"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#a6500bc123ee62205ff472b6257d6449b">  470</a></span>&#160;<span class="comment"></span>  iterator <a class="code" href="classllvm_1_1SparseMultiSet.html#a6500bc123ee62205ff472b6257d6449b">erase</a>(iterator <a class="code" href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">I</a>) {</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    assert(I.isKeyed() &amp;&amp; !I.isEnd() &amp;&amp; !Dense[I.Idx].isTombstone() &amp;&amp;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;           <span class="stringliteral">&quot;erasing invalid/end/tombstone iterator&quot;</span>);</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    <span class="comment">// First, unlink the node from its list. Then swap the node out with the</span></div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;    <span class="comment">// dense vector&#39;s last entry</span></div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    iterator NextI = <a class="code" href="namespacellvm_1_1LibFunc.html#abf8f6830387f338fed0bce2e65108c6faf883e0410537d3920543f4aa7fe2626c">unlink</a>(Dense[I.Idx]);</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    <span class="comment">// Put in a tombstone.</span></div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    makeTombstone(I.Idx);</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    <span class="keywordflow">return</span> NextI;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;  }</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;<span class="comment">  /// Erase all elements with the given key. This invalidates all</span></div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;<span class="comment">  /// iterators of that key.</span></div><div class="line"><a name="l00486"></a><span class="lineno"><a class="line" href="classllvm_1_1SparseMultiSet.html#ab911382d02334b8421f4dbca8c53ff27">  486</a></span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#ab911382d02334b8421f4dbca8c53ff27">eraseAll</a>(<span class="keyword">const</span> KeyT &amp;K) {</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    <span class="keywordflow">for</span> (iterator <a class="code" href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">I</a> = <a class="code" href="classllvm_1_1SparseMultiSet.html#a007d043f89bfaefaec158a7e93b39832">find</a>(K); <a class="code" href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">I</a> != <a class="code" href="classllvm_1_1SparseMultiSet.html#a6123d1aa335e5d9c6299050c2cc5193e">end</a>(); <span class="comment">/* empty */</span>)</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;      <a class="code" href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">I</a> = <a class="code" href="classllvm_1_1SparseMultiSet.html#a6500bc123ee62205ff472b6257d6449b">erase</a>(<a class="code" href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">I</a>);</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;  }</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;<span class="keyword">private</span>:<span class="comment"></span></div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;<span class="comment">  /// Unlink the node from its list. Returns the next node in the list.</span></div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;<span class="comment"></span>  iterator <a class="code" href="namespacellvm_1_1LibFunc.html#abf8f6830387f338fed0bce2e65108c6faf883e0410537d3920543f4aa7fe2626c">unlink</a>(<span class="keyword">const</span> SMSNode &amp;N) {</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    <span class="keywordflow">if</span> (isSingleton(N)) {</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;      <span class="comment">// Singleton is already unlinked</span></div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;      assert(N.Next == SMSNode::INVALID &amp;&amp; <span class="stringliteral">&quot;Singleton has next?&quot;</span>);</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a5a05b79eda02945cb09d6202624f7fa4">iterator</a>(<span class="keyword">this</span>, SMSNode::INVALID, ValIndexOf(N.Data));</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    }</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    <span class="keywordflow">if</span> (isHead(N)) {</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;      <span class="comment">// If we&#39;re the head, then update the sparse array and our next.</span></div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;      Sparse[sparseIndex(N)] = N.Next;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;      Dense[N.Next].Prev = N.Prev;</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a5a05b79eda02945cb09d6202624f7fa4">iterator</a>(<span class="keyword">this</span>, N.Next, ValIndexOf(N.Data));</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    }</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;    <span class="keywordflow">if</span> (N.isTail()) {</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;      <span class="comment">// If we&#39;re the tail, then update our head and our previous.</span></div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;      <a class="code" href="classllvm_1_1SparseMultiSet.html#a16a780296035cd55839932310e5dc672">findIndex</a>(sparseIndex(N)).setPrev(N.Prev);</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;      Dense[N.Prev].Next = N.Next;</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;      <span class="comment">// Give back an end iterator that can be decremented</span></div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;      iterator <a class="code" href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">I</a>(<span class="keyword">this</span>, N.Prev, ValIndexOf(N.Data));</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;      <span class="keywordflow">return</span> ++<a class="code" href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">I</a>;</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;    }</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;    <span class="comment">// Otherwise, just drop us</span></div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;    Dense[N.Next].Prev = N.Prev;</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;    Dense[N.Prev].Next = N.Next;</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1SparseMultiSet.html#a5a05b79eda02945cb09d6202624f7fa4">iterator</a>(<span class="keyword">this</span>, N.Next, ValIndexOf(N.Data));</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;  }</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;};</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;} <span class="comment">// end namespace llvm</span></div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;<span class="preprocessor">#endif</span></div><div class="ttc" id="classllvm_1_1SparseMultiSet_html_a6123d1aa335e5d9c6299050c2cc5193e"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#a6123d1aa335e5d9c6299050c2cc5193e">llvm::SparseMultiSet::end</a></div><div class="ttdeci">iterator end()</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00320">SparseMultiSet.h:320</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorTemplateCommon_html_a22a311dfe4c28a897de8a9365a4f0a84"><div class="ttname"><a href="classllvm_1_1SmallVectorTemplateCommon.html#a22a311dfe4c28a897de8a9365a4f0a84">llvm::SmallVectorTemplateCommon::size</a></div><div class="ttdeci">size_type size() const </div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00127">SmallVector.h:127</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorTemplateBase_html_ae1a10b90f22c0478960fb5798ff73916"><div class="ttname"><a href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">llvm::SmallVectorTemplateBase::push_back</a></div><div class="ttdeci">void push_back(const T &amp;Elt)</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00236">SmallVector.h:236</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_1_1iterator__base_html_aaadb87b8b56aed717dee2e82373bc64a"><div class="ttname"><a href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#aaadb87b8b56aed717dee2e82373bc64a">llvm::SparseMultiSet::iterator_base::reference</a></div><div class="ttdeci">super::reference reference</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00246">SparseMultiSet.h:246</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_a60e716d1343927746b0f9f9cdcbc9e94"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#a60e716d1343927746b0f9f9cdcbc9e94">llvm::SparseMultiSet::value_type</a></div><div class="ttdeci">ValueT value_type</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00179">SparseMultiSet.h:179</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_1_1iterator__base_html_afafb4cb5eaafd087d1518f488ebcd5b2"><div class="ttname"><a href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#afafb4cb5eaafd087d1518f488ebcd5b2">llvm::SparseMultiSet::iterator_base::operator=</a></div><div class="ttdeci">const iterator_base &amp; operator=(const iterator_base &amp;RHS)</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00251">SparseMultiSet.h:251</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_a8586fb88f0c2e2236a1552292cba1dd3"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#a8586fb88f0c2e2236a1552292cba1dd3">llvm::SparseMultiSet::insert</a></div><div class="ttdeci">iterator insert(const ValueT &amp;Val)</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00423">SparseMultiSet.h:423</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_af23cb8c07f7bd9c7df0a85434aa8a0c2"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#af23cb8c07f7bd9c7df0a85434aa8a0c2">llvm::SparseMultiSet::contains</a></div><div class="ttdeci">bool contains(const KeyT &amp;Key) const </div><div class="ttdoc">Returns true if this set contains an element identified by Key. </div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00399">SparseMultiSet.h:399</a></div></div>
<div class="ttc" id="namespacellvm_html"><div class="ttname"><a href="namespacellvm.html">llvm</a></div><div class="ttdoc">List of target independent CodeGen pass IDs. </div><div class="ttdef"><b>Definition:</b> <a href="APFloat_8h_source.html#l00022">APFloat.h:22</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_a8c07f91492bf91fe8dc6b8eef80a131c"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#a8c07f91492bf91fe8dc6b8eef80a131c">llvm::SparseMultiSet::I</a></div><div class="ttdeci">* I</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00468">SparseMultiSet.h:468</a></div></div>
<div class="ttc" id="README-SSE_8txt_html_a63d206a063eefcdf8c318ded97b65020"><div class="ttname"><a href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a></div><div class="ttdeci">This currently compiles esp xmm0 movsd esp eax eax esp ret We should use not the dag combiner This is because dagcombine2 needs to be able to see through the X86ISD::Wrapper which DAGCombine can t really do The code for turning x load into a single vector load is target independent and should be moved to the dag combiner The code for turning x load into a vector load can only handle a direct load from a global or a direct load from the stack It should be generalized to handle any load from P</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00427">README-SSE.txt:427</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_a60a82e2dbc82339b5e527a38fb0677f8"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#a60a82e2dbc82339b5e527a38fb0677f8">llvm::SparseMultiSet::reference</a></div><div class="ttdeci">ValueT &amp; reference</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00180">SparseMultiSet.h:180</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_1_1iterator__base_html_a3e19644ee8a7fadddca08081de300200"><div class="ttname"><a href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a3e19644ee8a7fadddca08081de300200">llvm::SparseMultiSet::iterator_base::operator--</a></div><div class="ttdeci">iterator_base &amp; operator--()</div><div class="ttdoc">Increment and decrement operators. </div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00283">SparseMultiSet.h:283</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_abb5808737d5bc560a7c8f797433e8182"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#abb5808737d5bc560a7c8f797433e8182">llvm::SparseMultiSet::find</a></div><div class="ttdeci">const_iterator find(const KeyT &amp;Key) const </div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00383">SparseMultiSet.h:383</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_ac92517e8c9066cbd446b0589a50c16f6"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#ac92517e8c9066cbd446b0589a50c16f6">llvm::SparseMultiSet::equal_range</a></div><div class="ttdeci">RangePair equal_range(const KeyT &amp;K)</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00415">SparseMultiSet.h:415</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_a85861f4b52d943fe6c6911b2c60625ab"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#a85861f4b52d943fe6c6911b2c60625ab">llvm::SparseMultiSet::SparseMultiSet</a></div><div class="ttdeci">SparseMultiSet()</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00185">SparseMultiSet.h:185</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_a5a05b79eda02945cb09d6202624f7fa4"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#a5a05b79eda02945cb09d6202624f7fa4">llvm::SparseMultiSet::iterator</a></div><div class="ttdeci">iterator_base&lt; SparseMultiSet * &gt; iterator</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00312">SparseMultiSet.h:312</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_a9bbecf0bb2b7cc5819bb54f53fbf4622"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#a9bbecf0bb2b7cc5819bb54f53fbf4622">llvm::SparseMultiSet::getHead</a></div><div class="ttdeci">iterator getHead(const KeyT &amp;Key)</div><div class="ttdoc">Return the head and tail of the subset&amp;#39;s list, otherwise returns end(). </div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00404">SparseMultiSet.h:404</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_a05191a6f8484d590cc004027e3e61144"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#a05191a6f8484d590cc004027e3e61144">llvm::SparseMultiSet::const_pointer</a></div><div class="ttdeci">const ValueT * const_pointer</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00183">SparseMultiSet.h:183</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_aa107631835001303a52fc79b695d2f41"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#aa107631835001303a52fc79b695d2f41">llvm::SparseMultiSet::getTail</a></div><div class="ttdeci">iterator getTail(const KeyT &amp;Key)</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00405">SparseMultiSet.h:405</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_ab3bce59716d1338c5ec42309029704e6"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#ab3bce59716d1338c5ec42309029704e6">llvm::SparseMultiSet::pointer</a></div><div class="ttdeci">ValueT * pointer</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00182">SparseMultiSet.h:182</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_1_1iterator__base_html_a9c7fc0e07b570a2773e4dce72cce553b"><div class="ttname"><a href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a9c7fc0e07b570a2773e4dce72cce553b">llvm::SparseMultiSet::iterator_base::operator++</a></div><div class="ttdeci">iterator_base &amp; operator++()</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00296">SparseMultiSet.h:296</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_1_1iterator__base_html_a21292ed929dc2a97f2e897aaa2b6d300"><div class="ttname"><a href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a21292ed929dc2a97f2e897aaa2b6d300">llvm::SparseMultiSet::iterator_base::operator++</a></div><div class="ttdeci">iterator_base operator++(int)</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00306">SparseMultiSet.h:306</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_ad48508707ac902124dfd05481728014f"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#ad48508707ac902124dfd05481728014f">llvm::SparseMultiSet::~SparseMultiSet</a></div><div class="ttdeci">~SparseMultiSet()</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00188">SparseMultiSet.h:188</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_aad80836d7fbed3e386912eb8596e2743"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#aad80836d7fbed3e386912eb8596e2743">llvm::SparseMultiSet::const_iterator</a></div><div class="ttdeci">iterator_base&lt; const SparseMultiSet * &gt; const_iterator</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00313">SparseMultiSet.h:313</a></div></div>
<div class="ttc" id="namespacellvm_1_1AArch64ISD_html_a246d89cb58f606179b1435937830bbdca84e96c468affe3b1fd3076b4fc5d063e"><div class="ttname"><a href="namespacellvm_1_1AArch64ISD.html#a246d89cb58f606179b1435937830bbdca84e96c468affe3b1fd3076b4fc5d063e">llvm::AArch64ISD::Ret</a></div><div class="ttdef"><b>Definition:</b> <a href="AArch64ISelLowering_8h_source.html#l00060">AArch64ISelLowering.h:60</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorImpl_html_aac0ea55010b7b1a301e65a0baea057aa"><div class="ttname"><a href="classllvm_1_1SmallVectorImpl.html#aac0ea55010b7b1a301e65a0baea057aa">llvm::SmallVectorImpl::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00396">SmallVector.h:396</a></div></div>
<div class="ttc" id="namespacellvm_1_1LibFunc_html_abf8f6830387f338fed0bce2e65108c6fa60e05e8cf4600d05ec9251b750544c7c"><div class="ttname"><a href="namespacellvm_1_1LibFunc.html#abf8f6830387f338fed0bce2e65108c6fa60e05e8cf4600d05ec9251b750544c7c">llvm::LibFunc::free</a></div><div class="ttdoc">void free(void *ptr); </div><div class="ttdef"><b>Definition:</b> <a href="TargetLibraryInfo_8h_source.html#l00273">TargetLibraryInfo.h:273</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_1_1iterator__base_html_a0365e14859d40f92a05acaac517094e3"><div class="ttname"><a href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a0365e14859d40f92a05acaac517094e3">llvm::SparseMultiSet::iterator_base::value_type</a></div><div class="ttdeci">super::value_type value_type</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00243">SparseMultiSet.h:243</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_af781b01667ff848f2b07b4b51660a714"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#af781b01667ff848f2b07b4b51660a714">llvm::SparseMultiSet::setUniverse</a></div><div class="ttdeci">void setUniverse(unsigned U)</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00195">SparseMultiSet.h:195</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_1_1iterator__base_html_a3cfb35c0ca65fa9277bd50b812bb4bc9"><div class="ttname"><a href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a3cfb35c0ca65fa9277bd50b812bb4bc9">llvm::SparseMultiSet::iterator_base::operator-&gt;</a></div><div class="ttdeci">pointer operator-&gt;() const </div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00264">SparseMultiSet.h:264</a></div></div>
<div class="ttc" id="namespacellvm_1_1LibFunc_html_abf8f6830387f338fed0bce2e65108c6faf883e0410537d3920543f4aa7fe2626c"><div class="ttname"><a href="namespacellvm_1_1LibFunc.html#abf8f6830387f338fed0bce2e65108c6faf883e0410537d3920543f4aa7fe2626c">llvm::LibFunc::unlink</a></div><div class="ttdoc">int unlink(const char *path); </div><div class="ttdef"><b>Definition:</b> <a href="TargetLibraryInfo_8h_source.html#l00624">TargetLibraryInfo.h:624</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_a2554bf4e6f211e29c3e80fd4c9141c79"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#a2554bf4e6f211e29c3e80fd4c9141c79">llvm::SparseMultiSet::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00343">SparseMultiSet.h:343</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_a007d043f89bfaefaec158a7e93b39832"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#a007d043f89bfaefaec158a7e93b39832">llvm::SparseMultiSet::find</a></div><div class="ttdeci">iterator find(const KeyT &amp;Key)</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00379">SparseMultiSet.h:379</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_1_1iterator__base_html_a4bb0ab76d97bd15bcd884ffedbedf3c3"><div class="ttname"><a href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a4bb0ab76d97bd15bcd884ffedbedf3c3">llvm::SparseMultiSet::iterator_base::pointer</a></div><div class="ttdeci">super::pointer pointer</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00245">SparseMultiSet.h:245</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_aeb3fe6e0de21d69233fc63b2d26f9aa7"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#aeb3fe6e0de21d69233fc63b2d26f9aa7">llvm::SparseMultiSet::end</a></div><div class="ttdeci">const_iterator end() const </div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00321">SparseMultiSet.h:321</a></div></div>
<div class="ttc" id="Target_2README_8txt_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">i</div><div class="ttdef"><b>Definition:</b> <a href="Target_2README_8txt_source.html#l00029">Target/README.txt:29</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_1_1iterator__base_html_a4c31ff4b5054b9fd7350b5d41fa963ea"><div class="ttname"><a href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a4c31ff4b5054b9fd7350b5d41fa963ea">llvm::SparseMultiSet::iterator_base::operator*</a></div><div class="ttdeci">reference operator*() const </div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00258">SparseMultiSet.h:258</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVector_html"><div class="ttname"><a href="classllvm_1_1SmallVector.html">llvm::SmallVector&lt; SMSNode, 8 &gt;</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_1_1iterator__base_html_ae25c4a3950e490375740861d3fd254e3"><div class="ttname"><a href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#ae25c4a3950e490375740861d3fd254e3">llvm::SparseMultiSet::iterator_base::operator--</a></div><div class="ttdeci">iterator_base operator--(int)</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00301">SparseMultiSet.h:301</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_1_1iterator__base_html_a649c4b7d00e65192814844a03605caa1"><div class="ttname"><a href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a649c4b7d00e65192814844a03605caa1">llvm::SparseMultiSet::iterator_base::difference_type</a></div><div class="ttdeci">super::difference_type difference_type</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00244">SparseMultiSet.h:244</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_ab911382d02334b8421f4dbca8c53ff27"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#ab911382d02334b8421f4dbca8c53ff27">llvm::SparseMultiSet::eraseAll</a></div><div class="ttdeci">void eraseAll(const KeyT &amp;K)</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00486">SparseMultiSet.h:486</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_a16a780296035cd55839932310e5dc672"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#a16a780296035cd55839932310e5dc672">llvm::SparseMultiSet::findIndex</a></div><div class="ttdeci">iterator findIndex(unsigned Idx)</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00355">SparseMultiSet.h:355</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_ac8d3a507aeb3c626ad4ac4b28312b191"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#ac8d3a507aeb3c626ad4ac4b28312b191">llvm::SparseMultiSet::count</a></div><div class="ttdeci">unsigned count(const KeyT &amp;Key) const </div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00390">SparseMultiSet.h:390</a></div></div>
<div class="ttc" id="Compiler_8h_html_aacca75352b8e153274310c374564eb01"><div class="ttname"><a href="Compiler_8h.html#aacca75352b8e153274310c374564eb01">LLVM_DELETED_FUNCTION</a></div><div class="ttdeci">#define LLVM_DELETED_FUNCTION</div><div class="ttdef"><b>Definition:</b> <a href="Compiler_8h_source.html#l00137">Compiler.h:137</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_a6500bc123ee62205ff472b6257d6449b"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#a6500bc123ee62205ff472b6257d6449b">llvm::SparseMultiSet::erase</a></div><div class="ttdeci">**iterator erase(iterator I)</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00470">SparseMultiSet.h:470</a></div></div>
<div class="ttc" id="structllvm_1_1SparseSetValFunctor_html"><div class="ttname"><a href="structllvm_1_1SparseSetValFunctor.html">llvm::SparseSetValFunctor</a></div><div class="ttdef"><b>Definition:</b> <a href="SparseSet_8h_source.html#l00064">SparseSet.h:64</a></div></div>
<div class="ttc" id="SparseSet_8h_html"><div class="ttname"><a href="SparseSet_8h.html">SparseSet.h</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_1_1iterator__base_html_a40fd54d421bd36f861db8d56e817b43c"><div class="ttname"><a href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a40fd54d421bd36f861db8d56e817b43c">llvm::SparseMultiSet::iterator_base::iterator_base</a></div><div class="ttdeci">iterator_base(const iterator_base &amp;RHS)</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00248">SparseMultiSet.h:248</a></div></div>
<div class="ttc" id="regcomp_8c_html_a0240ac851181b84ac374872dc5434ee4"><div class="ttname"><a href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a></div><div class="ttdeci">#define N</div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_1_1iterator__base_html_a9f33c6f0c3b8a457af259add31335cce"><div class="ttname"><a href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#a9f33c6f0c3b8a457af259add31335cce">llvm::SparseMultiSet::iterator_base::super</a></div><div class="ttdeci">std::iterator&lt; std::bidirectional_iterator_tag, ValueT &gt; super</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00242">SparseMultiSet.h:242</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_1_1iterator__base_html_af9458343f244f31363e1a2ef1d48367a"><div class="ttname"><a href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#af9458343f244f31363e1a2ef1d48367a">llvm::SparseMultiSet::iterator_base::operator!=</a></div><div class="ttdeci">bool operator!=(const iterator_base &amp;RHS) const </div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00278">SparseMultiSet.h:278</a></div></div>
<div class="ttc" id="structllvm_1_1identity_html"><div class="ttname"><a href="structllvm_1_1identity.html">llvm::identity&lt; unsigned &gt;</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html">llvm::SparseMultiSet</a></div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00078">SparseMultiSet.h:78</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_a56623897a22446f188d99b1ae7a004ac"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#a56623897a22446f188d99b1ae7a004ac">llvm::SparseMultiSet::empty</a></div><div class="ttdeci">bool empty() const </div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00329">SparseMultiSet.h:329</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_1_1iterator__base_html"><div class="ttname"><a href="classllvm_1_1SparseMultiSet_1_1iterator__base.html">llvm::SparseMultiSet::iterator_base</a></div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00213">SparseMultiSet.h:213</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_a7b2bf65ef72ddaadb5a2a6c274af2a6e"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#a7b2bf65ef72ddaadb5a2a6c274af2a6e">llvm::SparseMultiSet::const_reference</a></div><div class="ttdeci">const ValueT &amp; const_reference</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00181">SparseMultiSet.h:181</a></div></div>
<div class="ttc" id="namespacellvm_html_a162c90bc179a6359438d060722bee35f"><div class="ttname"><a href="namespacellvm.html#a162c90bc179a6359438d060722bee35f">llvm::operator==</a></div><div class="ttdeci">bool operator==(uint64_t V1, const APInt &amp;V2)</div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l01684">APInt.h:1684</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_1_1iterator__base_html_af6af1649895276003eb58aebede8686e"><div class="ttname"><a href="classllvm_1_1SparseMultiSet_1_1iterator__base.html#af6af1649895276003eb58aebede8686e">llvm::SparseMultiSet::iterator_base::operator==</a></div><div class="ttdeci">bool operator==(const iterator_base &amp;RHS) const </div><div class="ttdoc">Comparison operators. </div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00267">SparseMultiSet.h:267</a></div></div>
<div class="ttc" id="Target_2ARM_2README_8txt_html_a90cca76dd78688687e0d697679dbc799"><div class="ttname"><a href="Target_2ARM_2README_8txt.html#a90cca76dd78688687e0d697679dbc799">B</a></div><div class="ttdeci">compiles ldr LCPI1_0 ldr ldr mov lsr tst moveq r1 ldr LCPI1_1 and r0 bx lr It would be better to do something like to fold the shift into the conditional ldr LCPI1_0 ldr ldr tst movne lsr ldr LCPI1_1 and r0 bx lr it saves an instruction and a register It might be profitable to cse MOVi16 if there are lots of bit immediates with the same bottom half Robert Muth started working on an alternate jump table implementation that does not put the tables in line in the text This is more like the llvm default jump table implementation This might be useful sometime Several revisions of patches are on the mailing beginning while CMP sets them like a subtract Therefore to be able to use CMN for comparisons other than the Z we ll need additional logic to reverse the conditionals associated with the comparison Perhaps a pseudo instruction for the with a post codegen pass to clean up and handle the condition codes See PR5694 for testcase Given the following on int B</div><div class="ttdef"><b>Definition:</b> <a href="Target_2ARM_2README_8txt_source.html#l00592">Target/ARM/README.txt:592</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_ae9320934e3ae489cb0f70d01dd0bd053"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#ae9320934e3ae489cb0f70d01dd0bd053">llvm::SparseMultiSet::RangePair</a></div><div class="ttdeci">std::pair&lt; iterator, iterator &gt; RangePair</div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00316">SparseMultiSet.h:316</a></div></div>
<div class="ttc" id="namespacellvm_1_1LibFunc_html_abf8f6830387f338fed0bce2e65108c6fa3ad9aa19face37d539b9fbe4130e1c6f"><div class="ttname"><a href="namespacellvm_1_1LibFunc.html#abf8f6830387f338fed0bce2e65108c6fa3ad9aa19face37d539b9fbe4130e1c6f">llvm::LibFunc::calloc</a></div><div class="ttdoc">void *calloc(size_t count, size_t size); </div><div class="ttdef"><b>Definition:</b> <a href="TargetLibraryInfo_8h_source.html#l00149">TargetLibraryInfo.h:149</a></div></div>
<div class="ttc" id="classllvm_1_1SparseMultiSet_html_a6a93435ad61b876b5542533316a8920a"><div class="ttname"><a href="classllvm_1_1SparseMultiSet.html#a6a93435ad61b876b5542533316a8920a">llvm::SparseMultiSet::size</a></div><div class="ttdeci">unsigned size() const </div><div class="ttdef"><b>Definition:</b> <a href="SparseMultiSet_8h_source.html#l00336">SparseMultiSet.h:336</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<hr>
<p class="footer">
Generated on Sat Nov 10 2018 23:02:21 for <a href="http://llvm.org/">LLVM</a> by
<a href="http://www.doxygen.org"><img src="doxygen.png" alt="Doxygen"
align="middle" border="0"/>1.8.11</a><br>
Copyright &copy; 2003-2013 University of Illinois at Urbana-Champaign.
All Rights Reserved.</p>
<hr>
<!--#include virtual="/attrib.incl" -->
</body>
</html>
