<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="keywords" content="LLVM,Low Level Virtual Machine,C++,doxygen,API,documentation"/>
<meta name="description" content="C++ source code API documentation for LLVM."/>
<title>LLVM: TypeBasedAliasAnalysis.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head><body>
<p class="title">LLVM API Documentation</p>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('TypeBasedAliasAnalysis_8cpp_source.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">TypeBasedAliasAnalysis.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="TypeBasedAliasAnalysis_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//===- TypeBasedAliasAnalysis.cpp - Type-Based Alias Analysis -------------===//</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">//                     The LLVM Compiler Infrastructure</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// This file is distributed under the University of Illinois Open Source</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">// License. See LICENSE.TXT for details.</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">// This file defines the TypeBasedAliasAnalysis pass, which implements</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">// metadata-based TBAA.</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">// In LLVM IR, memory does not have types, so LLVM&#39;s own type system is not</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">// suitable for doing TBAA. Instead, metadata is added to the IR to describe</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">// a type system of a higher level language. This can be used to implement</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">// typical C/C++ TBAA, but it can also be used to implement custom alias</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">// analysis behavior for other languages.</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">// We now support two types of metadata format: scalar TBAA and struct-path</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">// aware TBAA. After all testing cases are upgraded to use struct-path aware</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment">// TBAA and we can auto-upgrade existing bc files, the support for scalar TBAA</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">// can be dropped.</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment">// The scalar TBAA metadata format is very simple. TBAA MDNodes have up to</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment">// three fields, e.g.:</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment">//   !0 = metadata !{ metadata !&quot;an example type tree&quot; }</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment">//   !1 = metadata !{ metadata !&quot;int&quot;, metadata !0 }</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment">//   !2 = metadata !{ metadata !&quot;float&quot;, metadata !0 }</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">//   !3 = metadata !{ metadata !&quot;const float&quot;, metadata !2, i64 1 }</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment">// The first field is an identity field. It can be any value, usually</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment">// an MDString, which uniquely identifies the type. The most important</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment">// name in the tree is the name of the root node. Two trees with</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="comment">// different root node names are entirely disjoint, even if they</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment">// have leaves with common names.</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment">// The second field identifies the type&#39;s parent node in the tree, or</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">// is null or omitted for a root node. A type is considered to alias</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">// all of its descendants and all of its ancestors in the tree. Also,</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment">// a type is considered to alias all types in other trees, so that</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment">// bitcode produced from multiple front-ends is handled conservatively.</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="comment">// If the third field is present, it&#39;s an integer which if equal to 1</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="comment">// indicates that the type is &quot;constant&quot; (meaning pointsToConstantMemory</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment">// should return true; see</span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="comment">// http://llvm.org/docs/AliasAnalysis.html#OtherItfs).</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment">// With struct-path aware TBAA, the MDNodes attached to an instruction using</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment">// &quot;!tbaa&quot; are called path tag nodes.</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment">// The path tag node has 4 fields with the last field being optional.</span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment">// The first field is the base type node, it can be a struct type node</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment">// or a scalar type node. The second field is the access type node, it</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment">// must be a scalar type node. The third field is the offset into the base type.</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment">// The last field has the same meaning as the last field of our scalar TBAA:</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment">// it&#39;s an integer which if equal to 1 indicates that the access is &quot;constant&quot;.</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment">// The struct type node has a name and a list of pairs, one pair for each member</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment">// of the struct. The first element of each pair is a type node (a struct type</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment">// node or a sclar type node), specifying the type of the member, the second</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment">// element of each pair is the offset of the member.</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment">// Given an example</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment">// typedef struct {</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment">//   short s;</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment">// } A;</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="comment">// typedef struct {</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="comment">//   uint16_t s;</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="comment">//   A a;</span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment">// } B;</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="comment">// For an acess to B.a.s, we attach !5 (a path tag node) to the load/store</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="comment">// instruction. The base type is !4 (struct B), the access type is !2 (scalar</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment">// type short) and the offset is 4.</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="comment">// !0 = metadata !{metadata !&quot;Simple C/C++ TBAA&quot;}</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="comment">// !1 = metadata !{metadata !&quot;omnipotent char&quot;, metadata !0} // Scalar type node</span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="comment">// !2 = metadata !{metadata !&quot;short&quot;, metadata !1}           // Scalar type node</span></div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="comment">// !3 = metadata !{metadata !&quot;A&quot;, metadata !2, i64 0}        // Struct type node</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="comment">// !4 = metadata !{metadata !&quot;B&quot;, metadata !2, i64 0, metadata !3, i64 4}</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="comment">//                                                           // Struct type node</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="comment">// !5 = metadata !{metadata !4, metadata !2, i64 4}          // Path tag node</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="comment">// The struct type nodes and the scalar type nodes form a type DAG.</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="comment">//         Root (!0)</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="comment">//         char (!1)  -- edge to Root</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="comment">//         short (!2) -- edge to char</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="comment">//         A (!3) -- edge with offset 0 to short</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="comment">//         B (!4) -- edge with offset 0 to short and edge with offset 4 to A</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment">// To check if two tags (tagX and tagY) can alias, we start from the base type</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment">// of tagX, follow the edge with the correct offset in the type DAG and adjust</span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="comment">// the offset until we reach the base type of tagY or until we reach the Root</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment">// node.</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="comment">// If we reach the base type of tagY, compare the adjusted offset with</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="comment">// offset of tagY, return Alias if the offsets are the same, return NoAlias</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="comment">// otherwise.</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="comment">// If we reach the Root node, perform the above starting from base type of tagY</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="comment">// to see if we reach base type of tagX.</span></div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="comment">// If they have different roots, they&#39;re part of different potentially</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="comment">// unrelated type systems, so we return Alias to be conservative.</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="comment">// If neither node is an ancestor of the other and they have the same root,</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="comment">// then we say NoAlias.</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="comment">// TODO: The current metadata format doesn&#39;t support struct</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="comment">// fields. For example:</span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment">//   struct X {</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="comment">//     double d;</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment">//     int i;</span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment">//   };</span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="comment">//   void foo(struct X *x, struct X *y, double *p) {</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="comment">//     *x = *y;</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment">//     *p = 0.0;</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment">//   }</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">// Struct X has a double member, so the store to *x can alias the store to *p.</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment">// Currently it&#39;s not possible to precisely describe all the things struct X</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment">// aliases, so struct assignments must use conservative TBAA nodes. There&#39;s</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment">// no scheme for attaching metadata to @llvm.memcpy yet either.</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Analysis_2Passes_8h.html">llvm/Analysis/Passes.h</a>&quot;</span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="AliasAnalysis_8h.html">llvm/Analysis/AliasAnalysis.h</a>&quot;</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Constants_8h.html">llvm/IR/Constants.h</a>&quot;</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="LLVMContext_8h.html">llvm/IR/LLVMContext.h</a>&quot;</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Metadata_8h.html">llvm/IR/Metadata.h</a>&quot;</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Module_8h.html">llvm/IR/Module.h</a>&quot;</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Pass_8h.html">llvm/Pass.h</a>&quot;</span></div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="CommandLine_8h.html">llvm/Support/CommandLine.h</a>&quot;</span></div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespacellvm.html">llvm</a>;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="comment">// A handy option for disabling TBAA functionality. The same effect can also be</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="comment">// achieved by stripping the !tbaa tags from IR, but this option is sometimes</span></div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="comment">// more convenient.</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="keyword">static</span> <a class="code" href="classllvm_1_1cl_1_1opt.html">cl::opt&lt;bool&gt;</a> <a class="code" href="TypeBasedAliasAnalysis_8cpp.html#ac9cc1aa1eaf0273f5628439f8f9026df">EnableTBAA</a>(<span class="stringliteral">&quot;enable-tbaa&quot;</span>, <a class="code" href="namespacellvm_1_1cl.html#a10a041239ae1870cfcc064bfaa79fb65">cl::init</a>(<span class="keyword">true</span>));</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="keyword">namespace </span>{<span class="comment"></span></div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="comment">  /// TBAANode - This is a simple wrapper around an MDNode which provides a</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="comment">  /// higher-level interface by hiding the details of how alias analysis</span></div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="comment">  /// information is encoded in its operands.</span></div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="comment"></span>  <span class="keyword">class </span>TBAANode {</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *Node;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  <span class="keyword">public</span>:</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    TBAANode() : Node(0) {}</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    <span class="keyword">explicit</span> TBAANode(<span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *<a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>) : Node(N) {}</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="comment">    /// getNode - Get the MDNode for this TBAANode.</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment"></span>    <span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *getNode()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> Node; }</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment">    /// getParent - Get this TBAANode&#39;s Alias tree parent.</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="comment"></span>    TBAANode <a class="code" href="BasicAliasAnalysis_8cpp.html#a2675de1d8479c7b00387979714da43f7">getParent</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;      <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#ade17b50e4f0b835cd9eb58dffe12a90d">getNumOperands</a>() &lt; 2)</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        <span class="keywordflow">return</span> TBAANode();</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;      <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *<a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a> = dyn_cast_or_null&lt;MDNode&gt;(Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">getOperand</a>(1));</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;      <span class="keywordflow">if</span> (!P)</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;        <span class="keywordflow">return</span> TBAANode();</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;      <span class="comment">// Ok, this node has a valid parent. Return it.</span></div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;      <span class="keywordflow">return</span> TBAANode(P);</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    }</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="comment">    /// TypeIsImmutable - Test if this TBAANode represents a type for objects</span></div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="comment">    /// which are not modified (by any means) in the context where this</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="comment">    /// AliasAnalysis is relevant.</span></div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="comment"></span>    <span class="keywordtype">bool</span> TypeIsImmutable()<span class="keyword"> const </span>{</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;      <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#ade17b50e4f0b835cd9eb58dffe12a90d">getNumOperands</a>() &lt; 3)</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;      <a class="code" href="classllvm_1_1ConstantInt.html">ConstantInt</a> *CI = <a class="code" href="namespacellvm.html#a3f2f98c2a67c9e79f58aad9150a62e42">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1ConstantInt.html">ConstantInt</a>&gt;(Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">getOperand</a>(2));</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;      <span class="keywordflow">if</span> (!CI)</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;      <span class="keywordflow">return</span> CI-&gt;<a class="code" href="classllvm_1_1ConstantInt.html#af8dde13a97efce293a7b04daf1e208fb">getValue</a>()[0];</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    }</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  };</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="comment">  /// This is a simple wrapper around an MDNode which provides a</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="comment">  /// higher-level interface by hiding the details of how alias analysis</span></div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="comment">  /// information is encoded in its operands.</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="comment"></span>  <span class="keyword">class </span>TBAAStructTagNode {<span class="comment"></span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="comment">    /// This node should be created with createTBAAStructTagNode.</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="comment"></span>    <span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *Node;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;  <span class="keyword">public</span>:</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    TBAAStructTagNode() : Node(0) {}</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    <span class="keyword">explicit</span> TBAAStructTagNode(<span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *<a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>) : Node(N) {}</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment">    /// Get the MDNode for this TBAAStructTagNode.</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment"></span>    <span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *getNode()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> Node; }</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *getBaseType()<span class="keyword"> const </span>{</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;      <span class="keywordflow">return</span> dyn_cast_or_null&lt;MDNode&gt;(Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">getOperand</a>(0));</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    }</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *<a class="code" href="LoopStrengthReduce_8cpp.html#a4f07d245cf5f31e5b86ee80c06ab949a">getAccessType</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;      <span class="keywordflow">return</span> dyn_cast_or_null&lt;MDNode&gt;(Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">getOperand</a>(1));</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    }</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    uint64_t getOffset()<span class="keyword"> const </span>{</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;      <span class="keywordflow">return</span> cast&lt;ConstantInt&gt;(Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">getOperand</a>(2))-&gt;getZExtValue();</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    }<span class="comment"></span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="comment">    /// TypeIsImmutable - Test if this TBAAStructTagNode represents a type for</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="comment">    /// objects which are not modified (by any means) in the context where this</span></div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="comment">    /// AliasAnalysis is relevant.</span></div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="comment"></span>    <span class="keywordtype">bool</span> TypeIsImmutable()<span class="keyword"> const </span>{</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;      <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#ade17b50e4f0b835cd9eb58dffe12a90d">getNumOperands</a>() &lt; 4)</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;      <a class="code" href="classllvm_1_1ConstantInt.html">ConstantInt</a> *CI = <a class="code" href="namespacellvm.html#a3f2f98c2a67c9e79f58aad9150a62e42">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1ConstantInt.html">ConstantInt</a>&gt;(Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">getOperand</a>(3));</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;      <span class="keywordflow">if</span> (!CI)</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;      <span class="keywordflow">return</span> CI-&gt;<a class="code" href="classllvm_1_1ConstantInt.html#af8dde13a97efce293a7b04daf1e208fb">getValue</a>()[0];</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    }</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;  };</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="comment">  /// This is a simple wrapper around an MDNode which provides a</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="comment">  /// higher-level interface by hiding the details of how alias analysis</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="comment">  /// information is encoded in its operands.</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="comment"></span>  <span class="keyword">class </span>TBAAStructTypeNode {<span class="comment"></span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="comment">    /// This node should be created with createTBAAStructTypeNode.</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="comment"></span>    <span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *Node;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;  <span class="keyword">public</span>:</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    TBAAStructTypeNode() : Node(0) {}</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="keyword">explicit</span> TBAAStructTypeNode(<span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *<a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>) : Node(N) {}</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="comment">    /// Get the MDNode for this TBAAStructTypeNode.</span></div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="comment"></span>    <span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *getNode()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> Node; }</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="comment">    /// Get this TBAAStructTypeNode&#39;s field in the type DAG with</span></div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment">    /// given offset. Update the offset to be relative to the field type.</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment"></span>    TBAAStructTypeNode <a class="code" href="BasicAliasAnalysis_8cpp.html#a2675de1d8479c7b00387979714da43f7">getParent</a>(uint64_t &amp;Offset)<span class="keyword"> const </span>{</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;      <span class="comment">// Parent can be omitted for the root node.</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;      <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#ade17b50e4f0b835cd9eb58dffe12a90d">getNumOperands</a>() &lt; 2)</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        <span class="keywordflow">return</span> TBAAStructTypeNode();</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;      <span class="comment">// Fast path for a scalar type node and a struct type node with a single</span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;      <span class="comment">// field.</span></div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;      <span class="keywordflow">if</span> (Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#ade17b50e4f0b835cd9eb58dffe12a90d">getNumOperands</a>() &lt;= 3) {</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        uint64_t Cur = Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#ade17b50e4f0b835cd9eb58dffe12a90d">getNumOperands</a>() == 2 ? 0 :</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;                       cast&lt;ConstantInt&gt;(Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">getOperand</a>(2))-&gt;getZExtValue();</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        Offset -= Cur;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *P = dyn_cast_or_null&lt;MDNode&gt;(Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">getOperand</a>(1));</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;        <span class="keywordflow">if</span> (!P)</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;          <span class="keywordflow">return</span> TBAAStructTypeNode();</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;        <span class="keywordflow">return</span> TBAAStructTypeNode(P);</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;      }</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;      <span class="comment">// Assume the offsets are in order. We return the previous field if</span></div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;      <span class="comment">// the current offset is bigger than the given offset.</span></div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;      <span class="keywordtype">unsigned</span> TheIdx = 0;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> Idx = 1; Idx &lt; Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#ade17b50e4f0b835cd9eb58dffe12a90d">getNumOperands</a>(); Idx += 2) {</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        uint64_t Cur = cast&lt;ConstantInt&gt;(Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">getOperand</a>(Idx + 1))-&gt;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                         getZExtValue();</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        <span class="keywordflow">if</span> (Cur &gt; Offset) {</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;          assert(Idx &gt;= 3 &amp;&amp;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;                 <span class="stringliteral">&quot;TBAAStructTypeNode::getParent should have an offset match!&quot;</span>);</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;          TheIdx = Idx - 2;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;          <span class="keywordflow">break</span>;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;        }</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;      }</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;      <span class="comment">// Move along the last field.</span></div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;      <span class="keywordflow">if</span> (TheIdx == 0)</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        TheIdx = Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#ade17b50e4f0b835cd9eb58dffe12a90d">getNumOperands</a>() - 2;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;      uint64_t Cur = cast&lt;ConstantInt&gt;(Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">getOperand</a>(TheIdx + 1))-&gt;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;                       getZExtValue();</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;      Offset -= Cur;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;      <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *P = dyn_cast_or_null&lt;MDNode&gt;(Node-&gt;<a class="code" href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">getOperand</a>(TheIdx));</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;      <span class="keywordflow">if</span> (!P)</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        <span class="keywordflow">return</span> TBAAStructTypeNode();</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;      <span class="keywordflow">return</span> TBAAStructTypeNode(P);</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    }</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;  };</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;}</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="keyword">namespace </span>{<span class="comment"></span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment">  /// TypeBasedAliasAnalysis - This is a simple alias analysis</span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="comment">  /// implementation that uses TypeBased to answer queries.</span></div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="comment"></span>  <span class="keyword">class </span>TypeBasedAliasAnalysis : <span class="keyword">public</span> <a class="code" href="classllvm_1_1ImmutablePass.html">ImmutablePass</a>,</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                                 <span class="keyword">public</span> <a class="code" href="classllvm_1_1AliasAnalysis.html">AliasAnalysis</a> {</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;  <span class="keyword">public</span>:</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">char</span> <a class="code" href="namespacellvm_1_1CallingConv.html#a4f861731fc6dbfdccc05af5968d98974">ID</a>; <span class="comment">// Class identification, replacement for typeinfo</span></div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    TypeBasedAliasAnalysis() : <a class="code" href="classllvm_1_1ImmutablePass.html">ImmutablePass</a>(ID) {</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;      <a class="code" href="namespacellvm.html#a7f9f839587d3ddc195c46b97c41bd973">initializeTypeBasedAliasAnalysisPass</a>(*<a class="code" href="classllvm_1_1PassRegistry.html#a05a729900b76c89e808c6c3094921b2f">PassRegistry::getPassRegistry</a>());</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    }</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    <span class="keyword">virtual</span> <span class="keywordtype">void</span> initializePass() {</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;      InitializeAliasAnalysis(<span class="keyword">this</span>);</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    }</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="comment">    /// getAdjustedAnalysisPointer - This method is used when a pass implements</span></div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="comment">    /// an analysis interface through multiple inheritance.  If needed, it</span></div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="comment">    /// should override this to adjust the this pointer as needed for the</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="comment">    /// specified pass info.</span></div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="comment"></span>    <span class="keyword">virtual</span> <span class="keywordtype">void</span> *getAdjustedAnalysisPointer(<span class="keyword">const</span> <span class="keywordtype">void</span> *PI) {</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;      <span class="keywordflow">if</span> (PI == &amp;<a class="code" href="classllvm_1_1AliasAnalysis.html#ae46bcf64f0fc3010424d4582dbb44391">AliasAnalysis::ID</a>)</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;        <span class="keywordflow">return</span> (<a class="code" href="classllvm_1_1AliasAnalysis.html">AliasAnalysis</a>*)<span class="keyword">this</span>;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">this</span>;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    }</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    <span class="keywordtype">bool</span> Aliases(<span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *<a class="code" href="namespacellvm_1_1ARM__PROC.html#aac31dd660a6f18140efdd62b351cb11bad9577456b5bb7a03b7f42a710e122ab5">A</a>, <span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *<a class="code" href="Target_2ARM_2README_8txt.html#a90cca76dd78688687e0d697679dbc799">B</a>) <span class="keyword">const</span>;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    <span class="keywordtype">bool</span> PathAliases(<span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *<a class="code" href="namespacellvm_1_1ARM__PROC.html#aac31dd660a6f18140efdd62b351cb11bad9577456b5bb7a03b7f42a710e122ab5">A</a>, <span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *<a class="code" href="Target_2ARM_2README_8txt.html#a90cca76dd78688687e0d697679dbc799">B</a>) <span class="keyword">const</span>;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;  <span class="keyword">private</span>:</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    <span class="keyword">virtual</span> <span class="keywordtype">void</span> getAnalysisUsage(<a class="code" href="classllvm_1_1AnalysisUsage.html">AnalysisUsage</a> &amp;AU) <span class="keyword">const</span>;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    <span class="keyword">virtual</span> AliasResult alias(<span class="keyword">const</span> Location &amp;LocA, <span class="keyword">const</span> Location &amp;LocB);</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> pointsToConstantMemory(<span class="keyword">const</span> Location &amp;Loc, <span class="keywordtype">bool</span> OrLocal);</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <span class="keyword">virtual</span> <a class="code" href="MemorySanitizer_8cpp.html#a4fb9a92499e70532fe8798b32bfd9e7b">ModRefBehavior</a> getModRefBehavior(<a class="code" href="classllvm_1_1ImmutableCallSite.html">ImmutableCallSite</a> CS);</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;    <span class="keyword">virtual</span> <a class="code" href="MemorySanitizer_8cpp.html#a4fb9a92499e70532fe8798b32bfd9e7b">ModRefBehavior</a> getModRefBehavior(<span class="keyword">const</span> <a class="code" href="classllvm_1_1Function.html">Function</a> *<a class="code" href="LLParser_8cpp.html#a33ece1ef8074506a15d7f86eb76dbae6">F</a>);</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    <span class="keyword">virtual</span> ModRefResult getModRefInfo(<a class="code" href="classllvm_1_1ImmutableCallSite.html">ImmutableCallSite</a> CS,</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;                                       <span class="keyword">const</span> Location &amp;Loc);</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    <span class="keyword">virtual</span> ModRefResult getModRefInfo(<a class="code" href="classllvm_1_1ImmutableCallSite.html">ImmutableCallSite</a> CS1,</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                                       <a class="code" href="classllvm_1_1ImmutableCallSite.html">ImmutableCallSite</a> CS2);</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;  };</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;}  <span class="comment">// End of anonymous namespace</span></div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="comment">// Register this pass...</span></div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="keywordtype">char</span> <a class="code" href="namespacellvm_1_1CallingConv.html#a4f861731fc6dbfdccc05af5968d98974">TypeBasedAliasAnalysis::ID</a> = 0;</div><div class="line"><a name="l00316"></a><span class="lineno"><a class="line" href="TypeBasedAliasAnalysis_8cpp.html#a982c9d171140ae8b360d60230aeb0bbc">  316</a></span>&#160;<a class="code" href="TypeBasedAliasAnalysis_8cpp.html#a982c9d171140ae8b360d60230aeb0bbc">INITIALIZE_AG_PASS</a>(TypeBasedAliasAnalysis, <a class="code" href="classllvm_1_1AliasAnalysis.html">AliasAnalysis</a>, <span class="stringliteral">&quot;tbaa&quot;</span>,</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;                   <span class="stringliteral">&quot;Type-Based Alias Analysis&quot;</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>)</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<a class="code" href="classllvm_1_1ImmutablePass.html">ImmutablePass</a> *<a class="code" href="namespacellvm.html">llvm</a>::<a class="code" href="namespacellvm.html#a022323238327ae5edae5d42398e0325f">createTypeBasedAliasAnalysisPass</a>() {</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">new</span> TypeBasedAliasAnalysis();</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;}</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="keywordtype">void</span></div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;TypeBasedAliasAnalysis::getAnalysisUsage(<a class="code" href="classllvm_1_1AnalysisUsage.html">AnalysisUsage</a> &amp;AU)<span class="keyword"> const </span>{</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;  AU.<a class="code" href="classllvm_1_1AnalysisUsage.html#af22b06a6a4f9df80454071685a0d6a02">setPreservesAll</a>();</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;  <a class="code" href="classllvm_1_1AliasAnalysis.html#aa2f12c9f80c62624255ac0f4893f496e">AliasAnalysis::getAnalysisUsage</a>(AU);</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;}</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="comment">/// Check the first operand of the tbaa tag node, if it is a MDNode, we treat</span></div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="comment">/// it as struct-path aware TBAA format, otherwise, we treat it as scalar TBAA</span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="comment">/// format.</span></div><div class="line"><a name="l00332"></a><span class="lineno"><a class="line" href="TypeBasedAliasAnalysis_8cpp.html#a5e19d69f8c65d343b518e66bef56db58">  332</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="TypeBasedAliasAnalysis_8cpp.html#a5e19d69f8c65d343b518e66bef56db58">isStructPathTBAA</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *MD) {</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;  <span class="comment">// Anonymous TBAA root starts with a MDNode and dragonegg uses it as</span></div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;  <span class="comment">// a TBAA tag.</span></div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;  <span class="keywordflow">return</span> isa&lt;MDNode&gt;(MD-&gt;<a class="code" href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">getOperand</a>(0)) &amp;&amp; MD-&gt;<a class="code" href="classllvm_1_1MDNode.html#ade17b50e4f0b835cd9eb58dffe12a90d">getNumOperands</a>() &gt;= 3;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;}</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="comment">/// Aliases - Test whether the type represented by A may alias the</span></div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="comment">/// type represented by B.</span></div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="comment"></span><span class="keywordtype">bool</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;TypeBasedAliasAnalysis::Aliases(<span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *<a class="code" href="namespacellvm_1_1ARM__PROC.html#aac31dd660a6f18140efdd62b351cb11bad9577456b5bb7a03b7f42a710e122ab5">A</a>,</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;                                <span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *<a class="code" href="Target_2ARM_2README_8txt.html#a90cca76dd78688687e0d697679dbc799">B</a>)<span class="keyword"> const </span>{</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="TypeBasedAliasAnalysis_8cpp.html#a5e19d69f8c65d343b518e66bef56db58">isStructPathTBAA</a>(A))</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    <span class="keywordflow">return</span> PathAliases(A, B);</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;  <span class="comment">// Keep track of the root node for A and B.</span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;  TBAANode RootA, RootB;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;  <span class="comment">// Climb the tree from A to see if we reach B.</span></div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;  <span class="keywordflow">for</span> (TBAANode <a class="code" href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a>(A); ; ) {</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classT.html">T</a>.getNode() == <a class="code" href="Target_2ARM_2README_8txt.html#a90cca76dd78688687e0d697679dbc799">B</a>)</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;      <span class="comment">// B is an ancestor of A.</span></div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    RootA = <a class="code" href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a>;</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <a class="code" href="classT.html">T</a> = <a class="code" href="classT.html">T</a>.getParent();</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="classT.html">T</a>.getNode())</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;      <span class="keywordflow">break</span>;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;  }</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;  <span class="comment">// Climb the tree from B to see if we reach A.</span></div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;  <span class="keywordflow">for</span> (TBAANode <a class="code" href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a>(B); ; ) {</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classT.html">T</a>.getNode() == <a class="code" href="namespacellvm_1_1ARM__PROC.html#aac31dd660a6f18140efdd62b351cb11bad9577456b5bb7a03b7f42a710e122ab5">A</a>)</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;      <span class="comment">// A is an ancestor of B.</span></div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    RootB = <a class="code" href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a>;</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    <a class="code" href="classT.html">T</a> = <a class="code" href="classT.html">T</a>.getParent();</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="classT.html">T</a>.getNode())</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;      <span class="keywordflow">break</span>;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;  }</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;  <span class="comment">// Neither node is an ancestor of the other.</span></div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;  </div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;  <span class="comment">// If they have different roots, they&#39;re part of different potentially</span></div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;  <span class="comment">// unrelated type systems, so we must be conservative.</span></div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;  <span class="keywordflow">if</span> (RootA.getNode() != RootB.getNode())</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;  <span class="comment">// If they have the same root, then we&#39;ve proved there&#39;s no alias.</span></div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;}</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;<span class="comment">/// Test whether the struct-path tag represented by A may alias the</span></div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;<span class="comment">/// struct-path tag represented by B.</span></div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;<span class="comment"></span><span class="keywordtype">bool</span></div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;TypeBasedAliasAnalysis::PathAliases(<span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *A,</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;                                    <span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *B)<span class="keyword"> const </span>{</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;  <span class="comment">// Keep track of the root node for A and B.</span></div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;  TBAAStructTypeNode RootA, RootB;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;  TBAAStructTagNode TagA(A), TagB(B);</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;  <span class="comment">// TODO: We need to check if AccessType of TagA encloses AccessType of</span></div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;  <span class="comment">// TagB to support aggregate AccessType. If yes, return true.</span></div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;  <span class="comment">// Start from the base type of A, follow the edge with the correct offset in</span></div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;  <span class="comment">// the type DAG and adjust the offset until we reach the base type of B or</span></div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;  <span class="comment">// until we reach the Root node.</span></div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;  <span class="comment">// Compare the adjusted offset once we have the same base.</span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;  <span class="comment">// Climb the type DAG from base type of A to see if we reach base type of B.</span></div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *BaseA = TagA.getBaseType();</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *BaseB = TagB.getBaseType();</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;  uint64_t OffsetA = TagA.getOffset(), OffsetB = TagB.getOffset();</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;  <span class="keywordflow">for</span> (TBAAStructTypeNode <a class="code" href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a>(BaseA); ; ) {</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classT.html">T</a>.getNode() == BaseB)</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;      <span class="comment">// Base type of A encloses base type of B, check if the offsets match.</span></div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;      <span class="keywordflow">return</span> OffsetA == OffsetB;</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    RootA = <a class="code" href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a>;</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    <span class="comment">// Follow the edge with the correct offset, OffsetA will be adjusted to</span></div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    <span class="comment">// be relative to the field type.</span></div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    <a class="code" href="classT.html">T</a> = <a class="code" href="classT.html">T</a>.getParent(OffsetA);</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="classT.html">T</a>.getNode())</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;      <span class="keywordflow">break</span>;</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;  }</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;  <span class="comment">// Reset OffsetA and climb the type DAG from base type of B to see if we reach</span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;  <span class="comment">// base type of A.</span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;  OffsetA = TagA.getOffset();</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;  <span class="keywordflow">for</span> (TBAAStructTypeNode <a class="code" href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a>(BaseB); ; ) {</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classT.html">T</a>.getNode() == BaseA)</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;      <span class="comment">// Base type of B encloses base type of A, check if the offsets match.</span></div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;      <span class="keywordflow">return</span> OffsetA == OffsetB;</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    RootB = <a class="code" href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a>;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <span class="comment">// Follow the edge with the correct offset, OffsetB will be adjusted to</span></div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    <span class="comment">// be relative to the field type.</span></div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    <a class="code" href="classT.html">T</a> = <a class="code" href="classT.html">T</a>.getParent(OffsetB);</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="classT.html">T</a>.getNode())</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;      <span class="keywordflow">break</span>;</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;  }</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;  <span class="comment">// Neither node is an ancestor of the other.</span></div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;  <span class="comment">// If they have different roots, they&#39;re part of different potentially</span></div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;  <span class="comment">// unrelated type systems, so we must be conservative.</span></div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;  <span class="keywordflow">if</span> (RootA.getNode() != RootB.getNode())</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;  <span class="comment">// If they have the same root, then we&#39;ve proved there&#39;s no alias.</span></div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;}</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;<a class="code" href="classllvm_1_1AliasAnalysis.html#aa96743b70089c7a0ef5d935f34173826">AliasAnalysis::AliasResult</a></div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;TypeBasedAliasAnalysis::alias(<span class="keyword">const</span> Location &amp;LocA,</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;                              <span class="keyword">const</span> Location &amp;LocB) {</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="TypeBasedAliasAnalysis_8cpp.html#ac9cc1aa1eaf0273f5628439f8f9026df">EnableTBAA</a>)</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1AliasAnalysis.html#a59949d72986d3e9fdb7e7c9272c02f0f">AliasAnalysis::alias</a>(LocA, LocB);</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;  <span class="comment">// Get the attached MDNodes. If either value lacks a tbaa MDNode, we must</span></div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;  <span class="comment">// be conservative.</span></div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *AM = LocA.TBAATag;</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;  <span class="keywordflow">if</span> (!AM) <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1AliasAnalysis.html#a59949d72986d3e9fdb7e7c9272c02f0f">AliasAnalysis::alias</a>(LocA, LocB);</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *BM = LocB.TBAATag;</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;  <span class="keywordflow">if</span> (!BM) <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1AliasAnalysis.html#a59949d72986d3e9fdb7e7c9272c02f0f">AliasAnalysis::alias</a>(LocA, LocB);</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;  <span class="comment">// If they may alias, chain to the next AliasAnalysis.</span></div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;  <span class="keywordflow">if</span> (Aliases(AM, BM))</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1AliasAnalysis.html#a59949d72986d3e9fdb7e7c9272c02f0f">AliasAnalysis::alias</a>(LocA, LocB);</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;  <span class="comment">// Otherwise return a definitive result.</span></div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;  <span class="keywordflow">return</span> NoAlias;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;}</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;<span class="keywordtype">bool</span> TypeBasedAliasAnalysis::pointsToConstantMemory(<span class="keyword">const</span> Location &amp;Loc,</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;                                                    <span class="keywordtype">bool</span> OrLocal) {</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="TypeBasedAliasAnalysis_8cpp.html#ac9cc1aa1eaf0273f5628439f8f9026df">EnableTBAA</a>)</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1AliasAnalysis.html#abf9502ffcd1aeddfe91345685e3c78a9">AliasAnalysis::pointsToConstantMemory</a>(Loc, OrLocal);</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *<a class="code" href="Target_2X86_2README_8txt.html#ac88fe1d3a61b056a4f64fbbb156a62ff">M</a> = Loc.TBAATag;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;  <span class="keywordflow">if</span> (!M) <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1AliasAnalysis.html#abf9502ffcd1aeddfe91345685e3c78a9">AliasAnalysis::pointsToConstantMemory</a>(Loc, OrLocal);</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;  <span class="comment">// If this is an &quot;immutable&quot; type, we can assume the pointer is pointing</span></div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;  <span class="comment">// to constant memory.</span></div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;  <span class="keywordflow">if</span> ((!<a class="code" href="TypeBasedAliasAnalysis_8cpp.html#a5e19d69f8c65d343b518e66bef56db58">isStructPathTBAA</a>(M) &amp;&amp; TBAANode(M).TypeIsImmutable()) ||</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;      (<a class="code" href="TypeBasedAliasAnalysis_8cpp.html#a5e19d69f8c65d343b518e66bef56db58">isStructPathTBAA</a>(M) &amp;&amp; TBAAStructTagNode(M).TypeIsImmutable()))</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1AliasAnalysis.html#abf9502ffcd1aeddfe91345685e3c78a9">AliasAnalysis::pointsToConstantMemory</a>(Loc, OrLocal);</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;}</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<a class="code" href="classllvm_1_1AliasAnalysis.html#ae0276e687a2b2ddd7d0d549d98140f91">AliasAnalysis::ModRefBehavior</a></div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;TypeBasedAliasAnalysis::getModRefBehavior(<a class="code" href="classllvm_1_1ImmutableCallSite.html">ImmutableCallSite</a> CS) {</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="TypeBasedAliasAnalysis_8cpp.html#ac9cc1aa1eaf0273f5628439f8f9026df">EnableTBAA</a>)</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1AliasAnalysis.html#a64eefe72b0df7de20f76983b398f72df">AliasAnalysis::getModRefBehavior</a>(CS);</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;  <a class="code" href="MemorySanitizer_8cpp.html#a4fb9a92499e70532fe8798b32bfd9e7b">ModRefBehavior</a> Min = UnknownModRefBehavior;</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;  <span class="comment">// If this is an &quot;immutable&quot; type, we can assume the call doesn&#39;t write</span></div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;  <span class="comment">// to memory.</span></div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *<a class="code" href="Target_2X86_2README_8txt.html#ac88fe1d3a61b056a4f64fbbb156a62ff">M</a> = CS.<a class="code" href="classllvm_1_1CallSiteBase.html#ae4c67f835911559821939fb23a2e7aff">getInstruction</a>()-&gt;<a class="code" href="classllvm_1_1Instruction.html#aafa29112cbe02e4adc9b36752c771991">getMetadata</a>(<a class="code" href="classllvm_1_1LLVMContext.html#a0869c4dfee48696ce863fcd367eba52da66682b7e33233c8e51196bbf274726a2">LLVMContext::MD_tbaa</a>))</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    <span class="keywordflow">if</span> ((!<a class="code" href="TypeBasedAliasAnalysis_8cpp.html#a5e19d69f8c65d343b518e66bef56db58">isStructPathTBAA</a>(<a class="code" href="Target_2X86_2README_8txt.html#ac88fe1d3a61b056a4f64fbbb156a62ff">M</a>) &amp;&amp; TBAANode(<a class="code" href="Target_2X86_2README_8txt.html#ac88fe1d3a61b056a4f64fbbb156a62ff">M</a>).TypeIsImmutable()) ||</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;        (<a class="code" href="TypeBasedAliasAnalysis_8cpp.html#a5e19d69f8c65d343b518e66bef56db58">isStructPathTBAA</a>(<a class="code" href="Target_2X86_2README_8txt.html#ac88fe1d3a61b056a4f64fbbb156a62ff">M</a>) &amp;&amp; TBAAStructTagNode(<a class="code" href="Target_2X86_2README_8txt.html#ac88fe1d3a61b056a4f64fbbb156a62ff">M</a>).TypeIsImmutable()))</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;      Min = OnlyReadsMemory;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="MemorySanitizer_8cpp.html#a4fb9a92499e70532fe8798b32bfd9e7b">ModRefBehavior</a>(<a class="code" href="classllvm_1_1AliasAnalysis.html#a64eefe72b0df7de20f76983b398f72df">AliasAnalysis::getModRefBehavior</a>(CS) &amp; Min);</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;}</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;<a class="code" href="classllvm_1_1AliasAnalysis.html#ae0276e687a2b2ddd7d0d549d98140f91">AliasAnalysis::ModRefBehavior</a></div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;TypeBasedAliasAnalysis::getModRefBehavior(<span class="keyword">const</span> <a class="code" href="classllvm_1_1Function.html">Function</a> *<a class="code" href="LLParser_8cpp.html#a33ece1ef8074506a15d7f86eb76dbae6">F</a>) {</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;  <span class="comment">// Functions don&#39;t have metadata. Just chain to the next implementation.</span></div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1AliasAnalysis.html#a64eefe72b0df7de20f76983b398f72df">AliasAnalysis::getModRefBehavior</a>(F);</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;}</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;<a class="code" href="classllvm_1_1AliasAnalysis.html#a83d29c51155787c607268c2659559460">AliasAnalysis::ModRefResult</a></div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;TypeBasedAliasAnalysis::getModRefInfo(<a class="code" href="classllvm_1_1ImmutableCallSite.html">ImmutableCallSite</a> CS,</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;                                      <span class="keyword">const</span> Location &amp;Loc) {</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="TypeBasedAliasAnalysis_8cpp.html#ac9cc1aa1eaf0273f5628439f8f9026df">EnableTBAA</a>)</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1AliasAnalysis.html#a3f09a65a9c9d7bfff6c6271976d1baba">AliasAnalysis::getModRefInfo</a>(CS, Loc);</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *L = Loc.TBAATag)</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *<a class="code" href="Target_2X86_2README_8txt.html#ac88fe1d3a61b056a4f64fbbb156a62ff">M</a> =</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;          CS.<a class="code" href="classllvm_1_1CallSiteBase.html#ae4c67f835911559821939fb23a2e7aff">getInstruction</a>()-&gt;<a class="code" href="classllvm_1_1Instruction.html#aafa29112cbe02e4adc9b36752c771991">getMetadata</a>(<a class="code" href="classllvm_1_1LLVMContext.html#a0869c4dfee48696ce863fcd367eba52da66682b7e33233c8e51196bbf274726a2">LLVMContext::MD_tbaa</a>))</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;      <span class="keywordflow">if</span> (!Aliases(L, <a class="code" href="Target_2X86_2README_8txt.html#ac88fe1d3a61b056a4f64fbbb156a62ff">M</a>))</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;        <span class="keywordflow">return</span> NoModRef;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1AliasAnalysis.html#a3f09a65a9c9d7bfff6c6271976d1baba">AliasAnalysis::getModRefInfo</a>(CS, Loc);</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;}</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;<a class="code" href="classllvm_1_1AliasAnalysis.html#a83d29c51155787c607268c2659559460">AliasAnalysis::ModRefResult</a></div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;TypeBasedAliasAnalysis::getModRefInfo(<a class="code" href="classllvm_1_1ImmutableCallSite.html">ImmutableCallSite</a> CS1,</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;                                      <a class="code" href="classllvm_1_1ImmutableCallSite.html">ImmutableCallSite</a> CS2) {</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="TypeBasedAliasAnalysis_8cpp.html#ac9cc1aa1eaf0273f5628439f8f9026df">EnableTBAA</a>)</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1AliasAnalysis.html#a3f09a65a9c9d7bfff6c6271976d1baba">AliasAnalysis::getModRefInfo</a>(CS1, CS2);</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *M1 =</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;        CS1.<a class="code" href="classllvm_1_1CallSiteBase.html#ae4c67f835911559821939fb23a2e7aff">getInstruction</a>()-&gt;<a class="code" href="classllvm_1_1Instruction.html#aafa29112cbe02e4adc9b36752c771991">getMetadata</a>(<a class="code" href="classllvm_1_1LLVMContext.html#a0869c4dfee48696ce863fcd367eba52da66682b7e33233c8e51196bbf274726a2">LLVMContext::MD_tbaa</a>))</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *M2 =</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;          CS2.<a class="code" href="classllvm_1_1CallSiteBase.html#ae4c67f835911559821939fb23a2e7aff">getInstruction</a>()-&gt;<a class="code" href="classllvm_1_1Instruction.html#aafa29112cbe02e4adc9b36752c771991">getMetadata</a>(<a class="code" href="classllvm_1_1LLVMContext.html#a0869c4dfee48696ce863fcd367eba52da66682b7e33233c8e51196bbf274726a2">LLVMContext::MD_tbaa</a>))</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;      <span class="keywordflow">if</span> (!Aliases(M1, M2))</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;        <span class="keywordflow">return</span> NoModRef;</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1AliasAnalysis.html#a3f09a65a9c9d7bfff6c6271976d1baba">AliasAnalysis::getModRefInfo</a>(CS1, CS2);</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;}</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;</div><div class="line"><a name="l00537"></a><span class="lineno"><a class="line" href="classllvm_1_1MDNode.html#a4eb5d36353fa3776df4579b934a21511">  537</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1MDNode.html#a4eb5d36353fa3776df4579b934a21511">MDNode::isTBAAVtableAccess</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="TypeBasedAliasAnalysis_8cpp.html#a5e19d69f8c65d343b518e66bef56db58">isStructPathTBAA</a>(<span class="keyword">this</span>)) {</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;    <span class="keywordflow">if</span> (getNumOperands() &lt; 1) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1MDString.html">MDString</a> *Tag1 = dyn_cast&lt;MDString&gt;(getOperand(0))) {</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;      <span class="keywordflow">if</span> (Tag1-&gt;getString() == <span class="stringliteral">&quot;vtable pointer&quot;</span>) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;    }</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;  }</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;  <span class="comment">// For struct-path aware TBAA, we use the access type of the tag.</span></div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;  <span class="keywordflow">if</span> (getNumOperands() &lt; 2) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;  <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *Tag = cast_or_null&lt;MDNode&gt;(getOperand(1));</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;  <span class="keywordflow">if</span> (!Tag) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1MDString.html">MDString</a> *Tag1 = dyn_cast&lt;MDString&gt;(Tag-&gt;<a class="code" href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">getOperand</a>(0))) {</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;    <span class="keywordflow">if</span> (Tag1-&gt;getString() == <span class="stringliteral">&quot;vtable pointer&quot;</span>) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;  }</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">false</span>;  </div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;}</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;</div><div class="line"><a name="l00556"></a><span class="lineno"><a class="line" href="classllvm_1_1MDNode.html#a3c210e8905029a012df3384a7eeb63ad">  556</a></span>&#160;<a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *<a class="code" href="classllvm_1_1MDNode.html#a3c210e8905029a012df3384a7eeb63ad">MDNode::getMostGenericTBAA</a>(<a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *A, <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *B) {</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;  <span class="keywordflow">if</span> (!A || !B)</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;    <span class="keywordflow">return</span> NULL;</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;  <span class="keywordflow">if</span> (A == B)</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacellvm_1_1ARM__PROC.html#aac31dd660a6f18140efdd62b351cb11bad9577456b5bb7a03b7f42a710e122ab5">A</a>;</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;  <span class="comment">// For struct-path aware TBAA, we use the access type of the tag.</span></div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;  <span class="keywordtype">bool</span> StructPath = <a class="code" href="TypeBasedAliasAnalysis_8cpp.html#a5e19d69f8c65d343b518e66bef56db58">isStructPathTBAA</a>(A);</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;  <span class="keywordflow">if</span> (StructPath) {</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;    A = cast_or_null&lt;MDNode&gt;(A-&gt;<a class="code" href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">getOperand</a>(1));</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;    <span class="keywordflow">if</span> (!A) <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;    B = cast_or_null&lt;MDNode&gt;(B-&gt;<a class="code" href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">getOperand</a>(1));</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;    <span class="keywordflow">if</span> (!B) <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;  }</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;MDNode *, 4&gt;</a> PathA;</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;  <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *<a class="code" href="classT.html">T</a> = <a class="code" href="namespacellvm_1_1ARM__PROC.html#aac31dd660a6f18140efdd62b351cb11bad9577456b5bb7a03b7f42a710e122ab5">A</a>;</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;  <span class="keywordflow">while</span> (T) {</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;    PathA.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(T);</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;    T = T-&gt;<a class="code" href="classllvm_1_1MDNode.html#ade17b50e4f0b835cd9eb58dffe12a90d">getNumOperands</a>() &gt;= 2 ? cast_or_null&lt;MDNode&gt;(T-&gt;<a class="code" href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">getOperand</a>(1)) : 0;</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;  }</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;MDNode *, 4&gt;</a> PathB;</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;  T = <a class="code" href="Target_2ARM_2README_8txt.html#a90cca76dd78688687e0d697679dbc799">B</a>;</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;  <span class="keywordflow">while</span> (T) {</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;    PathB.push_back(T);</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;    T = T-&gt;<a class="code" href="classllvm_1_1MDNode.html#ade17b50e4f0b835cd9eb58dffe12a90d">getNumOperands</a>() &gt;= 2 ? cast_or_null&lt;MDNode&gt;(T-&gt;<a class="code" href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">getOperand</a>(1)) : 0;</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;  }</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;  <span class="keywordtype">int</span> IA = PathA.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a22a311dfe4c28a897de8a9365a4f0a84">size</a>() - 1;</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;  <span class="keywordtype">int</span> IB = PathB.size() - 1;</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;  <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *<a class="code" href="namespacellvm_1_1AArch64ISD.html#a246d89cb58f606179b1435937830bbdca84e96c468affe3b1fd3076b4fc5d063e">Ret</a> = 0;</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;  <span class="keywordflow">while</span> (IA &gt;= 0 &amp;&amp; IB &gt;=0) {</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;    <span class="keywordflow">if</span> (PathA[IA] == PathB[IB])</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;      Ret = PathA[IA];</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;      <span class="keywordflow">break</span>;</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    --IA;</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    --IB;</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;  }</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;  <span class="keywordflow">if</span> (!StructPath)</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacellvm_1_1AArch64ISD.html#a246d89cb58f606179b1435937830bbdca84e96c468affe3b1fd3076b4fc5d063e">Ret</a>;</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;  <span class="keywordflow">if</span> (!Ret)</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;  <span class="comment">// We need to convert from a type node to a tag node.</span></div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *Int64 = <a class="code" href="classllvm_1_1IntegerType.html#a14f7b4f1aed38192fb6b7772eb506bdb">IntegerType::get</a>(A-&gt;<a class="code" href="classllvm_1_1Value.html#af85a4828b6b5a8de7fc0a55cc0e5b52f">getContext</a>(), 64);</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *Ops[3] = { <a class="code" href="namespacellvm_1_1AArch64ISD.html#a246d89cb58f606179b1435937830bbdca84e96c468affe3b1fd3076b4fc5d063e">Ret</a>, <a class="code" href="namespacellvm_1_1AArch64ISD.html#a246d89cb58f606179b1435937830bbdca84e96c468affe3b1fd3076b4fc5d063e">Ret</a>, <a class="code" href="classllvm_1_1ConstantInt.html#a9105541412dab869e18b3cceebfff07d">ConstantInt::get</a>(Int64, 0) };</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1MDNode.html#ad66ceb4f77078b084e527a19baab19d6">MDNode::get</a>(A-&gt;<a class="code" href="classllvm_1_1Value.html#af85a4828b6b5a8de7fc0a55cc0e5b52f">getContext</a>(), Ops);</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;}</div><div class="ttc" id="classllvm_1_1SmallVectorTemplateCommon_html_a22a311dfe4c28a897de8a9365a4f0a84"><div class="ttname"><a href="classllvm_1_1SmallVectorTemplateCommon.html#a22a311dfe4c28a897de8a9365a4f0a84">llvm::SmallVectorTemplateCommon&lt; T &gt;::size</a></div><div class="ttdeci">size_type size() const</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00127">SmallVector.h:127</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorTemplateBase_html_ae1a10b90f22c0478960fb5798ff73916"><div class="ttname"><a href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">llvm::SmallVectorTemplateBase&lt; T, isPodLike&lt; T &gt;::value &gt;::push_back</a></div><div class="ttdeci">void push_back(const T &amp;Elt)</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00236">SmallVector.h:236</a></div></div>
<div class="ttc" id="namespacellvm_1_1ARM__PROC_html_aac31dd660a6f18140efdd62b351cb11bad9577456b5bb7a03b7f42a710e122ab5"><div class="ttname"><a href="namespacellvm_1_1ARM__PROC.html#aac31dd660a6f18140efdd62b351cb11bad9577456b5bb7a03b7f42a710e122ab5">llvm::ARM_PROC::A</a></div><div class="ttdef"><b>Definition:</b> <a href="ARMBaseInfo_8h_source.html#l00098">ARMBaseInfo.h:98</a></div></div>
<div class="ttc" id="classllvm_1_1AliasAnalysis_html_abf9502ffcd1aeddfe91345685e3c78a9"><div class="ttname"><a href="classllvm_1_1AliasAnalysis.html#abf9502ffcd1aeddfe91345685e3c78a9">llvm::AliasAnalysis::pointsToConstantMemory</a></div><div class="ttdeci">virtual bool pointsToConstantMemory(const Location &amp;Loc, bool OrLocal=false)</div><div class="ttdef"><b>Definition:</b> <a href="AliasAnalysis_8cpp_source.html#l00057">AliasAnalysis.cpp:57</a></div></div>
<div class="ttc" id="classllvm_1_1PassRegistry_html_a05a729900b76c89e808c6c3094921b2f"><div class="ttname"><a href="classllvm_1_1PassRegistry.html#a05a729900b76c89e808c6c3094921b2f">llvm::PassRegistry::getPassRegistry</a></div><div class="ttdeci">static PassRegistry * getPassRegistry()</div><div class="ttdef"><b>Definition:</b> <a href="PassRegistry_8cpp_source.html#l00035">PassRegistry.cpp:35</a></div></div>
<div class="ttc" id="namespacellvm_html"><div class="ttname"><a href="namespacellvm.html">llvm</a></div><div class="ttdoc">List of target independent CodeGen pass IDs. </div><div class="ttdef"><b>Definition:</b> <a href="APFloat_8h_source.html#l00022">APFloat.h:22</a></div></div>
<div class="ttc" id="classllvm_1_1AliasAnalysis_html_a3f09a65a9c9d7bfff6c6271976d1baba"><div class="ttname"><a href="classllvm_1_1AliasAnalysis.html#a3f09a65a9c9d7bfff6c6271976d1baba">llvm::AliasAnalysis::getModRefInfo</a></div><div class="ttdeci">ModRefResult getModRefInfo(const Instruction *I, const Location &amp;Loc)</div><div class="ttdef"><b>Definition:</b> <a href="AliasAnalysis_8h_source.html#l00353">AliasAnalysis.h:353</a></div></div>
<div class="ttc" id="namespacellvm_html_a3f2f98c2a67c9e79f58aad9150a62e42"><div class="ttname"><a href="namespacellvm.html#a3f2f98c2a67c9e79f58aad9150a62e42">llvm::dyn_cast</a></div><div class="ttdeci">enable_if_c&lt;!is_simple_type&lt; Y &gt;::value, typename cast_retty&lt; X, const Y &gt;::ret_type &gt;::type dyn_cast(const Y &amp;Val)</div><div class="ttdef"><b>Definition:</b> <a href="Casting_8h_source.html#l00266">Casting.h:266</a></div></div>
<div class="ttc" id="classllvm_1_1MDNode_html_ade17b50e4f0b835cd9eb58dffe12a90d"><div class="ttname"><a href="classllvm_1_1MDNode.html#ade17b50e4f0b835cd9eb58dffe12a90d">llvm::MDNode::getNumOperands</a></div><div class="ttdeci">unsigned getNumOperands() const </div><div class="ttdoc">getNumOperands - Return number of MDNode operands. </div><div class="ttdef"><b>Definition:</b> <a href="Metadata_8h_source.html#l00146">Metadata.h:146</a></div></div>
<div class="ttc" id="classllvm_1_1AliasAnalysis_html_ae0276e687a2b2ddd7d0d549d98140f91"><div class="ttname"><a href="classllvm_1_1AliasAnalysis.html#ae0276e687a2b2ddd7d0d549d98140f91">llvm::AliasAnalysis::ModRefBehavior</a></div><div class="ttdeci">ModRefBehavior</div><div class="ttdef"><b>Definition:</b> <a href="AliasAnalysis_8h_source.html#l00241">AliasAnalysis.h:241</a></div></div>
<div class="ttc" id="README-SSE_8txt_html_a63d206a063eefcdf8c318ded97b65020"><div class="ttname"><a href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a></div><div class="ttdeci">This currently compiles esp xmm0 movsd esp eax eax esp ret We should use not the dag combiner This is because dagcombine2 needs to be able to see through the X86ISD::Wrapper which DAGCombine can t really do The code for turning x load into a single vector load is target independent and should be moved to the dag combiner The code for turning x load into a vector load can only handle a direct load from a global or a direct load from the stack It should be generalized to handle any load from P</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00427">README-SSE.txt:427</a></div></div>
<div class="ttc" id="Metadata_8h_html"><div class="ttname"><a href="Metadata_8h.html">Metadata.h</a></div></div>
<div class="ttc" id="classllvm_1_1MDNode_html"><div class="ttname"><a href="classllvm_1_1MDNode.html">llvm::MDNode</a></div><div class="ttdoc">MDNode - a tuple of other values. </div><div class="ttdef"><b>Definition:</b> <a href="Metadata_8h_source.html#l00073">Metadata.h:73</a></div></div>
<div class="ttc" id="LLParser_8cpp_html_a33ece1ef8074506a15d7f86eb76dbae6"><div class="ttname"><a href="LLParser_8cpp.html#a33ece1ef8074506a15d7f86eb76dbae6">F</a></div><div class="ttdeci">F(f)</div></div>
<div class="ttc" id="classllvm_1_1Function_html"><div class="ttname"><a href="classllvm_1_1Function.html">llvm::Function</a></div><div class="ttdef"><b>Definition:</b> <a href="Function_8h_source.html#l00070">Function.h:70</a></div></div>
<div class="ttc" id="classllvm_1_1MDNode_html_ad66ceb4f77078b084e527a19baab19d6"><div class="ttname"><a href="classllvm_1_1MDNode.html#ad66ceb4f77078b084e527a19baab19d6">llvm::MDNode::get</a></div><div class="ttdeci">static MDNode * get(LLVMContext &amp;Context, ArrayRef&lt; Value * &gt; Vals)</div><div class="ttdef"><b>Definition:</b> <a href="Metadata_8cpp_source.html#l00268">Metadata.cpp:268</a></div></div>
<div class="ttc" id="classllvm_1_1MDNode_html_adb91929f939ff02dbee552d32afaf4e6"><div class="ttname"><a href="classllvm_1_1MDNode.html#adb91929f939ff02dbee552d32afaf4e6">llvm::MDNode::getOperand</a></div><div class="ttdeci">Value * getOperand(unsigned i) const LLVM_READONLY</div><div class="ttdoc">getOperand - Return specified operand. </div><div class="ttdef"><b>Definition:</b> <a href="Metadata_8cpp_source.html#l00307">Metadata.cpp:307</a></div></div>
<div class="ttc" id="namespacellvm_html_a7f9f839587d3ddc195c46b97c41bd973"><div class="ttname"><a href="namespacellvm.html#a7f9f839587d3ddc195c46b97c41bd973">llvm::initializeTypeBasedAliasAnalysisPass</a></div><div class="ttdeci">void initializeTypeBasedAliasAnalysisPass(PassRegistry &amp;)</div></div>
<div class="ttc" id="classllvm_1_1ConstantInt_html_af8dde13a97efce293a7b04daf1e208fb"><div class="ttname"><a href="classllvm_1_1ConstantInt.html#af8dde13a97efce293a7b04daf1e208fb">llvm::ConstantInt::getValue</a></div><div class="ttdeci">const APInt &amp; getValue() const </div><div class="ttdoc">Return the constant&amp;#39;s value. </div><div class="ttdef"><b>Definition:</b> <a href="Constants_8h_source.html#l00105">Constants.h:105</a></div></div>
<div class="ttc" id="classllvm_1_1AliasAnalysis_html_aa96743b70089c7a0ef5d935f34173826"><div class="ttname"><a href="classllvm_1_1AliasAnalysis.html#aa96743b70089c7a0ef5d935f34173826">llvm::AliasAnalysis::AliasResult</a></div><div class="ttdeci">AliasResult</div><div class="ttdef"><b>Definition:</b> <a href="AliasAnalysis_8h_source.html#l00161">AliasAnalysis.h:161</a></div></div>
<div class="ttc" id="classllvm_1_1AliasAnalysis_html"><div class="ttname"><a href="classllvm_1_1AliasAnalysis.html">llvm::AliasAnalysis</a></div><div class="ttdef"><b>Definition:</b> <a href="AliasAnalysis_8h_source.html#l00056">AliasAnalysis.h:56</a></div></div>
<div class="ttc" id="namespacellvm_1_1CallingConv_html_a4f861731fc6dbfdccc05af5968d98974"><div class="ttname"><a href="namespacellvm_1_1CallingConv.html#a4f861731fc6dbfdccc05af5968d98974">llvm::CallingConv::ID</a></div><div class="ttdeci">ID</div><div class="ttdoc">LLVM Calling Convention Representation. </div><div class="ttdef"><b>Definition:</b> <a href="CallingConv_8h_source.html#l00026">CallingConv.h:26</a></div></div>
<div class="ttc" id="classllvm_1_1MDNode_html_a4eb5d36353fa3776df4579b934a21511"><div class="ttname"><a href="classllvm_1_1MDNode.html#a4eb5d36353fa3776df4579b934a21511">llvm::MDNode::isTBAAVtableAccess</a></div><div class="ttdeci">bool isTBAAVtableAccess() const </div><div class="ttdoc">Check whether MDNode is a vtable access. </div><div class="ttdef"><b>Definition:</b> <a href="TypeBasedAliasAnalysis_8cpp_source.html#l00537">TypeBasedAliasAnalysis.cpp:537</a></div></div>
<div class="ttc" id="Mips16ISelLowering_8cpp_html_a0acb682b8260ab1c60b918599864e2e5"><div class="ttname"><a href="Mips16ISelLowering_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a></div><div class="ttdeci">#define T</div><div class="ttdef"><b>Definition:</b> <a href="Mips16ISelLowering_8cpp_source.html#l00349">Mips16ISelLowering.cpp:349</a></div></div>
<div class="ttc" id="Analysis_2Passes_8h_html"><div class="ttname"><a href="Analysis_2Passes_8h.html">Passes.h</a></div></div>
<div class="ttc" id="CommandLine_8h_html"><div class="ttname"><a href="CommandLine_8h.html">CommandLine.h</a></div></div>
<div class="ttc" id="namespacellvm_1_1cl_html_a10a041239ae1870cfcc064bfaa79fb65"><div class="ttname"><a href="namespacellvm_1_1cl.html#a10a041239ae1870cfcc064bfaa79fb65">llvm::cl::init</a></div><div class="ttdeci">initializer&lt; Ty &gt; init(const Ty &amp;Val)</div><div class="ttdef"><b>Definition:</b> <a href="CommandLine_8h_source.html#l00314">CommandLine.h:314</a></div></div>
<div class="ttc" id="namespacellvm_1_1AArch64ISD_html_a246d89cb58f606179b1435937830bbdca84e96c468affe3b1fd3076b4fc5d063e"><div class="ttname"><a href="namespacellvm_1_1AArch64ISD.html#a246d89cb58f606179b1435937830bbdca84e96c468affe3b1fd3076b4fc5d063e">llvm::AArch64ISD::Ret</a></div><div class="ttdef"><b>Definition:</b> <a href="AArch64ISelLowering_8h_source.html#l00060">AArch64ISelLowering.h:60</a></div></div>
<div class="ttc" id="namespacellvm_html_a022323238327ae5edae5d42398e0325f"><div class="ttname"><a href="namespacellvm.html#a022323238327ae5edae5d42398e0325f">llvm::createTypeBasedAliasAnalysisPass</a></div><div class="ttdeci">ImmutablePass * createTypeBasedAliasAnalysisPass()</div></div>
<div class="ttc" id="classllvm_1_1Type_html"><div class="ttname"><a href="classllvm_1_1Type.html">llvm::Type</a></div><div class="ttdef"><b>Definition:</b> <a href="Type_8h_source.html#l00044">Type.h:44</a></div></div>
<div class="ttc" id="classllvm_1_1CallSiteBase_html_ae4c67f835911559821939fb23a2e7aff"><div class="ttname"><a href="classllvm_1_1CallSiteBase.html#ae4c67f835911559821939fb23a2e7aff">llvm::CallSiteBase::getInstruction</a></div><div class="ttdeci">InstrTy * getInstruction() const </div><div class="ttdef"><b>Definition:</b> <a href="CallSite_8h_source.html#l00079">CallSite.h:79</a></div></div>
<div class="ttc" id="classllvm_1_1AliasAnalysis_html_a59949d72986d3e9fdb7e7c9272c02f0f"><div class="ttname"><a href="classllvm_1_1AliasAnalysis.html#a59949d72986d3e9fdb7e7c9272c02f0f">llvm::AliasAnalysis::alias</a></div><div class="ttdeci">virtual AliasResult alias(const Location &amp;LocA, const Location &amp;LocB)</div><div class="ttdef"><b>Definition:</b> <a href="AliasAnalysis_8cpp_source.html#l00052">AliasAnalysis.cpp:52</a></div></div>
<div class="ttc" id="Constants_8h_html"><div class="ttname"><a href="Constants_8h.html">Constants.h</a></div></div>
<div class="ttc" id="MemorySanitizer_8cpp_html_a4fb9a92499e70532fe8798b32bfd9e7b"><div class="ttname"><a href="MemorySanitizer_8cpp.html#a4fb9a92499e70532fe8798b32bfd9e7b">ModRefBehavior</a></div><div class="ttdeci">#define ModRefBehavior</div></div>
<div class="ttc" id="classllvm_1_1AnalysisUsage_html"><div class="ttname"><a href="classllvm_1_1AnalysisUsage.html">llvm::AnalysisUsage</a></div><div class="ttdef"><b>Definition:</b> <a href="PassAnalysisSupport_8h_source.html#l00037">PassAnalysisSupport.h:37</a></div></div>
<div class="ttc" id="classllvm_1_1LLVMContext_html_a0869c4dfee48696ce863fcd367eba52da66682b7e33233c8e51196bbf274726a2"><div class="ttname"><a href="classllvm_1_1LLVMContext.html#a0869c4dfee48696ce863fcd367eba52da66682b7e33233c8e51196bbf274726a2">llvm::LLVMContext::MD_tbaa</a></div><div class="ttdef"><b>Definition:</b> <a href="LLVMContext_8h_source.html#l00047">LLVMContext.h:47</a></div></div>
<div class="ttc" id="LoopStrengthReduce_8cpp_html_a4f07d245cf5f31e5b86ee80c06ab949a"><div class="ttname"><a href="LoopStrengthReduce_8cpp.html#a4f07d245cf5f31e5b86ee80c06ab949a">getAccessType</a></div><div class="ttdeci">static Type * getAccessType(const Instruction *Inst)</div><div class="ttdoc">getAccessType - Return the type of the memory being accessed. </div><div class="ttdef"><b>Definition:</b> <a href="LoopStrengthReduce_8cpp_source.html#l00636">LoopStrengthReduce.cpp:636</a></div></div>
<div class="ttc" id="classllvm_1_1MDNode_html_a3c210e8905029a012df3384a7eeb63ad"><div class="ttname"><a href="classllvm_1_1MDNode.html#a3c210e8905029a012df3384a7eeb63ad">llvm::MDNode::getMostGenericTBAA</a></div><div class="ttdeci">static MDNode * getMostGenericTBAA(MDNode *A, MDNode *B)</div><div class="ttdoc">Methods for metadata merging. </div><div class="ttdef"><b>Definition:</b> <a href="TypeBasedAliasAnalysis_8cpp_source.html#l00556">TypeBasedAliasAnalysis.cpp:556</a></div></div>
<div class="ttc" id="classllvm_1_1Value_html_af85a4828b6b5a8de7fc0a55cc0e5b52f"><div class="ttname"><a href="classllvm_1_1Value.html#af85a4828b6b5a8de7fc0a55cc0e5b52f">llvm::Value::getContext</a></div><div class="ttdeci">LLVMContext &amp; getContext() const </div><div class="ttdoc">All values hold a context through their type. </div><div class="ttdef"><b>Definition:</b> <a href="Value_8cpp_source.html#l00517">Value.cpp:517</a></div></div>
<div class="ttc" id="classT_html"><div class="ttname"><a href="classT.html">T</a></div></div>
<div class="ttc" id="classllvm_1_1AliasAnalysis_html_a64eefe72b0df7de20f76983b398f72df"><div class="ttname"><a href="classllvm_1_1AliasAnalysis.html#a64eefe72b0df7de20f76983b398f72df">llvm::AliasAnalysis::getModRefBehavior</a></div><div class="ttdeci">virtual ModRefBehavior getModRefBehavior(ImmutableCallSite CS)</div><div class="ttdoc">getModRefBehavior - Return the behavior when calling the given call site. </div><div class="ttdef"><b>Definition:</b> <a href="AliasAnalysis_8cpp_source.html#l00199">AliasAnalysis.cpp:199</a></div></div>
<div class="ttc" id="classllvm_1_1IntegerType_html_a14f7b4f1aed38192fb6b7772eb506bdb"><div class="ttname"><a href="classllvm_1_1IntegerType.html#a14f7b4f1aed38192fb6b7772eb506bdb">llvm::IntegerType::get</a></div><div class="ttdeci">static IntegerType * get(LLVMContext &amp;C, unsigned NumBits)</div><div class="ttdoc">Get or create an IntegerType instance. </div><div class="ttdef"><b>Definition:</b> <a href="Type_8cpp_source.html#l00305">Type.cpp:305</a></div></div>
<div class="ttc" id="classllvm_1_1ConstantInt_html"><div class="ttname"><a href="classllvm_1_1ConstantInt.html">llvm::ConstantInt</a></div><div class="ttdoc">Class for constant integers. </div><div class="ttdef"><b>Definition:</b> <a href="Constants_8h_source.html#l00051">Constants.h:51</a></div></div>
<div class="ttc" id="classllvm_1_1ImmutablePass_html"><div class="ttname"><a href="classllvm_1_1ImmutablePass.html">llvm::ImmutablePass</a></div><div class="ttdef"><b>Definition:</b> <a href="Pass_8h_source.html#l00261">Pass.h:261</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVector_html"><div class="ttname"><a href="classllvm_1_1SmallVector.html">llvm::SmallVector</a></div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00880">SmallVector.h:880</a></div></div>
<div class="ttc" id="Module_8h_html"><div class="ttname"><a href="Module_8h.html">Module.h</a></div></div>
<div class="ttc" id="classllvm_1_1Instruction_html_aafa29112cbe02e4adc9b36752c771991"><div class="ttname"><a href="classllvm_1_1Instruction.html#aafa29112cbe02e4adc9b36752c771991">llvm::Instruction::getMetadata</a></div><div class="ttdeci">MDNode * getMetadata(unsigned KindID) const </div><div class="ttdef"><b>Definition:</b> <a href="Instruction_8h_source.html#l00140">Instruction.h:140</a></div></div>
<div class="ttc" id="classllvm_1_1ConstantInt_html_a9105541412dab869e18b3cceebfff07d"><div class="ttname"><a href="classllvm_1_1ConstantInt.html#a9105541412dab869e18b3cceebfff07d">llvm::ConstantInt::get</a></div><div class="ttdeci">static Constant * get(Type *Ty, uint64_t V, bool isSigned=false)</div><div class="ttdef"><b>Definition:</b> <a href="Constants_8cpp_source.html#l00492">Constants.cpp:492</a></div></div>
<div class="ttc" id="TypeBasedAliasAnalysis_8cpp_html_a982c9d171140ae8b360d60230aeb0bbc"><div class="ttname"><a href="TypeBasedAliasAnalysis_8cpp.html#a982c9d171140ae8b360d60230aeb0bbc">INITIALIZE_AG_PASS</a></div><div class="ttdeci">INITIALIZE_AG_PASS(TypeBasedAliasAnalysis, AliasAnalysis,&quot;tbaa&quot;,&quot;Type-Based Alias Analysis&quot;, false, true, false) ImmutablePass *llvm</div><div class="ttdef"><b>Definition:</b> <a href="TypeBasedAliasAnalysis_8cpp_source.html#l00316">TypeBasedAliasAnalysis.cpp:316</a></div></div>
<div class="ttc" id="classllvm_1_1AnalysisUsage_html_af22b06a6a4f9df80454071685a0d6a02"><div class="ttname"><a href="classllvm_1_1AnalysisUsage.html#af22b06a6a4f9df80454071685a0d6a02">llvm::AnalysisUsage::setPreservesAll</a></div><div class="ttdeci">void setPreservesAll()</div><div class="ttdef"><b>Definition:</b> <a href="PassAnalysisSupport_8h_source.html#l00094">PassAnalysisSupport.h:94</a></div></div>
<div class="ttc" id="Pass_8h_html"><div class="ttname"><a href="Pass_8h.html">Pass.h</a></div></div>
<div class="ttc" id="classllvm_1_1AliasAnalysis_html_ae46bcf64f0fc3010424d4582dbb44391"><div class="ttname"><a href="classllvm_1_1AliasAnalysis.html#ae46bcf64f0fc3010424d4582dbb44391">llvm::AliasAnalysis::ID</a></div><div class="ttdeci">static char ID</div><div class="ttdef"><b>Definition:</b> <a href="AliasAnalysis_8h_source.html#l00077">AliasAnalysis.h:77</a></div></div>
<div class="ttc" id="TypeBasedAliasAnalysis_8cpp_html_ac9cc1aa1eaf0273f5628439f8f9026df"><div class="ttname"><a href="TypeBasedAliasAnalysis_8cpp.html#ac9cc1aa1eaf0273f5628439f8f9026df">EnableTBAA</a></div><div class="ttdeci">static cl::opt&lt; bool &gt; EnableTBAA(&quot;enable-tbaa&quot;, cl::init(true))</div></div>
<div class="ttc" id="AliasAnalysis_8h_html"><div class="ttname"><a href="AliasAnalysis_8h.html">AliasAnalysis.h</a></div></div>
<div class="ttc" id="classllvm_1_1cl_1_1opt_html"><div class="ttname"><a href="classllvm_1_1cl_1_1opt.html">llvm::cl::opt</a></div><div class="ttdef"><b>Definition:</b> <a href="CommandLine_8h_source.html#l01149">CommandLine.h:1149</a></div></div>
<div class="ttc" id="classllvm_1_1ImmutableCallSite_html"><div class="ttname"><a href="classllvm_1_1ImmutableCallSite.html">llvm::ImmutableCallSite</a></div><div class="ttdoc">ImmutableCallSite - establish a view to a call site for examination. </div><div class="ttdef"><b>Definition:</b> <a href="CallSite_8h_source.html#l00318">CallSite.h:318</a></div></div>
<div class="ttc" id="regcomp_8c_html_a0240ac851181b84ac374872dc5434ee4"><div class="ttname"><a href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a></div><div class="ttdeci">#define N</div></div>
<div class="ttc" id="LLVMContext_8h_html"><div class="ttname"><a href="LLVMContext_8h.html">LLVMContext.h</a></div></div>
<div class="ttc" id="classllvm_1_1Value_html"><div class="ttname"><a href="classllvm_1_1Value.html">llvm::Value</a></div><div class="ttdoc">LLVM Value Representation. </div><div class="ttdef"><b>Definition:</b> <a href="Value_8h_source.html#l00066">Value.h:66</a></div></div>
<div class="ttc" id="classllvm_1_1AliasAnalysis_html_a83d29c51155787c607268c2659559460"><div class="ttname"><a href="classllvm_1_1AliasAnalysis.html#a83d29c51155787c607268c2659559460">llvm::AliasAnalysis::ModRefResult</a></div><div class="ttdeci">ModRefResult</div><div class="ttdef"><b>Definition:</b> <a href="AliasAnalysis_8h_source.html#l00231">AliasAnalysis.h:231</a></div></div>
<div class="ttc" id="Target_2X86_2README_8txt_html_ac88fe1d3a61b056a4f64fbbb156a62ff"><div class="ttname"><a href="Target_2X86_2README_8txt.html#ac88fe1d3a61b056a4f64fbbb156a62ff">M</a></div><div class="ttdeci">We currently emits eax Perhaps this is what we really should generate is Is imull three or four cycles eax eax The current instruction priority is based on pattern complexity The former is more complex because it folds a load so the latter will not be emitted Perhaps we should use AddedComplexity to give LEA32r a higher priority We should always try to match LEA first since the LEA matching code does some estimate to determine whether the match is profitable if we care more about code then imull is better It s two bytes shorter than movl leal On a Pentium M</div><div class="ttdef"><b>Definition:</b> <a href="Target_2X86_2README_8txt_source.html#l00297">Target/X86/README.txt:297</a></div></div>
<div class="ttc" id="BasicAliasAnalysis_8cpp_html_a2675de1d8479c7b00387979714da43f7"><div class="ttname"><a href="BasicAliasAnalysis_8cpp.html#a2675de1d8479c7b00387979714da43f7">getParent</a></div><div class="ttdeci">static const Function * getParent(const Value *V)</div><div class="ttdef"><b>Definition:</b> <a href="BasicAliasAnalysis_8cpp_source.html#l00447">BasicAliasAnalysis.cpp:447</a></div></div>
<div class="ttc" id="classllvm_1_1AliasAnalysis_html_aa2f12c9f80c62624255ac0f4893f496e"><div class="ttname"><a href="classllvm_1_1AliasAnalysis.html#aa2f12c9f80c62624255ac0f4893f496e">llvm::AliasAnalysis::getAnalysisUsage</a></div><div class="ttdeci">virtual void getAnalysisUsage(AnalysisUsage &amp;AU) const </div><div class="ttdef"><b>Definition:</b> <a href="AliasAnalysis_8cpp_source.html#l00482">AliasAnalysis.cpp:482</a></div></div>
<div class="ttc" id="classllvm_1_1MDString_html"><div class="ttname"><a href="classllvm_1_1MDString.html">llvm::MDString</a></div><div class="ttdef"><b>Definition:</b> <a href="Metadata_8h_source.html#l00039">Metadata.h:39</a></div></div>
<div class="ttc" id="Target_2ARM_2README_8txt_html_a90cca76dd78688687e0d697679dbc799"><div class="ttname"><a href="Target_2ARM_2README_8txt.html#a90cca76dd78688687e0d697679dbc799">B</a></div><div class="ttdeci">compiles ldr LCPI1_0 ldr ldr mov lsr tst moveq r1 ldr LCPI1_1 and r0 bx lr It would be better to do something like to fold the shift into the conditional ldr LCPI1_0 ldr ldr tst movne lsr ldr LCPI1_1 and r0 bx lr it saves an instruction and a register It might be profitable to cse MOVi16 if there are lots of bit immediates with the same bottom half Robert Muth started working on an alternate jump table implementation that does not put the tables in line in the text This is more like the llvm default jump table implementation This might be useful sometime Several revisions of patches are on the mailing beginning while CMP sets them like a subtract Therefore to be able to use CMN for comparisons other than the Z we ll need additional logic to reverse the conditionals associated with the comparison Perhaps a pseudo instruction for the with a post codegen pass to clean up and handle the condition codes See PR5694 for testcase Given the following on int B</div><div class="ttdef"><b>Definition:</b> <a href="Target_2ARM_2README_8txt_source.html#l00592">Target/ARM/README.txt:592</a></div></div>
<div class="ttc" id="TypeBasedAliasAnalysis_8cpp_html_a5e19d69f8c65d343b518e66bef56db58"><div class="ttname"><a href="TypeBasedAliasAnalysis_8cpp.html#a5e19d69f8c65d343b518e66bef56db58">isStructPathTBAA</a></div><div class="ttdeci">static bool isStructPathTBAA(const MDNode *MD)</div><div class="ttdef"><b>Definition:</b> <a href="TypeBasedAliasAnalysis_8cpp_source.html#l00332">TypeBasedAliasAnalysis.cpp:332</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<hr>
<p class="footer">
Generated on Sat Nov 10 2018 23:02:57 for <a href="http://llvm.org/">LLVM</a> by
<a href="http://www.doxygen.org"><img src="doxygen.png" alt="Doxygen"
align="middle" border="0"/>1.8.11</a><br>
Copyright &copy; 2003-2013 University of Illinois at Urbana-Champaign.
All Rights Reserved.</p>
<hr>
<!--#include virtual="/attrib.incl" -->
</body>
</html>
