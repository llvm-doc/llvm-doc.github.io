<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="keywords" content="LLVM,Low Level Virtual Machine,C++,doxygen,API,documentation"/>
<meta name="description" content="C++ source code API documentation for LLVM."/>
<title>LLVM: SROA.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head><body>
<p class="title">LLVM API Documentation</p>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('SROA_8cpp_source.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">SROA.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="SROA_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//===- SROA.cpp - Scalar Replacement Of Aggregates ------------------------===//</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">//                     The LLVM Compiler Infrastructure</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// This file is distributed under the University of Illinois Open Source</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">// License. See LICENSE.TXT for details.</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span><span class="comment"></span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">/// \file</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">/// This transformation implements the well known scalar replacement of</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">/// aggregates transformation. It tries to identify promotable elements of an</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">/// aggregate alloca, and promote them to registers. It will also try to</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">/// convert uses of an element (or set of elements) of an alloca into a vector</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">/// or bitfield-style integer scalar if appropriate.</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">/// It works to do this with minimal slicing of the alloca so that regions</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">/// which are merely transferred in and out of external memory remain unchanged</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment">/// and are not decomposed to scalar code.</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">/// Because this also performs alloca promotion, it can be thought of as also</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment">/// serving the purpose of SSA formation. The algorithm iterates on the</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">/// function until all opportunities for promotion have been realized.</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment"></span><span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">   26</a></span>&#160;<span class="preprocessor">#define DEBUG_TYPE &quot;sroa&quot;</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Transforms_2Scalar_8h.html">llvm/Transforms/Scalar.h</a>&quot;</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="STLExtras_8h.html">llvm/ADT/STLExtras.h</a>&quot;</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="SetVector_8h.html">llvm/ADT/SetVector.h</a>&quot;</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="SmallVector_8h.html">llvm/ADT/SmallVector.h</a>&quot;</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Statistic_8h.html">llvm/ADT/Statistic.h</a>&quot;</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Dominators_8h.html">llvm/Analysis/Dominators.h</a>&quot;</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Loads_8h.html">llvm/Analysis/Loads.h</a>&quot;</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="PtrUseVisitor_8h.html">llvm/Analysis/PtrUseVisitor.h</a>&quot;</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="ValueTracking_8h.html">llvm/Analysis/ValueTracking.h</a>&quot;</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="DIBuilder_8h.html">llvm/DIBuilder.h</a>&quot;</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="DebugInfo_8h.html">llvm/DebugInfo.h</a>&quot;</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Constants_8h.html">llvm/IR/Constants.h</a>&quot;</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="DataLayout_8h.html">llvm/IR/DataLayout.h</a>&quot;</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="DerivedTypes_8h.html">llvm/IR/DerivedTypes.h</a>&quot;</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Function_8h.html">llvm/IR/Function.h</a>&quot;</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="IRBuilder_8h.html">llvm/IR/IRBuilder.h</a>&quot;</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Instructions_8h.html">llvm/IR/Instructions.h</a>&quot;</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="IntrinsicInst_8h.html">llvm/IR/IntrinsicInst.h</a>&quot;</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="LLVMContext_8h.html">llvm/IR/LLVMContext.h</a>&quot;</span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Operator_8h.html">llvm/IR/Operator.h</a>&quot;</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="InstVisitor_8h.html">llvm/InstVisitor.h</a>&quot;</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Pass_8h.html">llvm/Pass.h</a>&quot;</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="CommandLine_8h.html">llvm/Support/CommandLine.h</a>&quot;</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Compiler_8h.html">llvm/Support/Compiler.h</a>&quot;</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Debug_8h.html">llvm/Support/Debug.h</a>&quot;</span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="ErrorHandling_8h.html">llvm/Support/ErrorHandling.h</a>&quot;</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="MathExtras_8h.html">llvm/Support/MathExtras.h</a>&quot;</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="raw__ostream_8h.html">llvm/Support/raw_ostream.h</a>&quot;</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Local_8h.html">llvm/Transforms/Utils/Local.h</a>&quot;</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="PromoteMemToReg_8h.html">llvm/Transforms/Utils/PromoteMemToReg.h</a>&quot;</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="SSAUpdater_8h.html">llvm/Transforms/Utils/SSAUpdater.h</a>&quot;</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespacellvm.html">llvm</a>;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<a class="code" href="SROA_8cpp.html#ae70113602d2d74907fc766c32cc4ae7d">STATISTIC</a>(NumAllocasAnalyzed, <span class="stringliteral">&quot;Number of allocas analyzed for replacement&quot;</span>);</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<a class="code" href="SROA_8cpp.html#ae70113602d2d74907fc766c32cc4ae7d">STATISTIC</a>(NumAllocaPartitions, <span class="stringliteral">&quot;Number of alloca partitions formed&quot;</span>);</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<a class="code" href="SROA_8cpp.html#ae70113602d2d74907fc766c32cc4ae7d">STATISTIC</a>(MaxPartitionsPerAlloca, <span class="stringliteral">&quot;Maximum number of partitions per alloca&quot;</span>);</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<a class="code" href="SROA_8cpp.html#ae70113602d2d74907fc766c32cc4ae7d">STATISTIC</a>(NumAllocaPartitionUses, <span class="stringliteral">&quot;Number of alloca partition uses rewritten&quot;</span>);</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<a class="code" href="SROA_8cpp.html#ae70113602d2d74907fc766c32cc4ae7d">STATISTIC</a>(MaxUsesPerAllocaPartition, <span class="stringliteral">&quot;Maximum number of uses of a partition&quot;</span>);</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<a class="code" href="SROA_8cpp.html#ae70113602d2d74907fc766c32cc4ae7d">STATISTIC</a>(NumNewAllocas, <span class="stringliteral">&quot;Number of new, smaller allocas introduced&quot;</span>);</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<a class="code" href="SROA_8cpp.html#ae70113602d2d74907fc766c32cc4ae7d">STATISTIC</a>(NumPromoted, <span class="stringliteral">&quot;Number of allocas promoted to SSA values&quot;</span>);</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<a class="code" href="SROA_8cpp.html#ae70113602d2d74907fc766c32cc4ae7d">STATISTIC</a>(NumLoadsSpeculated, <span class="stringliteral">&quot;Number of loads speculated to allow promotion&quot;</span>);</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<a class="code" href="SROA_8cpp.html#ae70113602d2d74907fc766c32cc4ae7d">STATISTIC</a>(NumDeleted, <span class="stringliteral">&quot;Number of instructions deleted&quot;</span>);</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<a class="code" href="SROA_8cpp.html#ae70113602d2d74907fc766c32cc4ae7d">STATISTIC</a>(NumVectorized, <span class="stringliteral">&quot;Number of vectorized aggregates&quot;</span>);</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment">/// Hidden option to force the pass to not use DomTree and mem2reg, instead</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="comment">/// forming SSA values through the SSAUpdater infrastructure.</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="classllvm_1_1cl_1_1opt.html">cl::opt&lt;bool&gt;</a></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<a class="code" href="SROA_8cpp.html#a613f24111340d4f4fc57e01da7a083b5">ForceSSAUpdater</a>(<span class="stringliteral">&quot;force-ssa-updater&quot;</span>, <a class="code" href="namespacellvm_1_1cl.html#a10a041239ae1870cfcc064bfaa79fb65">cl::init</a>(<span class="keyword">false</span>), <a class="code" href="namespacellvm_1_1cl.html#a68075925a54790e71ca790e1d4f21a40a263ac008d8d31f13ce460395fc4cf7e6">cl::Hidden</a>);</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="keyword">namespace </span>{<span class="comment"></span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="comment">/// \brief A custom IRBuilder inserter which prefixes all names if they are</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="comment">/// preserved.</span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="comment"></span><span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> preserveNames = true&gt;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="keyword">class </span>IRBuilderPrefixedInserter :</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="keyword">public</span> <a class="code" href="classllvm_1_1IRBuilderDefaultInserter.html">IRBuilderDefaultInserter</a>&lt;preserveNames&gt; {</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  std::string <a class="code" href="namespacellvm_1_1cl.html#afcbd4ecc474e2d218391d6d3027b086aa7861ef1db44eac8ea7a373cd7c53a7c5">Prefix</a>;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  <span class="keywordtype">void</span> SetNamePrefix(<span class="keyword">const</span> <a class="code" href="classllvm_1_1Twine.html">Twine</a> &amp;<a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>) { Prefix = P.<a class="code" href="classllvm_1_1Twine.html#aaabc8308782f695c3a2cc9dee510ab53">str</a>(); }</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="keyword">protected</span>:</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  <span class="keywordtype">void</span> InsertHelper(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <span class="keyword">const</span> <a class="code" href="classllvm_1_1Twine.html">Twine</a> &amp;<a class="code" href="namespacellvm_1_1GraphProgram.html#a0ad4685976f8c4d4a697a53fbe05d10b">Name</a>, <a class="code" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *<a class="code" href="CodeGen_2README_8txt.html#a09776db24cf586ec9f1e18f3bae14099">BB</a>,</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;                    <a class="code" href="classllvm_1_1ilist__iterator.html">BasicBlock::iterator</a> InsertPt)<span class="keyword"> const </span>{</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <a class="code" href="classllvm_1_1IRBuilderDefaultInserter.html#ad590e4afac186c7dbe3e72ece537d8cd">IRBuilderDefaultInserter&lt;preserveNames&gt;::InsertHelper</a>(</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;        I, Name.<a class="code" href="classllvm_1_1Twine.html#ac05f9009bd52e63b62e642bfdd24869b">isTriviallyEmpty</a>() ? Name : Prefix + <a class="code" href="namespacellvm_1_1GraphProgram.html#a0ad4685976f8c4d4a697a53fbe05d10b">Name</a>, <a class="code" href="CodeGen_2README_8txt.html#a09776db24cf586ec9f1e18f3bae14099">BB</a>, InsertPt);</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;  }</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;};</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment">// Specialization for not preserving the name is trivial.</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="keyword">template</span> &lt;&gt;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="keyword">class </span>IRBuilderPrefixedInserter&lt;<a class="code" href="namespacefalse.html">false</a>&gt; :</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <span class="keyword">public</span> <a class="code" href="classllvm_1_1IRBuilderDefaultInserter.html">IRBuilderDefaultInserter</a>&lt;false&gt; {</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;  <span class="keywordtype">void</span> SetNamePrefix(<span class="keyword">const</span> <a class="code" href="classllvm_1_1Twine.html">Twine</a> &amp;P) {}</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;};</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="comment">/// \brief Provide a typedef for IRBuilder that drops names in release builds.</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="comment"></span><span class="preprocessor">#ifndef NDEBUG</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="keyword">typedef</span> <a class="code" href="classllvm_1_1IRBuilder.html">llvm::IRBuilder</a>&lt;<span class="keyword">true</span>, <a class="code" href="classllvm_1_1ConstantFolder.html">ConstantFolder</a>,</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;                        IRBuilderPrefixedInserter&lt;true&gt; &gt; IRBuilderTy;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="preprocessor">#else</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="keyword">typedef</span> llvm::IRBuilder&lt;<span class="keyword">false</span>, ConstantFolder,</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                        IRBuilderPrefixedInserter&lt;false&gt; &gt; IRBuilderTy;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;}</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="keyword">namespace </span>{<span class="comment"></span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="comment">/// \brief A used slice of an alloca.</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment">/// This structure represents a slice of an alloca used by some instruction. It</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">/// stores both the begin and end offsets of this use, a pointer to the use</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment">/// itself, and a flag indicating whether we can classify the use as splittable</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment">/// or not when forming partitions of the alloca.</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment"></span><span class="keyword">class </span>Slice {<span class="comment"></span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment">  /// \brief The beginning offset of the range.</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment"></span>  uint64_t BeginOffset;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="comment">  /// \brief The ending offset, not included in the range.</span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="comment"></span>  uint64_t EndOffset;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment">  /// \brief Storage for both the use of this slice and whether it can be</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment">  /// split.</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1PointerIntPair.html">PointerIntPair&lt;Use *, 1, bool&gt;</a> UseAndIsSplittable;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  Slice() : BeginOffset(), EndOffset() {}</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  Slice(uint64_t BeginOffset, uint64_t EndOffset, <a class="code" href="classllvm_1_1Use.html">Use</a> *U, <span class="keywordtype">bool</span> IsSplittable)</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;      : BeginOffset(BeginOffset), EndOffset(EndOffset),</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        UseAndIsSplittable(U, IsSplittable) {}</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  uint64_t beginOffset()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> BeginOffset; }</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  uint64_t endOffset()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> EndOffset; }</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  <span class="keywordtype">bool</span> isSplittable()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> UseAndIsSplittable.<a class="code" href="classllvm_1_1PointerIntPair.html#ae8f9fce2cb409f89c47535165f214a23">getInt</a>(); }</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  <span class="keywordtype">void</span> makeUnsplittable() { UseAndIsSplittable.<a class="code" href="classllvm_1_1PointerIntPair.html#a725b89e7964f33d7dfeb38dfe00a45f8">setInt</a>(<span class="keyword">false</span>); }</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  <a class="code" href="classllvm_1_1Use.html">Use</a> *getUse()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> UseAndIsSplittable.<a class="code" href="classllvm_1_1PointerIntPair.html#a2aafa035d16eddeaadc40efbf8c721e5">getPointer</a>(); }</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;  <span class="keywordtype">bool</span> isDead()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> getUse() == 0; }</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;  <span class="keywordtype">void</span> kill() { UseAndIsSplittable.<a class="code" href="classllvm_1_1PointerIntPair.html#aca7e197fbcd4f17cae48e6f55969ab94">setPointer</a>(0); }</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="comment">  /// \brief Support for ordering ranges.</span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="comment">  /// This provides an ordering over ranges such that start offsets are</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment">  /// always increasing, and within equal start offsets, the end offsets are</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment">  /// decreasing. Thus the spanning range comes first in a cluster with the</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment">  /// same start position.</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#a7c469a194119a14e5a018ebb9b847cf0">operator&lt;</a>(<span class="keyword">const</span> Slice &amp;RHS)<span class="keyword"> const </span>{</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    <span class="keywordflow">if</span> (beginOffset() &lt; RHS.beginOffset()) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;    <span class="keywordflow">if</span> (beginOffset() &gt; RHS.beginOffset()) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    <span class="keywordflow">if</span> (isSplittable() != RHS.isSplittable()) <span class="keywordflow">return</span> !isSplittable();</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    <span class="keywordflow">if</span> (endOffset() &gt; RHS.endOffset()) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  }</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="comment">  /// \brief Support comparison with a single offset to allow binary searches.</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="comment"></span>  <span class="keyword">friend</span> <a class="code" href="Compiler_8h.html#acc1c483f4b4ee2f17bb6643a3b353609">LLVM_ATTRIBUTE_UNUSED</a> <span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#a7c469a194119a14e5a018ebb9b847cf0">operator&lt;</a>(<span class="keyword">const</span> Slice &amp;LHS,</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                                              uint64_t RHSOffset) {</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    <span class="keywordflow">return</span> LHS.beginOffset() &lt; RHSOffset;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;  }</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;  <span class="keyword">friend</span> <a class="code" href="Compiler_8h.html#acc1c483f4b4ee2f17bb6643a3b353609">LLVM_ATTRIBUTE_UNUSED</a> <span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#a7c469a194119a14e5a018ebb9b847cf0">operator&lt;</a>(uint64_t LHSOffset,</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                                              <span class="keyword">const</span> Slice &amp;RHS) {</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    <span class="keywordflow">return</span> LHSOffset &lt; RHS.beginOffset();</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  }</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#a162c90bc179a6359438d060722bee35f">operator==</a>(<span class="keyword">const</span> Slice &amp;RHS)<span class="keyword"> const </span>{</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    <span class="keywordflow">return</span> isSplittable() == RHS.isSplittable() &amp;&amp;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;           beginOffset() == RHS.beginOffset() &amp;&amp; endOffset() == RHS.endOffset();</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  }</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#a2f883c895f4d244f4ed56ed8a8c160c1">operator!=</a>(<span class="keyword">const</span> Slice &amp;RHS)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !<a class="code" href="namespacellvm.html#a162c90bc179a6359438d060722bee35f">operator==</a>(RHS); }</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;};</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;} <span class="comment">// end anonymous namespace</span></div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespacellvm.html">llvm</a> {</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span><a class="code" href="structllvm_1_1isPodLike.html">isPodLike</a>;</div><div class="line"><a name="l00182"></a><span class="lineno"><a class="line" href="structllvm_1_1isPodLike_3_01Slice_01_4.html">  182</a></span>&#160;<span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span><a class="code" href="structllvm_1_1isPodLike.html">isPodLike</a>&lt;Slice&gt; {</div><div class="line"><a name="l00183"></a><span class="lineno"><a class="line" href="structllvm_1_1isPodLike_3_01Slice_01_4.html#a2d4678c4a30e9f7b91e2a83455965083">  183</a></span>&#160;   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = <span class="keyword">true</span>;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;};</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;}</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="keyword">namespace </span>{<span class="comment"></span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment">/// \brief Representation of the alloca slices.</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="comment">/// This class represents the slices of an alloca which are formed by its</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="comment">/// various uses. If a pointer escapes, we can&#39;t fully build a representation</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment">/// for the slices used and we reflect that in this structure. The uses are</span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment">/// stored, sorted by increasing beginning offset and with unsplittable slices</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="comment">/// starting at a particular offset before splittable slices.</span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="comment"></span><span class="keyword">class </span>AllocaSlices {</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="keyword">public</span>:<span class="comment"></span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="comment">  /// \brief Construct the slices of a particular alloca.</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;<span class="comment"></span>  AllocaSlices(<span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> &amp;AI);</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="comment">  /// \brief Test whether a pointer to the allocation escapes our analysis.</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="comment">  /// If this is true, the slices are never fully built and should be</span></div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="comment">  /// ignored.</span></div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> isEscaped()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> PointerEscapingInstr; }</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="comment">  /// \brief Support for iterating over the slices.</span></div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="comment">  /// @{</span></div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="comment"></span>  <span class="keyword">typedef</span> <a class="code" href="classT.html">SmallVectorImpl&lt;Slice&gt;::iterator</a> iterator;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;  iterator <a class="code" href="namespacellvm_1_1sys_1_1path.html#a33706aab89e700b8f79e1fa6f4f0e3ee">begin</a>() { <span class="keywordflow">return</span> Slices.<a class="code" href="classllvm_1_1sys_1_1path_1_1const__iterator.html#a79fe46db1f88832bc90447c6ec541cf2">begin</a>(); }</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;  iterator <a class="code" href="namespacellvm_1_1sys_1_1path.html#a214ec2f04ffd92636ed4bd2717607a1d">end</a>() { <span class="keywordflow">return</span> Slices.<a class="code" href="classllvm_1_1sys_1_1path_1_1const__iterator.html#a8a503d1cbee10d1b8c8f5ac2a03b90df">end</a>(); }</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  <span class="keyword">typedef</span> <a class="code" href="classT.html">SmallVectorImpl&lt;Slice&gt;::const_iterator</a> const_iterator;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;  const_iterator <a class="code" href="namespacellvm_1_1sys_1_1path.html#a33706aab89e700b8f79e1fa6f4f0e3ee">begin</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> Slices.<a class="code" href="classllvm_1_1sys_1_1path_1_1const__iterator.html#a79fe46db1f88832bc90447c6ec541cf2">begin</a>(); }</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  const_iterator <a class="code" href="namespacellvm_1_1sys_1_1path.html#a214ec2f04ffd92636ed4bd2717607a1d">end</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> Slices.<a class="code" href="classllvm_1_1sys_1_1path_1_1const__iterator.html#a8a503d1cbee10d1b8c8f5ac2a03b90df">end</a>(); }<span class="comment"></span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="comment">  /// @}</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="comment"></span><span class="comment"></span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="comment">  /// \brief Allow iterating the dead users for this alloca.</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="comment">  /// These are instructions which will never actually use the alloca as they</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="comment">  /// are outside the allocated range. They are safe to replace with undef and</span></div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="comment">  /// delete.</span></div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="comment">  /// @{</span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="comment"></span>  <span class="keyword">typedef</span> <a class="code" href="classT.html">SmallVectorImpl&lt;Instruction *&gt;::const_iterator</a> dead_user_iterator;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;  dead_user_iterator dead_user_begin()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> DeadUsers.begin(); }</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;  dead_user_iterator dead_user_end()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> DeadUsers.end(); }<span class="comment"></span></div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="comment">  /// @}</span></div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="comment"></span><span class="comment"></span></div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment">  /// \brief Allow iterating the dead expressions referring to this alloca.</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="comment">  /// These are operands which have cannot actually be used to refer to the</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="comment">  /// alloca as they are outside its range and the user doesn&#39;t correct for</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="comment">  /// that. These mostly consist of PHI node inputs and the like which we just</span></div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="comment">  /// need to replace with undef.</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="comment">  /// @{</span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="comment"></span>  <span class="keyword">typedef</span> <a class="code" href="classT.html">SmallVectorImpl&lt;Use *&gt;::const_iterator</a> dead_op_iterator;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;  dead_op_iterator dead_op_begin()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> DeadOperands.begin(); }</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;  dead_op_iterator dead_op_end()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> DeadOperands.end(); }<span class="comment"></span></div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="comment">  /// @}</span></div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="preprocessor">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</span></div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;  <span class="keywordtype">void</span> print(<a class="code" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;OS, const_iterator <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <a class="code" href="classllvm_1_1StringRef.html">StringRef</a> Indent = <span class="stringliteral">&quot;  &quot;</span>) <span class="keyword">const</span>;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;  <span class="keywordtype">void</span> printSlice(<a class="code" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;OS, const_iterator I,</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                  <a class="code" href="classllvm_1_1StringRef.html">StringRef</a> Indent = <span class="stringliteral">&quot;  &quot;</span>) <span class="keyword">const</span>;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;  <span class="keywordtype">void</span> printUse(<a class="code" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;OS, const_iterator I,</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                <a class="code" href="classllvm_1_1StringRef.html">StringRef</a> Indent = <span class="stringliteral">&quot;  &quot;</span>) <span class="keyword">const</span>;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;  <span class="keywordtype">void</span> print(<a class="code" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;OS) <span class="keyword">const</span>;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="Compiler_8h.html#ac6a5e0eb6a9944baf6ba14b640eab6e1">LLVM_ATTRIBUTE_NOINLINE</a> <a class="code" href="Compiler_8h.html#a6881c00738b22a600dfee25a1c32dab3">LLVM_ATTRIBUTE_USED</a> <a class="code" href="namespacellvm.html#a03503773241005f01b090b9862aad304">dump</a>(const_iterator I) <span class="keyword">const</span>;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;  <span class="keywordtype">void</span> <a class="code" href="Compiler_8h.html#ac6a5e0eb6a9944baf6ba14b640eab6e1">LLVM_ATTRIBUTE_NOINLINE</a> <a class="code" href="Compiler_8h.html#a6881c00738b22a600dfee25a1c32dab3">LLVM_ATTRIBUTE_USED</a> <a class="code" href="namespacellvm.html#a03503773241005f01b090b9862aad304">dump</a>() <span class="keyword">const</span>;</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="keyword">private</span>:</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> DerivedT, <span class="keyword">typename</span> RetT = <span class="keywordtype">void</span>&gt; <span class="keyword">class </span>BuilderBase;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;  <span class="keyword">class </span>SliceBuilder;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classAllocaSlices_1_1SliceBuilder.html">AllocaSlices::SliceBuilder</a>;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="preprocessor">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</span></div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="comment">  /// \brief Handle to alloca instruction to simplify method interfaces.</span></div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> &amp;AI;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="comment">  /// \brief The instruction responsible for this alloca not having a known set</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="comment">  /// of slices.</span></div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="comment">  /// When an instruction (potentially) escapes the pointer to the alloca, we</span></div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="comment">  /// store a pointer to that here and abort trying to form slices of the</span></div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment">  /// alloca. This will be null if the alloca slices are analyzed successfully.</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *PointerEscapingInstr;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="comment">  /// \brief The slices of the alloca.</span></div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="comment">  /// We store a vector of the slices formed by uses of the alloca here. This</span></div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="comment">  /// vector is sorted by increasing begin offset, and then the unsplittable</span></div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="comment">  /// slices before the splittable ones. See the Slice inner class for more</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment">  /// details.</span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Slice, 8&gt;</a> Slices;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="comment">  /// \brief Instructions which will become dead if we rewrite the alloca.</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="comment">  /// Note that these are not separated by slice. This is because we expect an</span></div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="comment">  /// alloca to be completely rewritten or not rewritten at all. If rewritten,</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="comment">  /// all these instructions can simply be removed and replaced with undef as</span></div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="comment">  /// they come from outside of the allocated space.</span></div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Instruction *, 8&gt;</a> DeadUsers;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="comment">  /// \brief Operands which will become dead if we rewrite the alloca.</span></div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="comment">  /// These are operands that in their particular use can be replaced with</span></div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="comment">  /// undef when we rewrite the alloca. These show up in out-of-bounds inputs</span></div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="comment">  /// to PHI nodes and the like. They aren&#39;t entirely dead (there might be</span></div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="comment">  /// a GEP back into the bounds using it elsewhere) and nor is the PHI, but we</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="comment">  /// want to swap this particular input for undef to simplify the use lists of</span></div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="comment">  /// the alloca.</span></div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Use *, 8&gt;</a> DeadOperands;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;};</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;}</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;</div><div class="line"><a name="l00297"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#a849bc9de354f140d265e3ff56999ce19">  297</a></span>&#160;<span class="keyword">static</span> <a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="SROA_8cpp.html#a849bc9de354f140d265e3ff56999ce19">foldSelectInst</a>(<a class="code" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;SI) {</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;  <span class="comment">// If the condition being selected on is a constant or the same value is</span></div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;  <span class="comment">// being selected between, fold the select. Yes this does (rarely) happen</span></div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;  <span class="comment">// early on.</span></div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1ConstantInt.html">ConstantInt</a> *CI = dyn_cast&lt;ConstantInt&gt;(SI.<a class="code" href="classllvm_1_1SelectInst.html#ad285a69e32ddeee367fed93b5f392801">getCondition</a>()))</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    <span class="keywordflow">return</span> SI.<a class="code" href="classllvm_1_1User.html#a997ff6a1758bf732b9b263fc61011644">getOperand</a>(1+CI-&gt;isZero());</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;  <span class="keywordflow">if</span> (SI.<a class="code" href="classllvm_1_1User.html#a997ff6a1758bf732b9b263fc61011644">getOperand</a>(1) == SI.<a class="code" href="classllvm_1_1User.html#a997ff6a1758bf732b9b263fc61011644">getOperand</a>(2))</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    <span class="keywordflow">return</span> SI.<a class="code" href="classllvm_1_1User.html#a997ff6a1758bf732b9b263fc61011644">getOperand</a>(1);</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;  <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;}</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="comment">/// \brief Builder for the alloca slices.</span></div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;<span class="comment">/// This class builds a set of alloca slices by recursively visiting the uses</span></div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;<span class="comment">/// of an alloca and making a slice for each load and store at each offset.</span></div><div class="line"><a name="l00313"></a><span class="lineno"><a class="line" href="classAllocaSlices_1_1SliceBuilder.html">  313</a></span>&#160;<span class="comment"></span><span class="keyword">class </span><a class="code" href="classAllocaSlices_1_1SliceBuilder.html">AllocaSlices::SliceBuilder</a> : <span class="keyword">public</span> <a class="code" href="classllvm_1_1PtrUseVisitor.html">PtrUseVisitor</a>&lt;SliceBuilder&gt; {</div><div class="line"><a name="l00314"></a><span class="lineno"><a class="line" href="classAllocaSlices_1_1SliceBuilder.html#ab35732d98347554d3d2ed0460bc1ab26">  314</a></span>&#160;  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classllvm_1_1PtrUseVisitor.html">PtrUseVisitor</a>&lt;<a class="code" href="classAllocaSlices_1_1SliceBuilder.html">SliceBuilder</a>&gt;;</div><div class="line"><a name="l00315"></a><span class="lineno"><a class="line" href="classAllocaSlices_1_1SliceBuilder.html#abb0399d372fbb120a3e1e0672af49785">  315</a></span>&#160;  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classllvm_1_1InstVisitor.html">InstVisitor</a>&lt;<a class="code" href="classAllocaSlices_1_1SliceBuilder.html">SliceBuilder</a>&gt;;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;  <span class="keyword">typedef</span> <a class="code" href="classllvm_1_1PtrUseVisitor.html">PtrUseVisitor&lt;SliceBuilder&gt;</a> <a class="code" href="classllvm_1_1PtrUseVisitor.html">Base</a>;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;  <span class="keyword">const</span> uint64_t AllocSize;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;  AllocaSlices &amp;<a class="code" href="Target_2ARM_2README_8txt.html#a1b45f45820a60c09244a87eb59824aec">S</a>;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;  <a class="code" href="classllvm_1_1SmallDenseMap.html">SmallDenseMap&lt;Instruction *, unsigned&gt;</a> MemTransferSliceMap;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;  <a class="code" href="classllvm_1_1SmallDenseMap.html">SmallDenseMap&lt;Instruction *, uint64_t&gt;</a> PHIOrSelectSizes;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="comment">  /// \brief Set to de-duplicate dead instructions found in the use walk.</span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet&lt;Instruction *, 4&gt;</a> VisitedDeadInsts;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00328"></a><span class="lineno"><a class="line" href="classAllocaSlices_1_1SliceBuilder.html#ad113f431e82837ba1618b47f6ae6f5c8">  328</a></span>&#160;  <a class="code" href="classAllocaSlices_1_1SliceBuilder.html#ad113f431e82837ba1618b47f6ae6f5c8">SliceBuilder</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> &amp;AI, AllocaSlices &amp;S)</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;      : <a class="code" href="classllvm_1_1PtrUseVisitor.html">PtrUseVisitor</a>&lt;<a class="code" href="classAllocaSlices_1_1SliceBuilder.html">SliceBuilder</a>&gt;(DL),</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;        AllocSize(DL.getTypeAllocSize(AI.getAllocatedType())), S(S) {}</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="keyword">private</span>:</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;  <span class="keywordtype">void</span> markAsDead(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> &amp;<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) {</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    <span class="keywordflow">if</span> (VisitedDeadInsts.<a class="code" href="classllvm_1_1SmallPtrSet.html#a9b6dd0fc7a648a939e571246045b673e">insert</a>(&amp;I))</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;      S.DeadUsers.push_back(&amp;I);</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;  }</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;  <span class="keywordtype">void</span> insertUse(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> &amp;I, <span class="keyword">const</span> <a class="code" href="classllvm_1_1APInt.html">APInt</a> &amp;Offset, uint64_t Size,</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;                 <span class="keywordtype">bool</span> IsSplittable = <span class="keyword">false</span>) {</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="comment">// Completely skip uses which have a zero size or start either before or</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    <span class="comment">// past the end of the allocation.</span></div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    <span class="keywordflow">if</span> (Size == 0 || Offset.<a class="code" href="classllvm_1_1APInt.html#a0e9a2d7ec903d191ef029589ec647cb6">isNegative</a>() || Offset.<a class="code" href="classllvm_1_1APInt.html#a0229ff3a1d7432810a86c8efab115c33">uge</a>(AllocSize)) {</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;      <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;WARNING: Ignoring &quot;</span> &lt;&lt; Size &lt;&lt; <span class="stringliteral">&quot; byte use @&quot;</span> &lt;&lt; Offset</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;                   &lt;&lt; <span class="stringliteral">&quot; which has zero size or starts outside of the &quot;</span></div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;                   &lt;&lt; AllocSize &lt;&lt; <span class="stringliteral">&quot; byte alloca:\n&quot;</span></div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;                   &lt;&lt; <span class="stringliteral">&quot;    alloca: &quot;</span> &lt;&lt; S.AI &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                   &lt;&lt; <span class="stringliteral">&quot;       use: &quot;</span> &lt;&lt; I &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;      <span class="keywordflow">return</span> markAsDead(I);</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;    }</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    uint64_t BeginOffset = Offset.<a class="code" href="classllvm_1_1APInt.html#a7dc983ebf0eb2d255fa90a67063c72e2">getZExtValue</a>();</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    uint64_t EndOffset = BeginOffset + Size;</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    <span class="comment">// Clamp the end offset to the end of the allocation. Note that this is</span></div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;    <span class="comment">// formulated to handle even the case where &quot;BeginOffset + Size&quot; overflows.</span></div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <span class="comment">// This may appear superficially to be something we could ignore entirely,</span></div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    <span class="comment">// but that is not so! There may be widened loads or PHI-node uses where</span></div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    <span class="comment">// some instructions are dead but not others. We can&#39;t completely ignore</span></div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    <span class="comment">// them, and so have to record at least the information here.</span></div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    assert(AllocSize &gt;= BeginOffset); <span class="comment">// Established above.</span></div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    <span class="keywordflow">if</span> (Size &gt; AllocSize - BeginOffset) {</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;      <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;WARNING: Clamping a &quot;</span> &lt;&lt; Size &lt;&lt; <span class="stringliteral">&quot; byte use @&quot;</span> &lt;&lt; Offset</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;                   &lt;&lt; <span class="stringliteral">&quot; to remain within the &quot;</span> &lt;&lt; AllocSize &lt;&lt; <span class="stringliteral">&quot; byte alloca:\n&quot;</span></div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;                   &lt;&lt; <span class="stringliteral">&quot;    alloca: &quot;</span> &lt;&lt; S.AI &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;                   &lt;&lt; <span class="stringliteral">&quot;       use: &quot;</span> &lt;&lt; I &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;      EndOffset = AllocSize;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    }</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    S.Slices.push_back(Slice(BeginOffset, EndOffset, U, IsSplittable));</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;  }</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;  <span class="keywordtype">void</span> visitBitCastInst(<a class="code" href="classllvm_1_1BitCastInst.html">BitCastInst</a> &amp;BC) {</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    <span class="keywordflow">if</span> (BC.<a class="code" href="classllvm_1_1Value.html#ac38c53f76ef532f91f1666c8a87370e9">use_empty</a>())</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;      <span class="keywordflow">return</span> markAsDead(BC);</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    <span class="keywordflow">return</span> Base::visitBitCastInst(BC);</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;  }</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;  <span class="keywordtype">void</span> visitGetElementPtrInst(<a class="code" href="classllvm_1_1GetElementPtrInst.html">GetElementPtrInst</a> &amp;GEPI) {</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    <span class="keywordflow">if</span> (GEPI.<a class="code" href="classllvm_1_1Value.html#ac38c53f76ef532f91f1666c8a87370e9">use_empty</a>())</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;      <span class="keywordflow">return</span> markAsDead(GEPI);</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    <span class="keywordflow">return</span> Base::visitGetElementPtrInst(GEPI);</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;  }</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;  <span class="keywordtype">void</span> handleLoadOrStore(<a class="code" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> &amp;I, <span class="keyword">const</span> <a class="code" href="classllvm_1_1APInt.html">APInt</a> &amp;Offset,</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;                         uint64_t Size, <span class="keywordtype">bool</span> IsVolatile) {</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    <span class="comment">// We allow splitting of loads and stores where the type is an integer type</span></div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    <span class="comment">// and cover the entire alloca. This prevents us from splitting over</span></div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    <span class="comment">// eagerly.</span></div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;    <span class="comment">// FIXME: In the great blue eventually, we should eagerly split all integer</span></div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    <span class="comment">// loads and stores, and then have a separate step that merges adjacent</span></div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    <span class="comment">// alloca partitions into a single partition suitable for integer widening.</span></div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    <span class="comment">// Or we should skip the merge step and rely on GVN and other passes to</span></div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    <span class="comment">// merge adjacent loads and stores that survive mem2reg.</span></div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    <span class="keywordtype">bool</span> IsSplittable =</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;        Ty-&gt;<a class="code" href="classllvm_1_1Type.html#a6e328feb83afa5cf1c966d6704e43fc1">isIntegerTy</a>() &amp;&amp; !IsVolatile &amp;&amp; Offset == 0 &amp;&amp; Size &gt;= AllocSize;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    insertUse(I, Offset, Size, IsSplittable);</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;  }</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;  <span class="keywordtype">void</span> visitLoadInst(<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> &amp;LI) {</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    assert((!LI.<a class="code" href="classllvm_1_1LoadInst.html#a156c478ee8e7d1602143cdbad4bd5385">isSimple</a>() || LI.<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a36e21267fe14e69d3251eab1cd3a0076">isSingleValueType</a>()) &amp;&amp;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;           <span class="stringliteral">&quot;All simple FCA loads should have been pre-split&quot;</span>);</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    <span class="keywordflow">if</span> (!IsOffsetKnown)</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;      <span class="keywordflow">return</span> PI.setAborted(&amp;LI);</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;    uint64_t Size = DL.getTypeStoreSize(LI.<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>());</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    <span class="keywordflow">return</span> handleLoadOrStore(LI.<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>(), LI, Offset, Size, LI.<a class="code" href="classllvm_1_1LoadInst.html#aeb96f1a88b4e58c34a988eebd843f688">isVolatile</a>());</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;  }</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;  <span class="keywordtype">void</span> visitStoreInst(<a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> &amp;SI) {</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *ValOp = SI.<a class="code" href="classllvm_1_1StoreInst.html#a14298313bdf734e2db5a921cc6e861a0">getValueOperand</a>();</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    <span class="keywordflow">if</span> (ValOp == *U)</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;      <span class="keywordflow">return</span> PI.setEscapedAndAborted(&amp;SI);</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    <span class="keywordflow">if</span> (!IsOffsetKnown)</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;      <span class="keywordflow">return</span> PI.setAborted(&amp;SI);</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    uint64_t Size = DL.getTypeStoreSize(ValOp-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>());</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    <span class="comment">// If this memory access can be shown to *statically* extend outside the</span></div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    <span class="comment">// bounds of of the allocation, it&#39;s behavior is undefined, so simply</span></div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    <span class="comment">// ignore it. Note that this is more strict than the generic clamping</span></div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;    <span class="comment">// behavior of insertUse. We also try to handle cases which might run the</span></div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;    <span class="comment">// risk of overflow.</span></div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    <span class="comment">// FIXME: We should instead consider the pointer to have escaped if this</span></div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    <span class="comment">// function is being instrumented for addressing bugs or race conditions.</span></div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    <span class="keywordflow">if</span> (Offset.<a class="code" href="classllvm_1_1APInt.html#a0e9a2d7ec903d191ef029589ec647cb6">isNegative</a>() || Size &gt; AllocSize ||</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;        Offset.<a class="code" href="classllvm_1_1APInt.html#ad3d358e03c6228af2d19b2e67028886e">ugt</a>(AllocSize - Size)) {</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;      <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;WARNING: Ignoring &quot;</span> &lt;&lt; Size &lt;&lt; <span class="stringliteral">&quot; byte store @&quot;</span> &lt;&lt; Offset</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;                   &lt;&lt; <span class="stringliteral">&quot; which extends past the end of the &quot;</span> &lt;&lt; AllocSize</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;                   &lt;&lt; <span class="stringliteral">&quot; byte alloca:\n&quot;</span></div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;                   &lt;&lt; <span class="stringliteral">&quot;    alloca: &quot;</span> &lt;&lt; S.AI &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;                   &lt;&lt; <span class="stringliteral">&quot;       use: &quot;</span> &lt;&lt; SI &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;      <span class="keywordflow">return</span> markAsDead(SI);</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    }</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    assert((!SI.<a class="code" href="classllvm_1_1StoreInst.html#a1149c7eeefca671ac2685bca13843568">isSimple</a>() || ValOp-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a36e21267fe14e69d3251eab1cd3a0076">isSingleValueType</a>()) &amp;&amp;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;           <span class="stringliteral">&quot;All simple FCA stores should have been pre-split&quot;</span>);</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    handleLoadOrStore(ValOp-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>(), SI, Offset, Size, SI.<a class="code" href="classllvm_1_1StoreInst.html#a89471513a05fad4bbef69ec411b2586d">isVolatile</a>());</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;  }</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;  <span class="keywordtype">void</span> visitMemSetInst(<a class="code" href="classllvm_1_1MemSetInst.html">MemSetInst</a> &amp;II) {</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    assert(II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a3ec0c47a5532e568d54c8d452dfb58df">getRawDest</a>() == *U &amp;&amp; <span class="stringliteral">&quot;Pointer use is not the destination?&quot;</span>);</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    <a class="code" href="classllvm_1_1ConstantInt.html">ConstantInt</a> *Length = <a class="code" href="namespacellvm.html#a3f2f98c2a67c9e79f58aad9150a62e42">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1ConstantInt.html">ConstantInt</a>&gt;(II.<a class="code" href="classllvm_1_1MemIntrinsic.html#abad10f74789466601c7a025540c1c072">getLength</a>());</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    <span class="keywordflow">if</span> ((Length &amp;&amp; Length-&gt;getValue() == 0) ||</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;        (IsOffsetKnown &amp;&amp; !Offset.<a class="code" href="classllvm_1_1APInt.html#a0e9a2d7ec903d191ef029589ec647cb6">isNegative</a>() &amp;&amp; Offset.<a class="code" href="classllvm_1_1APInt.html#a0229ff3a1d7432810a86c8efab115c33">uge</a>(AllocSize)))</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;      <span class="comment">// Zero-length mem transfer intrinsics can be ignored entirely.</span></div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;      <span class="keywordflow">return</span> markAsDead(II);</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    <span class="keywordflow">if</span> (!IsOffsetKnown)</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;      <span class="keywordflow">return</span> PI.setAborted(&amp;II);</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;    insertUse(II, Offset,</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;              Length ? Length-&gt;<a class="code" href="classllvm_1_1APInt.html#ae0c5e70885cf005feb6707932774f99c">getLimitedValue</a>()</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;                     : AllocSize - Offset.<a class="code" href="classllvm_1_1APInt.html#ae0c5e70885cf005feb6707932774f99c">getLimitedValue</a>(),</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;              (bool)Length);</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;  }</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;  <span class="keywordtype">void</span> visitMemTransferInst(<a class="code" href="classllvm_1_1MemTransferInst.html">MemTransferInst</a> &amp;II) {</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    <a class="code" href="classllvm_1_1ConstantInt.html">ConstantInt</a> *Length = <a class="code" href="namespacellvm.html#a3f2f98c2a67c9e79f58aad9150a62e42">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1ConstantInt.html">ConstantInt</a>&gt;(II.<a class="code" href="classllvm_1_1MemIntrinsic.html#abad10f74789466601c7a025540c1c072">getLength</a>());</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    <span class="keywordflow">if</span> ((Length &amp;&amp; Length-&gt;<a class="code" href="classllvm_1_1ConstantInt.html#af8dde13a97efce293a7b04daf1e208fb">getValue</a>() == 0) ||</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        (IsOffsetKnown &amp;&amp; !Offset.<a class="code" href="classllvm_1_1APInt.html#a0e9a2d7ec903d191ef029589ec647cb6">isNegative</a>() &amp;&amp; Offset.<a class="code" href="classllvm_1_1APInt.html#a0229ff3a1d7432810a86c8efab115c33">uge</a>(AllocSize)))</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;      <span class="comment">// Zero-length mem transfer intrinsics can be ignored entirely.</span></div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;      <span class="keywordflow">return</span> markAsDead(II);</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;    <span class="keywordflow">if</span> (!IsOffsetKnown)</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;      <span class="keywordflow">return</span> PI.setAborted(&amp;II);</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    uint64_t RawOffset = Offset.<a class="code" href="classllvm_1_1APInt.html#ae0c5e70885cf005feb6707932774f99c">getLimitedValue</a>();</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    uint64_t Size = Length ? Length-&gt;<a class="code" href="classllvm_1_1ConstantInt.html#a024bb83a7f01e7661ea72ff7dcc460f5">getLimitedValue</a>()</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;                           : AllocSize - RawOffset;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;    <span class="comment">// Check for the special case where the same exact value is used for both</span></div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;    <span class="comment">// source and dest.</span></div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    <span class="keywordflow">if</span> (*U == II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a3ec0c47a5532e568d54c8d452dfb58df">getRawDest</a>() &amp;&amp; *U == II.<a class="code" href="classllvm_1_1MemTransferInst.html#a26bfca1607622229a625f2db73aed2ba">getRawSource</a>()) {</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;      <span class="comment">// For non-volatile transfers this is a no-op.</span></div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;      <span class="keywordflow">if</span> (!II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a9558faebdbb62c072aed98e33604889d">isVolatile</a>())</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;        <span class="keywordflow">return</span> markAsDead(II);</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;      <span class="keywordflow">return</span> insertUse(II, Offset, Size, <span class="comment">/*IsSplittable=*/</span><span class="keyword">false</span>);</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    }</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;    <span class="comment">// If we have seen both source and destination for a mem transfer, then</span></div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    <span class="comment">// they both point to the same alloca.</span></div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    <span class="keywordtype">bool</span> Inserted;</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    <a class="code" href="classllvm_1_1SmallDenseMap.html">SmallDenseMap&lt;Instruction *, unsigned&gt;::iterator</a> MTPI;</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    <a class="code" href="namespacellvm.html#a7dc3e2c002713fec56bdbf16aa704576">llvm::tie</a>(MTPI, Inserted) =</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;        MemTransferSliceMap.<a class="code" href="classllvm_1_1DenseMapBase.html#a699a66e504b48fdeff124e82f6c61917">insert</a>(std::make_pair(&amp;II, S.Slices.size()));</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    <span class="keywordtype">unsigned</span> PrevIdx = MTPI-&gt;second;</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    <span class="keywordflow">if</span> (!Inserted) {</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;      Slice &amp;PrevP = S.Slices[PrevIdx];</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;      <span class="comment">// Check if the begin offsets match and this is a non-volatile transfer.</span></div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;      <span class="comment">// In that case, we can completely elide the transfer.</span></div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;      <span class="keywordflow">if</span> (!II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a9558faebdbb62c072aed98e33604889d">isVolatile</a>() &amp;&amp; PrevP.beginOffset() == RawOffset) {</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;        PrevP.kill();</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;        <span class="keywordflow">return</span> markAsDead(II);</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;      }</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;      <span class="comment">// Otherwise we have an offset transfer within the same alloca. We can&#39;t</span></div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;      <span class="comment">// split those.</span></div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;      PrevP.makeUnsplittable();</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    }</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    <span class="comment">// Insert the use now that we&#39;ve fixed up the splittable nature.</span></div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    insertUse(II, Offset, Size, <span class="comment">/*IsSplittable=*/</span>Inserted &amp;&amp; Length);</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;    <span class="comment">// Check that we ended up with a valid index in the map.</span></div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;    assert(S.Slices[PrevIdx].getUse()-&gt;getUser() == &amp;II &amp;&amp;</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;           <span class="stringliteral">&quot;Map index doesn&#39;t point back to a slice with this user.&quot;</span>);</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;  }</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;  <span class="comment">// Disable SRoA for any intrinsics except for lifetime invariants.</span></div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;  <span class="comment">// FIXME: What about debug intrinsics? This matches old behavior, but</span></div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;  <span class="comment">// doesn&#39;t make sense.</span></div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;  <span class="keywordtype">void</span> visitIntrinsicInst(<a class="code" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> &amp;II) {</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;    <span class="keywordflow">if</span> (!IsOffsetKnown)</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;      <span class="keywordflow">return</span> PI.setAborted(&amp;II);</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    <span class="keywordflow">if</span> (II.<a class="code" href="classllvm_1_1IntrinsicInst.html#a6cbb4809b81f3994ee0c79b38556bd66">getIntrinsicID</a>() == <a class="code" href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90ae365354e47542c51f9bd46e329e3323e">Intrinsic::lifetime_start</a> ||</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;        II.<a class="code" href="classllvm_1_1IntrinsicInst.html#a6cbb4809b81f3994ee0c79b38556bd66">getIntrinsicID</a>() == <a class="code" href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90aa332b90dd5e4ebf4bbbcc0964220d373">Intrinsic::lifetime_end</a>) {</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;      <a class="code" href="classllvm_1_1ConstantInt.html">ConstantInt</a> *Length = cast&lt;ConstantInt&gt;(II.<a class="code" href="classllvm_1_1CallInst.html#a150b33ecedbc8c7803c2db8040fbe3f8">getArgOperand</a>(0));</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;      uint64_t Size = std::min(AllocSize - Offset.<a class="code" href="classllvm_1_1APInt.html#ae0c5e70885cf005feb6707932774f99c">getLimitedValue</a>(),</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;                               Length-&gt;<a class="code" href="classllvm_1_1ConstantInt.html#a024bb83a7f01e7661ea72ff7dcc460f5">getLimitedValue</a>());</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;      insertUse(II, Offset, Size, <span class="keyword">true</span>);</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;      <span class="keywordflow">return</span>;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;    }</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;    Base::visitIntrinsicInst(II);</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;  }</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;  <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *hasUnsafePHIOrSelectUse(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *Root, uint64_t &amp;Size) {</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;    <span class="comment">// We consider any PHI or select that results in a direct load or store of</span></div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;    <span class="comment">// the same offset to be a viable use for slicing purposes. These uses</span></div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    <span class="comment">// are considered unsplittable and the size is the maximum loaded or stored</span></div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;    <span class="comment">// size.</span></div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;    <a class="code" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet&lt;Instruction *, 4&gt;</a> Visited;</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;std::pair&lt;Instruction *, Instruction *&gt;</a>, 4&gt; Uses;</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;    Visited.<a class="code" href="classllvm_1_1SmallPtrSet.html#a9b6dd0fc7a648a939e571246045b673e">insert</a>(Root);</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;    Uses.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(std::make_pair(cast&lt;Instruction&gt;(*U), Root));</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;    <span class="comment">// If there are no loads or stores, the access is dead. We mark that as</span></div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;    <span class="comment">// a size zero access.</span></div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;    Size = 0;</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;    <span class="keywordflow">do</span> {</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;      <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, *UsedI;</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;      <a class="code" href="namespacellvm.html#a7dc3e2c002713fec56bdbf16aa704576">llvm::tie</a>(UsedI, I) = Uses.<a class="code" href="classllvm_1_1SmallVectorImpl.html#a400eaca9881c8dcab97e9f42b1ab1815">pop_back_val</a>();</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *LI = dyn_cast&lt;LoadInst&gt;(I)) {</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;        Size = std::max(Size, DL.getTypeStoreSize(LI-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()));</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;      }</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> *SI = dyn_cast&lt;StoreInst&gt;(I)) {</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;        <a class="code" href="classllvm_1_1Value.html">Value</a> *Op = SI-&gt;<a class="code" href="classllvm_1_1User.html#a997ff6a1758bf732b9b263fc61011644">getOperand</a>(0);</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;        <span class="keywordflow">if</span> (Op == UsedI)</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;          <span class="keywordflow">return</span> SI;</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;        Size = std::max(Size, DL.getTypeStoreSize(Op-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()));</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;      }</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1GetElementPtrInst.html">GetElementPtrInst</a> *GEP = dyn_cast&lt;GetElementPtrInst&gt;(I)) {</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;        <span class="keywordflow">if</span> (!GEP-&gt;hasAllZeroIndices())</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;          <span class="keywordflow">return</span> GEP;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!isa&lt;BitCastInst&gt;(I) &amp;&amp; !isa&lt;PHINode&gt;(<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) &amp;&amp;</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;                 !isa&lt;SelectInst&gt;(I)) {</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>;</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;      }</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;      <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1value__use__iterator.html">Value::use_iterator</a> UI = I-&gt;<a class="code" href="classllvm_1_1Value.html#a413abcab8dbc3900fc2fde96a5d8fca6">use_begin</a>(), UE = I-&gt;<a class="code" href="classllvm_1_1Value.html#ad86469939d2a8bdd4169be9403b89f5a">use_end</a>(); UI != UE;</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;           ++UI)</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;        <span class="keywordflow">if</span> (Visited.<a class="code" href="classllvm_1_1SmallPtrSet.html#a9b6dd0fc7a648a939e571246045b673e">insert</a>(cast&lt;Instruction&gt;(*UI)))</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;          Uses.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(std::make_pair(I, cast&lt;Instruction&gt;(*UI)));</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;    } <span class="keywordflow">while</span> (!Uses.<a class="code" href="classllvm_1_1SmallVectorBase.html#a8a8df4d85555c7954a95f86080cd3b64">empty</a>());</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;  }</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;  <span class="keywordtype">void</span> visitPHINode(<a class="code" href="classllvm_1_1PHINode.html">PHINode</a> &amp;PN) {</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;    <span class="keywordflow">if</span> (PN.<a class="code" href="classllvm_1_1Value.html#ac38c53f76ef532f91f1666c8a87370e9">use_empty</a>())</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;      <span class="keywordflow">return</span> markAsDead(PN);</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;    <span class="keywordflow">if</span> (!IsOffsetKnown)</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;      <span class="keywordflow">return</span> PI.setAborted(&amp;PN);</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;    <span class="comment">// See if we already have computed info on this node.</span></div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;    uint64_t &amp;PHISize = PHIOrSelectSizes[&amp;PN];</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    <span class="keywordflow">if</span> (!PHISize) {</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;      <span class="comment">// This is a new PHI node, check for an unsafe use of the PHI node.</span></div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *UnsafeI = hasUnsafePHIOrSelectUse(&amp;PN, PHISize))</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;        <span class="keywordflow">return</span> PI.setAborted(UnsafeI);</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;    }</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;    <span class="comment">// For PHI and select operands outside the alloca, we can&#39;t nuke the entire</span></div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    <span class="comment">// phi or select -- the other side might still be relevant, so we special</span></div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    <span class="comment">// case them here and use a separate structure to track the operands</span></div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    <span class="comment">// themselves which should be replaced with undef.</span></div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    <span class="comment">// FIXME: This should instead be escaped in the event we&#39;re instrumenting</span></div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    <span class="comment">// for address sanitization.</span></div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;    <span class="keywordflow">if</span> ((Offset.<a class="code" href="classllvm_1_1APInt.html#a0e9a2d7ec903d191ef029589ec647cb6">isNegative</a>() &amp;&amp; (-Offset).uge(PHISize)) ||</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;        (!Offset.<a class="code" href="classllvm_1_1APInt.html#a0e9a2d7ec903d191ef029589ec647cb6">isNegative</a>() &amp;&amp; Offset.<a class="code" href="classllvm_1_1APInt.html#a0229ff3a1d7432810a86c8efab115c33">uge</a>(AllocSize))) {</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;      S.DeadOperands.push_back(U);</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;      <span class="keywordflow">return</span>;</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;    }</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;    insertUse(PN, Offset, PHISize);</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;  }</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;  <span class="keywordtype">void</span> visitSelectInst(<a class="code" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;SI) {</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;    <span class="keywordflow">if</span> (SI.<a class="code" href="classllvm_1_1Value.html#ac38c53f76ef532f91f1666c8a87370e9">use_empty</a>())</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;      <span class="keywordflow">return</span> markAsDead(SI);</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1Value.html">Value</a> *Result = <a class="code" href="SROA_8cpp.html#a849bc9de354f140d265e3ff56999ce19">foldSelectInst</a>(SI)) {</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;      <span class="keywordflow">if</span> (Result == *U)</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;        <span class="comment">// If the result of the constant fold will be the pointer, recurse</span></div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;        <span class="comment">// through the select as if we had RAUW&#39;ed it.</span></div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;        enqueueUsers(SI);</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;        <span class="comment">// Otherwise the operand to the select is dead, and we can replace it</span></div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;        <span class="comment">// with undef.</span></div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;        S.DeadOperands.push_back(U);</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;      <span class="keywordflow">return</span>;</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;    }</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;    <span class="keywordflow">if</span> (!IsOffsetKnown)</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;      <span class="keywordflow">return</span> PI.setAborted(&amp;SI);</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;    <span class="comment">// See if we already have computed info on this node.</span></div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;    uint64_t &amp;SelectSize = PHIOrSelectSizes[&amp;SI];</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;    <span class="keywordflow">if</span> (!SelectSize) {</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;      <span class="comment">// This is a new Select, check for an unsafe use of it.</span></div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *UnsafeI = hasUnsafePHIOrSelectUse(&amp;SI, SelectSize))</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;        <span class="keywordflow">return</span> PI.setAborted(UnsafeI);</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;    }</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    <span class="comment">// For PHI and select operands outside the alloca, we can&#39;t nuke the entire</span></div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;    <span class="comment">// phi or select -- the other side might still be relevant, so we special</span></div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;    <span class="comment">// case them here and use a separate structure to track the operands</span></div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;    <span class="comment">// themselves which should be replaced with undef.</span></div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;    <span class="comment">// FIXME: This should instead be escaped in the event we&#39;re instrumenting</span></div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;    <span class="comment">// for address sanitization.</span></div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;    <span class="keywordflow">if</span> ((Offset.<a class="code" href="classllvm_1_1APInt.html#a0e9a2d7ec903d191ef029589ec647cb6">isNegative</a>() &amp;&amp; Offset.<a class="code" href="classllvm_1_1APInt.html#a0229ff3a1d7432810a86c8efab115c33">uge</a>(SelectSize)) ||</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;        (!Offset.<a class="code" href="classllvm_1_1APInt.html#a0e9a2d7ec903d191ef029589ec647cb6">isNegative</a>() &amp;&amp; Offset.<a class="code" href="classllvm_1_1APInt.html#a0229ff3a1d7432810a86c8efab115c33">uge</a>(AllocSize))) {</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;      S.DeadOperands.push_back(U);</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;      <span class="keywordflow">return</span>;</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    }</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;    insertUse(SI, Offset, SelectSize);</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;  }</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;<span class="comment">  /// \brief Disable SROA entirely if there are unhandled users of the alloca.</span></div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> visitInstruction(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> &amp;I) {</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;    PI.setAborted(&amp;I);</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;  }</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;};</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;AllocaSlices::AllocaSlices(<span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> &amp;AI)</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;    :</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;<span class="preprocessor">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</span></div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;      AI(AI),</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;      PointerEscapingInstr(0) {</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;  <a class="code" href="classAllocaSlices_1_1SliceBuilder.html">SliceBuilder</a> PB(DL, AI, *<span class="keyword">this</span>);</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;  <a class="code" href="classllvm_1_1detail_1_1PtrUseVisitorBase_1_1PtrInfo.html">SliceBuilder::PtrInfo</a> PtrI = PB.<a class="code" href="classllvm_1_1PtrUseVisitor.html#a511b9034e923ca17006a820514470dd4">visitPtr</a>(AI);</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;  <span class="keywordflow">if</span> (PtrI.<a class="code" href="classllvm_1_1detail_1_1PtrUseVisitorBase_1_1PtrInfo.html#a0d01c5defbda1273d906583864bf1e2d">isEscaped</a>() || PtrI.<a class="code" href="classllvm_1_1detail_1_1PtrUseVisitorBase_1_1PtrInfo.html#a9fac5f949c3305a84085a9d37113244a">isAborted</a>()) {</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;    <span class="comment">// FIXME: We should sink the escape vs. abort info into the caller nicely,</span></div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;    <span class="comment">// possibly by just storing the PtrInfo in the AllocaSlices.</span></div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;    PointerEscapingInstr = PtrI.<a class="code" href="classllvm_1_1detail_1_1PtrUseVisitorBase_1_1PtrInfo.html#ad14328f51a170ef45854cc15a4b3564f">getEscapingInst</a>() ? PtrI.<a class="code" href="classllvm_1_1detail_1_1PtrUseVisitorBase_1_1PtrInfo.html#ad14328f51a170ef45854cc15a4b3564f">getEscapingInst</a>()</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;                                                  : PtrI.<a class="code" href="classllvm_1_1detail_1_1PtrUseVisitorBase_1_1PtrInfo.html#a1312e1c22248e53e2e0c9c374a1352f6">getAbortingInst</a>();</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;    assert(PointerEscapingInstr &amp;&amp; <span class="stringliteral">&quot;Did not track a bad instruction&quot;</span>);</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;  }</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;  Slices.erase(std::remove_if(Slices.begin(), Slices.end(),</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;                              std::mem_fun_ref(&amp;Slice::isDead)),</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;               Slices.end());</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;  <span class="comment">// Sort the uses. This arranges for the offsets to be in ascending order,</span></div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;  <span class="comment">// and the sizes to be in descending order.</span></div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;  std::sort(Slices.begin(), Slices.end());</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;}</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;<span class="preprocessor">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</span></div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;<span class="keywordtype">void</span> AllocaSlices::print(<a class="code" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;OS, const_iterator <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>,</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;                         <a class="code" href="classllvm_1_1StringRef.html">StringRef</a> Indent)<span class="keyword"> const </span>{</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;  printSlice(OS, I, Indent);</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;  printUse(OS, I, Indent);</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;}</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;<span class="keywordtype">void</span> AllocaSlices::printSlice(<a class="code" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;OS, const_iterator I,</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;                              <a class="code" href="classllvm_1_1StringRef.html">StringRef</a> Indent)<span class="keyword"> const </span>{</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;  OS &lt;&lt; Indent &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; I-&gt;beginOffset() &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; I-&gt;endOffset() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span></div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;     &lt;&lt; <span class="stringliteral">&quot; slice #&quot;</span> &lt;&lt; (I - <a class="code" href="namespacellvm_1_1sys_1_1path.html#a33706aab89e700b8f79e1fa6f4f0e3ee">begin</a>())</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;     &lt;&lt; (I-&gt;isSplittable() ? <span class="stringliteral">&quot; (splittable)&quot;</span> : <span class="stringliteral">&quot;&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;}</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;<span class="keywordtype">void</span> AllocaSlices::printUse(<a class="code" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;OS, const_iterator I,</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;                            <a class="code" href="classllvm_1_1StringRef.html">StringRef</a> Indent)<span class="keyword"> const </span>{</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;  OS &lt;&lt; Indent &lt;&lt; <span class="stringliteral">&quot;  used by: &quot;</span> &lt;&lt; *I-&gt;getUse()-&gt;getUser() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;}</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;<span class="keywordtype">void</span> AllocaSlices::print(<a class="code" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;OS)<span class="keyword"> const </span>{</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;  <span class="keywordflow">if</span> (PointerEscapingInstr) {</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;    OS &lt;&lt; <span class="stringliteral">&quot;Can&#39;t analyze slices for alloca: &quot;</span> &lt;&lt; AI &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;       &lt;&lt; <span class="stringliteral">&quot;  A pointer to this alloca escaped by:\n&quot;</span></div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;       &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; *PointerEscapingInstr &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;  }</div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;  OS &lt;&lt; <span class="stringliteral">&quot;Slices of alloca: &quot;</span> &lt;&lt; AI &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;  <span class="keywordflow">for</span> (const_iterator I = <a class="code" href="namespacellvm_1_1sys_1_1path.html#a33706aab89e700b8f79e1fa6f4f0e3ee">begin</a>(), E = <a class="code" href="namespacellvm_1_1sys_1_1path.html#a214ec2f04ffd92636ed4bd2717607a1d">end</a>(); I != E; ++<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;    print(OS, I);</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;}</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacellvm.html#a03503773241005f01b090b9862aad304">AllocaSlices::dump</a>(const_iterator I)<span class="keyword"> const </span>{ print(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>(), I); }</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;<span class="keywordtype">void</span> <a class="code" href="namespacellvm.html#a03503773241005f01b090b9862aad304">AllocaSlices::dump</a>()<span class="keyword"> const </span>{ print(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>()); }</div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;<span class="preprocessor">#endif // !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</span></div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;<span class="keyword">namespace </span>{<span class="comment"></span></div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;<span class="comment">/// \brief Implementation of LoadAndStorePromoter for promoting allocas.</span></div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;<span class="comment">/// This subclass of LoadAndStorePromoter adds overrides to handle promoting</span></div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;<span class="comment">/// the loads and stores of an alloca instruction, as well as updating its</span></div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;<span class="comment">/// debug information. This is used when a domtree is unavailable and thus</span></div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;<span class="comment">/// mem2reg in its full form can&#39;t be used to handle promotion of allocas to</span></div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;<span class="comment">/// scalar values.</span></div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;<span class="comment"></span><span class="keyword">class </span>AllocaPromoter : <span class="keyword">public</span> <a class="code" href="classllvm_1_1LoadAndStorePromoter.html">LoadAndStorePromoter</a> {</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;  <a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> &amp;AI;</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;  <a class="code" href="classllvm_1_1DIBuilder.html">DIBuilder</a> &amp;DIB;</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;DbgDeclareInst *, 4&gt;</a> DDIs;</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;DbgValueInst *, 4&gt;</a> DVIs;</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;  AllocaPromoter(<span class="keyword">const</span> <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;Instruction *&gt;</a> &amp;Insts, <a class="code" href="classllvm_1_1SSAUpdater.html">SSAUpdater</a> &amp;<a class="code" href="Target_2ARM_2README_8txt.html#a1b45f45820a60c09244a87eb59824aec">S</a>,</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;                 <a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> &amp;AI, <a class="code" href="classllvm_1_1DIBuilder.html">DIBuilder</a> &amp;DIB)</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;      : <a class="code" href="classllvm_1_1LoadAndStorePromoter.html">LoadAndStorePromoter</a>(Insts, S), AI(AI), DIB(DIB) {}</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;  <span class="keywordtype">void</span> run(<span class="keyword">const</span> <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;Instruction*&gt;</a> &amp;Insts) {</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;    <span class="comment">// Retain the debug information attached to the alloca for use when</span></div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;    <span class="comment">// rewriting loads and stores.</span></div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *DebugNode = <a class="code" href="classllvm_1_1MDNode.html#a05433bf2c7b926ea34946266b6a222e3">MDNode::getIfExists</a>(AI.<a class="code" href="classllvm_1_1Value.html#af85a4828b6b5a8de7fc0a55cc0e5b52f">getContext</a>(), &amp;AI)) {</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;      <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1value__use__iterator.html">Value::use_iterator</a> UI = DebugNode-&gt;use_begin(),</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;                               UE = DebugNode-&gt;use_end();</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;           UI != UE; ++UI)</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1DbgDeclareInst.html">DbgDeclareInst</a> *DDI = dyn_cast&lt;DbgDeclareInst&gt;(*UI))</div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;          DDIs.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(DDI);</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1DbgValueInst.html">DbgValueInst</a> *DVI = dyn_cast&lt;DbgValueInst&gt;(*UI))</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;          DVIs.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(DVI);</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;    }</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;    <a class="code" href="classllvm_1_1LoadAndStorePromoter.html#a0e97a303d712494969b8800d3b6d712d">LoadAndStorePromoter::run</a>(Insts);</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;    <span class="comment">// While we have the debug information, clear it off of the alloca. The</span></div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;    <span class="comment">// caller takes care of deleting the alloca.</span></div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;    <span class="keywordflow">while</span> (!DDIs.<a class="code" href="classllvm_1_1SmallVectorBase.html#a8a8df4d85555c7954a95f86080cd3b64">empty</a>())</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;      DDIs.<a class="code" href="classllvm_1_1SmallVectorImpl.html#a400eaca9881c8dcab97e9f42b1ab1815">pop_back_val</a>()-&gt;<a class="code" href="classllvm_1_1Instruction.html#a6fe2f06b8a4b2c3d6308afb223a0238a">eraseFromParent</a>();</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;    <span class="keywordflow">while</span> (!DVIs.<a class="code" href="classllvm_1_1SmallVectorBase.html#a8a8df4d85555c7954a95f86080cd3b64">empty</a>())</div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;      DVIs.<a class="code" href="classllvm_1_1SmallVectorImpl.html#a400eaca9881c8dcab97e9f42b1ab1815">pop_back_val</a>()-&gt;<a class="code" href="classllvm_1_1Instruction.html#a6fe2f06b8a4b2c3d6308afb223a0238a">eraseFromParent</a>();</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;  }</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> isInstInList(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *I,</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;                            <span class="keyword">const</span> <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;Instruction*&gt;</a> &amp;Insts)<span class="keyword"> const </span>{</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr;</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *LI = dyn_cast&lt;LoadInst&gt;(I))</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;      Ptr = LI-&gt;getOperand(0);</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;      Ptr = cast&lt;StoreInst&gt;(<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)-&gt;<a class="code" href="Delinearization_8cpp.html#a67193aea0752a127930d6f762e685eef">getPointerOperand</a>();</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;    <span class="comment">// Only used to detect cycles, which will be rare and quickly found as</span></div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;    <span class="comment">// we&#39;re walking up a chain of defs rather than down through uses.</span></div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;    <a class="code" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet&lt;Value *, 4&gt;</a> Visited;</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;    <span class="keywordflow">do</span> {</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;      <span class="keywordflow">if</span> (Ptr == &amp;AI)</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1BitCastInst.html">BitCastInst</a> *BCI = dyn_cast&lt;BitCastInst&gt;(Ptr))</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;        Ptr = BCI-&gt;getOperand(0);</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1GetElementPtrInst.html">GetElementPtrInst</a> *GEPI = dyn_cast&lt;GetElementPtrInst&gt;(Ptr))</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;        Ptr = GEPI-&gt;getPointerOperand();</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;    } <span class="keywordflow">while</span> (Visited.<a class="code" href="classllvm_1_1SmallPtrSet.html#a9b6dd0fc7a648a939e571246045b673e">insert</a>(Ptr));</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;  }</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;  <span class="keyword">virtual</span> <span class="keywordtype">void</span> updateDebugInfo(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *Inst)<span class="keyword"> const </span>{</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;DbgDeclareInst *&gt;::const_iterator</a> I = DDIs.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a8a045d250952c0867382a9840ee18fdf">begin</a>(),</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;           E = DDIs.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a075e34e98605d0e7c289763a104869ac">end</a>(); I != E; ++<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) {</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;      <a class="code" href="classllvm_1_1DbgDeclareInst.html">DbgDeclareInst</a> *DDI = *<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>;</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> *SI = dyn_cast&lt;StoreInst&gt;(Inst))</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;        <a class="code" href="namespacellvm.html#ab3d313ef442aae5b5bebf03c923506d0">ConvertDebugDeclareToDebugValue</a>(DDI, SI, DIB);</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *LI = dyn_cast&lt;LoadInst&gt;(Inst))</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;        <a class="code" href="namespacellvm.html#ab3d313ef442aae5b5bebf03c923506d0">ConvertDebugDeclareToDebugValue</a>(DDI, LI, DIB);</div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;    }</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;DbgValueInst *&gt;::const_iterator</a> I = DVIs.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a8a045d250952c0867382a9840ee18fdf">begin</a>(),</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;           E = DVIs.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a075e34e98605d0e7c289763a104869ac">end</a>(); I != E; ++<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) {</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;      <a class="code" href="classllvm_1_1DbgValueInst.html">DbgValueInst</a> *DVI = *<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>;</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;      <a class="code" href="classllvm_1_1Value.html">Value</a> *Arg = 0;</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> *SI = dyn_cast&lt;StoreInst&gt;(Inst)) {</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;        <span class="comment">// If an argument is zero extended then use argument directly. The ZExt</span></div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;        <span class="comment">// may be zapped by an optimization pass in future.</span></div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1ZExtInst.html">ZExtInst</a> *ZExt = dyn_cast&lt;ZExtInst&gt;(SI-&gt;getOperand(0)))</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;          Arg = <a class="code" href="namespacellvm.html#a3f2f98c2a67c9e79f58aad9150a62e42">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1Argument.html">Argument</a>&gt;(ZExt-&gt;getOperand(0));</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1SExtInst.html">SExtInst</a> *SExt = dyn_cast&lt;SExtInst&gt;(SI-&gt;getOperand(0)))</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;          Arg = <a class="code" href="namespacellvm.html#a3f2f98c2a67c9e79f58aad9150a62e42">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1Argument.html">Argument</a>&gt;(SExt-&gt;getOperand(0));</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;        <span class="keywordflow">if</span> (!Arg)</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;          Arg = SI-&gt;getValueOperand();</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *LI = dyn_cast&lt;LoadInst&gt;(Inst)) {</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;        Arg = LI-&gt;getPointerOperand();</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;      } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;      }</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;      <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *DbgVal =</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;        DIB.<a class="code" href="classllvm_1_1DIBuilder.html#a827de4664f26cd97746786b159fa997f">insertDbgValueIntrinsic</a>(Arg, 0, <a class="code" href="classllvm_1_1DIVariable.html">DIVariable</a>(DVI-&gt;<a class="code" href="classllvm_1_1DbgValueInst.html#adae1fa6a78df1a034751ba599b71ed68">getVariable</a>()),</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;                                     Inst);</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;      DbgVal-&gt;<a class="code" href="classllvm_1_1Instruction.html#a7bd545769621a0a9d2cfb074f86f4295">setDebugLoc</a>(DVI-&gt;<a class="code" href="classllvm_1_1Instruction.html#aab8e16a35183ce39aad394714087bcff">getDebugLoc</a>());</div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;    }</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;  }</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;};</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;} <span class="comment">// end anon namespace</span></div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;<span class="keyword">namespace </span>{<span class="comment"></span></div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;<span class="comment">/// \brief An optimization pass providing Scalar Replacement of Aggregates.</span></div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;<span class="comment">/// This pass takes allocations which can be completely analyzed (that is, they</span></div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;<span class="comment">/// don&#39;t escape) and tries to turn them into scalar SSA values. There are</span></div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;<span class="comment">/// a few steps to this process.</span></div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;<span class="comment">/// 1) It takes allocations of aggregates and analyzes the ways in which they</span></div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;<span class="comment">///    are used to try to split them into smaller allocations, ideally of</span></div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;<span class="comment">///    a single scalar data type. It will split up memcpy and memset accesses</span></div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;<span class="comment">///    as necessary and try to isolate individual scalar accesses.</span></div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;<span class="comment">/// 2) It will transform accesses into forms which are suitable for SSA value</span></div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;<span class="comment">///    promotion. This can be replacing a memset with a scalar store of an</span></div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;<span class="comment">///    integer value, or it can involve speculating operations on a PHI or</span></div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;<span class="comment">///    select to be a PHI or select of the results.</span></div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;<span class="comment">/// 3) Finally, this will try to detect a pattern of accesses which map cleanly</span></div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;<span class="comment">///    onto insert and extract operations on a vector value, and convert them to</span></div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;<span class="comment">///    this form. By doing so, it will enable promotion of vector aggregates to</span></div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;<span class="comment">///    SSA vector values.</span></div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;<span class="comment"></span><span class="keyword">class </span>SROA : <span class="keyword">public</span> <a class="code" href="classllvm_1_1FunctionPass.html">FunctionPass</a> {</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">bool</span> RequiresDomTree;</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;</div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;  <a class="code" href="classllvm_1_1LLVMContext.html">LLVMContext</a> *<a class="code" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>;</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> *DL;</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;  <a class="code" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT;</div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;<span class="comment">  /// \brief Worklist of alloca instructions to simplify.</span></div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;<span class="comment">  /// Each alloca in the function is added to this. Each new alloca formed gets</span></div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;<span class="comment">  /// added to it as well to recursively simplify unless that alloca can be</span></div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;<span class="comment">  /// directly promoted. Finally, each time we rewrite a use of an alloca other</span></div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;<span class="comment">  /// the one being actively rewritten, we add it back onto the list if not</span></div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;<span class="comment">  /// already present to ensure it is re-visited.</span></div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1SetVector.html">SetVector&lt;AllocaInst *, SmallVector&lt;AllocaInst *, 16&gt;</a> &gt; Worklist;</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;<span class="comment">  /// \brief A collection of instructions to delete.</span></div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;<span class="comment">  /// We try to batch deletions to simplify code and make things a bit more</span></div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;<span class="comment">  /// efficient.</span></div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1SetVector.html">SetVector&lt;Instruction *, SmallVector&lt;Instruction *, 8&gt;</a> &gt; DeadInsts;</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;<span class="comment">  /// \brief Post-promotion worklist.</span></div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;<span class="comment">  /// Sometimes we discover an alloca which has a high probability of becoming</span></div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;<span class="comment">  /// viable for SROA after a round of promotion takes place. In those cases,</span></div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;<span class="comment">  /// the alloca is enqueued here for re-processing.</span></div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;<span class="comment">  /// Note that we have to be very careful to clear allocas out of this list in</span></div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;<span class="comment">  /// the event they are deleted.</span></div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1SetVector.html">SetVector&lt;AllocaInst *, SmallVector&lt;AllocaInst *, 16&gt;</a> &gt; PostPromotionWorklist;</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;<span class="comment">  /// \brief A collection of alloca instructions we can directly promote.</span></div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;<span class="comment"></span>  std::vector&lt;AllocaInst *&gt; PromotableAllocas;</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;<span class="comment">  /// \brief A worklist of PHIs to speculate prior to promoting allocas.</span></div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;<span class="comment">  /// All of these PHIs have been checked for the safety of speculation and by</span></div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;<span class="comment">  /// being speculated will allow promoting allocas currently in the promotable</span></div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;<span class="comment">  /// queue.</span></div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1SetVector.html">SetVector&lt;PHINode *, SmallVector&lt;PHINode *, 2&gt;</a> &gt; SpeculatablePHIs;</div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;<span class="comment">  /// \brief A worklist of select instructions to speculate prior to promoting</span></div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;<span class="comment">  /// allocas.</span></div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;<span class="comment">  /// All of these select instructions have been checked for the safety of</span></div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;<span class="comment">  /// speculation and by being speculated will allow promoting allocas</span></div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;<span class="comment">  /// currently in the promotable queue.</span></div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1SetVector.html">SetVector&lt;SelectInst *, SmallVector&lt;SelectInst *, 2&gt;</a> &gt; SpeculatableSelects;</div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;</div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;  SROA(<span class="keywordtype">bool</span> RequiresDomTree = <span class="keyword">true</span>)</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;      : <a class="code" href="classllvm_1_1FunctionPass.html">FunctionPass</a>(<a class="code" href="namespacellvm_1_1CallingConv.html#a4f861731fc6dbfdccc05af5968d98974">ID</a>), RequiresDomTree(RequiresDomTree),</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;        <a class="code" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>(0), DL(0), DT(0) {</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;    <a class="code" href="namespacellvm.html#a288536b492d939bd6b8b67554f29ed21">initializeSROAPass</a>(*<a class="code" href="classllvm_1_1PassRegistry.html#a05a729900b76c89e808c6c3094921b2f">PassRegistry::getPassRegistry</a>());</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;  }</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;  <span class="keywordtype">bool</span> runOnFunction(<a class="code" href="classllvm_1_1Function.html">Function</a> &amp;<a class="code" href="LLParser_8cpp.html#a33ece1ef8074506a15d7f86eb76dbae6">F</a>);</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;  <span class="keywordtype">void</span> getAnalysisUsage(<a class="code" href="classllvm_1_1AnalysisUsage.html">AnalysisUsage</a> &amp;AU) <span class="keyword">const</span>;</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">char</span> *getPassName()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;SROA&quot;</span>; }</div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;  <span class="keyword">static</span> <span class="keywordtype">char</span> <a class="code" href="namespacellvm_1_1CallingConv.html#a4f861731fc6dbfdccc05af5968d98974">ID</a>;</div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;<span class="keyword">private</span>:</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;  <span class="keyword">friend</span> <span class="keyword">class </span>PHIOrSelectSpeculator;</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;  <span class="keyword">friend</span> <span class="keyword">class </span>AllocaSliceRewriter;</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;  <span class="keywordtype">bool</span> rewritePartition(<a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> &amp;AI, AllocaSlices &amp;<a class="code" href="Target_2ARM_2README_8txt.html#a1b45f45820a60c09244a87eb59824aec">S</a>,</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;                        <a class="code" href="classT.html">AllocaSlices::iterator</a> <a class="code" href="Target_2ARM_2README_8txt.html#a90cca76dd78688687e0d697679dbc799">B</a>, <a class="code" href="classT.html">AllocaSlices::iterator</a> E,</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;                        int64_t BeginOffset, int64_t EndOffset,</div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;                        <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;AllocaSlices::iterator&gt;</a> SplitUses);</div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;  <span class="keywordtype">bool</span> splitAlloca(<a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> &amp;AI, AllocaSlices &amp;S);</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;  <span class="keywordtype">bool</span> runOnAlloca(<a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> &amp;AI);</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;  <span class="keywordtype">void</span> deleteDeadInstructions(<a class="code" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet&lt;AllocaInst *, 4&gt;</a> &amp;DeletedAllocas);</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;  <span class="keywordtype">bool</span> promoteAllocas(<a class="code" href="classllvm_1_1Function.html">Function</a> &amp;F);</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;};</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;}</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;<span class="keywordtype">char</span> <a class="code" href="namespacellvm_1_1CallingConv.html#a4f861731fc6dbfdccc05af5968d98974">SROA::ID</a> = 0;</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;</div><div class="line"><a name="l00925"></a><span class="lineno"><a class="line" href="namespacellvm.html#a2f229bc5f942c04056686242fd6e8988">  925</a></span>&#160;<a class="code" href="classllvm_1_1FunctionPass.html">FunctionPass</a> *<a class="code" href="namespacellvm.html#a2f229bc5f942c04056686242fd6e8988">llvm::createSROAPass</a>(<span class="keywordtype">bool</span> RequiresDomTree) {</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">new</span> SROA(RequiresDomTree);</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;}</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;<a class="code" href="SROA_8cpp.html#a0cddfff8553e3f05397def533fb5190e">INITIALIZE_PASS_BEGIN</a>(SROA, <span class="stringliteral">&quot;sroa&quot;</span>, <span class="stringliteral">&quot;Scalar Replacement Of Aggregates&quot;</span>,</div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;                      <span class="keyword">false</span>, <span class="keyword">false</span>)</div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;<a class="code" href="PassSupport_8h.html#a14724f1ccf528e73bb29bc9230737967">INITIALIZE_PASS_DEPENDENCY</a>(<a class="code" href="classllvm_1_1DominatorTree.html">DominatorTree</a>)</div><div class="line"><a name="l00932"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#a6990f15b9f29df6e8497b3e53875ccab">  932</a></span>&#160;<a class="code" href="PassSupport_8h.html#a74ce8276b89067e806f67c45a6d92575">INITIALIZE_PASS_END</a>(SROA, &quot;<a class="code" href="SROA_8cpp.html#a6990f15b9f29df6e8497b3e53875ccab">sroa</a>&quot;, &quot;<a class="code" href="namespacellvm_1_1NVPTX_1_1PTXLdStInstCode.html#a91119cbee2be000c528a690252aee07ca09c68d67f7dbfa6cc77eaf73aa535217">Scalar</a> Replacement Of <a class="code" href="SROA_8cpp.html#a5b3f8e5f6c512fe6a5059dd0c51aec95">Aggregates</a>&quot;,</div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;                    <a class="code" href="namespacefalse.html">false</a>, false)</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;<span class="comment">/// Walk the range of a partitioning looking for a common type to cover this</span></div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;<span class="comment">/// sequence of slices.</span></div><div class="line"><a name="l00937"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#ae4bd66bcc8e0dce3d4d67880b77c6b1b">  937</a></span>&#160;<span class="comment"></span>static <a class="code" href="classllvm_1_1Type.html">Type</a> *<a class="code" href="SROA_8cpp.html#ae4bd66bcc8e0dce3d4d67880b77c6b1b">findCommonType</a>(AllocaSlices::const_iterator <a class="code" href="Target_2ARM_2README_8txt.html#a90cca76dd78688687e0d697679dbc799">B</a>,</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;                            AllocaSlices::const_iterator E,</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;                            uint64_t EndOffset) {</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *Ty = 0;</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;  <span class="keywordtype">bool</span> IgnoreNonIntegralTypes = <span class="keyword">false</span>;</div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;  <span class="keywordflow">for</span> (AllocaSlices::const_iterator I = B; I != E; ++<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) {</div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;    <a class="code" href="classllvm_1_1Use.html">Use</a> *U = I-&gt;getUse();</div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;    <span class="keywordflow">if</span> (isa&lt;IntrinsicInst&gt;(*U-&gt;getUser()))</div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;    <span class="keywordflow">if</span> (I-&gt;beginOffset() != B-&gt;beginOffset() || I-&gt;endOffset() != EndOffset)</div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;    <a class="code" href="classllvm_1_1Type.html">Type</a> *UserTy = 0;</div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *LI = dyn_cast&lt;LoadInst&gt;(U-&gt;getUser())) {</div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;      UserTy = LI-&gt;getType();</div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> *SI = dyn_cast&lt;StoreInst&gt;(U-&gt;getUser())) {</div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;      UserTy = SI-&gt;getValueOperand()-&gt;getType();</div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;      IgnoreNonIntegralTypes = <span class="keyword">true</span>; <span class="comment">// Give up on anything but an iN type.</span></div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;    }</div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1IntegerType.html">IntegerType</a> *ITy = dyn_cast&lt;IntegerType&gt;(UserTy)) {</div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;      <span class="comment">// If the type is larger than the partition, skip it. We only encounter</span></div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;      <span class="comment">// this for split integer operations where we want to use the type of the</span></div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;      <span class="comment">// entity causing the split. Also skip if the type is not a byte width</span></div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;      <span class="comment">// multiple.</span></div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;      <span class="keywordflow">if</span> (ITy-&gt;getBitWidth() % 8 != 0 ||</div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;          ITy-&gt;getBitWidth() / 8 &gt; (EndOffset - B-&gt;beginOffset()))</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;</div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;      <span class="comment">// If we have found an integer type use covering the alloca, use that</span></div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;      <span class="comment">// regardless of the other types, as integers are often used for</span></div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;      <span class="comment">// a &quot;bucket of bits&quot; type.</span></div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;      <span class="comment">//</span></div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;      <span class="comment">// NB: This *must* be the only return from inside the loop so that the</span></div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;      <span class="comment">// order of slices doesn&#39;t impact the computed type.</span></div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;      <span class="keywordflow">return</span> ITy;</div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IgnoreNonIntegralTypes) {</div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;    }</div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;</div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;    <span class="keywordflow">if</span> (Ty &amp;&amp; Ty != UserTy)</div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;      IgnoreNonIntegralTypes = <span class="keyword">true</span>; <span class="comment">// Give up on anything but an iN type.</span></div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;    Ty = UserTy;</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;  }</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;  <span class="keywordflow">return</span> Ty;</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;}</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;<span class="comment">/// PHI instructions that use an alloca and are subsequently loaded can be</span></div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;<span class="comment">/// rewritten to load both input pointers in the pred blocks and then PHI the</span></div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;<span class="comment">/// results, allowing the load of the alloca to be promoted.</span></div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;<span class="comment">/// From this:</span></div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;<span class="comment">///   %P2 = phi [i32* %Alloca, i32* %Other]</span></div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;<span class="comment">///   %V = load i32* %P2</span></div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;<span class="comment">/// to:</span></div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;<span class="comment">///   %V1 = load i32* %Alloca      -&gt; will be mem2reg&#39;d</span></div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;<span class="comment">///   ...</span></div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;<span class="comment">///   %V2 = load i32* %Other</span></div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;<span class="comment">///   ...</span></div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;<span class="comment">///   %V = phi [i32 %V1, i32 %V2]</span></div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;<span class="comment">/// We can do this to a select if its only uses are loads and if the operands</span></div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;<span class="comment">/// to the select can be loaded unconditionally.</span></div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;<span class="comment">/// FIXME: This should be hoisted into a generic utility, likely in</span></div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;<span class="comment">/// Transforms/Util/Local.h</span></div><div class="line"><a name="l01005"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#a40145cc8bb126bba70637669bbb6dad8"> 1005</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="SROA_8cpp.html#a40145cc8bb126bba70637669bbb6dad8">isSafePHIToSpeculate</a>(<a class="code" href="classllvm_1_1PHINode.html">PHINode</a> &amp;PN,</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;                                 <span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> *DL = 0) {</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;  <span class="comment">// For now, we can only do this promotion if the load is in the same block</span></div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;  <span class="comment">// as the PHI, and if there are no stores between the phi and load.</span></div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;  <span class="comment">// TODO: Allow recursive phi users.</span></div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;  <span class="comment">// TODO: Allow stores.</span></div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;  <a class="code" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *<a class="code" href="CodeGen_2README_8txt.html#a09776db24cf586ec9f1e18f3bae14099">BB</a> = PN.<a class="code" href="classllvm_1_1Instruction.html#a9cd49851904f15060edb782ef4dd1b2d">getParent</a>();</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;  <span class="keywordtype">unsigned</span> MaxAlign = 0;</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;  <span class="keywordtype">bool</span> HaveLoad = <span class="keyword">false</span>;</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1value__use__iterator.html">Value::use_iterator</a> UI = PN.<a class="code" href="classllvm_1_1Value.html#a413abcab8dbc3900fc2fde96a5d8fca6">use_begin</a>(), UE = PN.<a class="code" href="classllvm_1_1Value.html#ad86469939d2a8bdd4169be9403b89f5a">use_end</a>(); UI != UE;</div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;       ++UI) {</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;    <a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *LI = <a class="code" href="namespacellvm.html#a3f2f98c2a67c9e79f58aad9150a62e42">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a>&gt;(*UI);</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;    <span class="keywordflow">if</span> (LI == 0 || !LI-&gt;<a class="code" href="classllvm_1_1LoadInst.html#a156c478ee8e7d1602143cdbad4bd5385">isSimple</a>())</div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;</div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;    <span class="comment">// For now we only allow loads in the same block as the PHI.  This is</span></div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;    <span class="comment">// a common case that happens when instcombine merges two loads through</span></div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;    <span class="comment">// a PHI.</span></div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;    <span class="keywordflow">if</span> (LI-&gt;<a class="code" href="classllvm_1_1Instruction.html#a9cd49851904f15060edb782ef4dd1b2d">getParent</a>() != <a class="code" href="CodeGen_2README_8txt.html#a09776db24cf586ec9f1e18f3bae14099">BB</a>)</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;    <span class="comment">// Ensure that there are no instructions between the PHI and the load that</span></div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;    <span class="comment">// could store.</span></div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1ilist__iterator.html">BasicBlock::iterator</a> BBI = &amp;PN; &amp;*BBI != LI; ++BBI)</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;      <span class="keywordflow">if</span> (BBI-&gt;mayWriteToMemory())</div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;</div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;    MaxAlign = std::max(MaxAlign, LI-&gt;<a class="code" href="classllvm_1_1LoadInst.html#ad1168fc42bcba1b71217a4969483671a">getAlignment</a>());</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;    HaveLoad = <span class="keyword">true</span>;</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;  }</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;  <span class="keywordflow">if</span> (!HaveLoad)</div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;  <span class="comment">// We can only transform this if it is safe to push the loads into the</span></div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;  <span class="comment">// predecessor blocks. The only thing to watch out for is that we can&#39;t put</span></div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;  <span class="comment">// a possibly trapping load in the predecessor if it is a critical edge.</span></div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> Idx = 0, Num = PN.<a class="code" href="classllvm_1_1PHINode.html#aa45f6c0433576e3858a6209a43750ad4">getNumIncomingValues</a>(); Idx != Num; ++Idx) {</div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;    <a class="code" href="classllvm_1_1TerminatorInst.html">TerminatorInst</a> *TI = PN.<a class="code" href="classllvm_1_1PHINode.html#a4c25b6c00c4867281779c81ab64d2081">getIncomingBlock</a>(Idx)-&gt;<a class="code" href="classllvm_1_1BasicBlock.html#a5cb76a65b6524dba1493dd2b9dc3abbe">getTerminator</a>();</div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *InVal = PN.<a class="code" href="classllvm_1_1PHINode.html#aba6a4cc4ed6d6fef3664b8d65ef04820">getIncomingValue</a>(Idx);</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;</div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;    <span class="comment">// If the value is produced by the terminator of the predecessor (an</span></div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;    <span class="comment">// invoke) or it has side-effects, there is no valid place to put a load</span></div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;    <span class="comment">// in the predecessor.</span></div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;    <span class="keywordflow">if</span> (TI == InVal || TI-&gt;<a class="code" href="classllvm_1_1Instruction.html#a573063aad4c101462893d0490d867524">mayHaveSideEffects</a>())</div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;</div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;    <span class="comment">// If the predecessor has a single successor, then the edge isn&#39;t</span></div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;    <span class="comment">// critical.</span></div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;    <span class="keywordflow">if</span> (TI-&gt;<a class="code" href="classllvm_1_1TerminatorInst.html#a4c26d3b92af99a6c8defd89a2d39ca32">getNumSuccessors</a>() == 1)</div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;</div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;    <span class="comment">// If this pointer is always safe to load, or if we can prove that there</span></div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;    <span class="comment">// is already a load in the block, then we can move the load to the pred</span></div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;    <span class="comment">// block.</span></div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;    <span class="keywordflow">if</span> (InVal-&gt;<a class="code" href="classllvm_1_1Value.html#ae6a2729f1446acc2ae3e5a05bc2a5a4b">isDereferenceablePointer</a>() ||</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;        <a class="code" href="namespacellvm.html#a2bb15e529c55b5356aabfb006d1e98aa">isSafeToLoadUnconditionally</a>(InVal, TI, MaxAlign, DL))</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;</div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;  }</div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;</div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;}</div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;</div><div class="line"><a name="l01070"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#aab38ec9ebc3b5d96a4b7ddcb11cfcd58"> 1070</a></span>&#160;<span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="SROA_8cpp.html#aab38ec9ebc3b5d96a4b7ddcb11cfcd58">speculatePHINodeLoads</a>(<a class="code" href="classllvm_1_1PHINode.html">PHINode</a> &amp;PN) {</div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;  <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;    original: &quot;</span> &lt;&lt; PN &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;</div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *LoadTy = cast&lt;PointerType&gt;(PN.<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>())-&gt;getElementType();</div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;  IRBuilderTy PHIBuilder(&amp;PN);</div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;  <a class="code" href="classllvm_1_1PHINode.html">PHINode</a> *NewPN = PHIBuilder.CreatePHI(LoadTy, PN.<a class="code" href="classllvm_1_1PHINode.html#aa45f6c0433576e3858a6209a43750ad4">getNumIncomingValues</a>(),</div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;                                        PN.<a class="code" href="classllvm_1_1Value.html#ad452febc1ac0b394876e640ec03ffa38">getName</a>() + <span class="stringliteral">&quot;.sroa.speculated&quot;</span>);</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;  <span class="comment">// Get the TBAA tag and alignment to use from one of the loads.  It doesn&#39;t</span></div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;  <span class="comment">// matter which one we get and if any differ.</span></div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;  <a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *SomeLoad = cast&lt;LoadInst&gt;(*PN.<a class="code" href="classllvm_1_1Value.html#a413abcab8dbc3900fc2fde96a5d8fca6">use_begin</a>());</div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;  <a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *TBAATag = SomeLoad-&gt;<a class="code" href="classllvm_1_1Instruction.html#aafa29112cbe02e4adc9b36752c771991">getMetadata</a>(<a class="code" href="classllvm_1_1LLVMContext.html#a0869c4dfee48696ce863fcd367eba52da66682b7e33233c8e51196bbf274726a2">LLVMContext::MD_tbaa</a>);</div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;  <span class="keywordtype">unsigned</span> <a class="code" href="ARMSubtarget_8cpp.html#a4bd80d4e433d9f72af26b364036900dc">Align</a> = SomeLoad-&gt;<a class="code" href="classllvm_1_1LoadInst.html#ad1168fc42bcba1b71217a4969483671a">getAlignment</a>();</div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;</div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;  <span class="comment">// Rewrite all loads of the PN to use the new PHI.</span></div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;  <span class="keywordflow">while</span> (!PN.<a class="code" href="classllvm_1_1Value.html#ac38c53f76ef532f91f1666c8a87370e9">use_empty</a>()) {</div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;    <a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *LI = cast&lt;LoadInst&gt;(*PN.<a class="code" href="classllvm_1_1Value.html#a413abcab8dbc3900fc2fde96a5d8fca6">use_begin</a>());</div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;    LI-&gt;<a class="code" href="classllvm_1_1Value.html#a3ab5fc45117b450e8bb04e564cb6e5f2">replaceAllUsesWith</a>(NewPN);</div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;    LI-&gt;<a class="code" href="classllvm_1_1Instruction.html#a6fe2f06b8a4b2c3d6308afb223a0238a">eraseFromParent</a>();</div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;  }</div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;</div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;  <span class="comment">// Inject loads into all of the pred blocks.</span></div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> Idx = 0, Num = PN.<a class="code" href="classllvm_1_1PHINode.html#aa45f6c0433576e3858a6209a43750ad4">getNumIncomingValues</a>(); Idx != Num; ++Idx) {</div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;    <a class="code" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *Pred = PN.<a class="code" href="classllvm_1_1PHINode.html#a4c25b6c00c4867281779c81ab64d2081">getIncomingBlock</a>(Idx);</div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;    <a class="code" href="classllvm_1_1TerminatorInst.html">TerminatorInst</a> *TI = Pred-&gt;<a class="code" href="classllvm_1_1BasicBlock.html#a5cb76a65b6524dba1493dd2b9dc3abbe">getTerminator</a>();</div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *InVal = PN.<a class="code" href="classllvm_1_1PHINode.html#aba6a4cc4ed6d6fef3664b8d65ef04820">getIncomingValue</a>(Idx);</div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;    IRBuilderTy PredBuilder(TI);</div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;</div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;    <a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *<a class="code" href="namespacellvm_1_1SPII.html#a11e9b8fca4a074643a6a21f444e51406a5069619ca8fdce305534f3fe85091a0f">Load</a> = PredBuilder.CreateLoad(</div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;        InVal, (PN.<a class="code" href="classllvm_1_1Value.html#ad452febc1ac0b394876e640ec03ffa38">getName</a>() + <span class="stringliteral">&quot;.sroa.speculate.load.&quot;</span> + Pred-&gt;<a class="code" href="classllvm_1_1Value.html#ad452febc1ac0b394876e640ec03ffa38">getName</a>()));</div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;    ++NumLoadsSpeculated;</div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;    Load-&gt;<a class="code" href="classllvm_1_1LoadInst.html#a218ef27c964707a907f12db0f9b002ba">setAlignment</a>(Align);</div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;    <span class="keywordflow">if</span> (TBAATag)</div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;      Load-&gt;<a class="code" href="classllvm_1_1Instruction.html#a9247a212ea89acc9573fa7e7f557eaba">setMetadata</a>(<a class="code" href="classllvm_1_1LLVMContext.html#a0869c4dfee48696ce863fcd367eba52da66682b7e33233c8e51196bbf274726a2">LLVMContext::MD_tbaa</a>, TBAATag);</div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;    NewPN-&gt;<a class="code" href="classllvm_1_1PHINode.html#a089cccb6f231efee72abc76d0f9c695f">addIncoming</a>(Load, Pred);</div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;  }</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;</div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;  <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;          speculated to: &quot;</span> &lt;&lt; *NewPN &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;  PN.<a class="code" href="classllvm_1_1Instruction.html#a6fe2f06b8a4b2c3d6308afb223a0238a">eraseFromParent</a>();</div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;}</div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;<span class="comment">/// Select instructions that use an alloca and are subsequently loaded can be</span></div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;<span class="comment">/// rewritten to load both input pointers and then select between the result,</span></div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;<span class="comment">/// allowing the load of the alloca to be promoted.</span></div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;<span class="comment">/// From this:</span></div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;<span class="comment">///   %P2 = select i1 %cond, i32* %Alloca, i32* %Other</span></div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;<span class="comment">///   %V = load i32* %P2</span></div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;<span class="comment">/// to:</span></div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;<span class="comment">///   %V1 = load i32* %Alloca      -&gt; will be mem2reg&#39;d</span></div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;<span class="comment">///   %V2 = load i32* %Other</span></div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;<span class="comment">///   %V = select i1 %cond, i32 %V1, i32 %V2</span></div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;<span class="comment">/// We can do this to a select if its only uses are loads and if the operand</span></div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;<span class="comment">/// to the select can be loaded unconditionally.</span></div><div class="line"><a name="l01124"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#a908c20a486274e383f5261012a7c36da"> 1124</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="SROA_8cpp.html#a908c20a486274e383f5261012a7c36da">isSafeSelectToSpeculate</a>(<a class="code" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;SI, <span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> *DL = 0) {</div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *TValue = SI.<a class="code" href="classllvm_1_1SelectInst.html#a67bf091383cd61e1225445e78b61d9f9">getTrueValue</a>();</div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *FValue = SI.<a class="code" href="classllvm_1_1SelectInst.html#a29a16f32075ee4f23cd769701463952c">getFalseValue</a>();</div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;  <span class="keywordtype">bool</span> TDerefable = TValue-&gt;<a class="code" href="classllvm_1_1Value.html#ae6a2729f1446acc2ae3e5a05bc2a5a4b">isDereferenceablePointer</a>();</div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;  <span class="keywordtype">bool</span> FDerefable = FValue-&gt;<a class="code" href="classllvm_1_1Value.html#ae6a2729f1446acc2ae3e5a05bc2a5a4b">isDereferenceablePointer</a>();</div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;</div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1value__use__iterator.html">Value::use_iterator</a> UI = SI.<a class="code" href="classllvm_1_1Value.html#a413abcab8dbc3900fc2fde96a5d8fca6">use_begin</a>(), UE = SI.<a class="code" href="classllvm_1_1Value.html#ad86469939d2a8bdd4169be9403b89f5a">use_end</a>(); UI != UE;</div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;       ++UI) {</div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;    <a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *LI = <a class="code" href="namespacellvm.html#a3f2f98c2a67c9e79f58aad9150a62e42">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a>&gt;(*UI);</div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;    <span class="keywordflow">if</span> (LI == 0 || !LI-&gt;<a class="code" href="classllvm_1_1LoadInst.html#a156c478ee8e7d1602143cdbad4bd5385">isSimple</a>())</div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;</div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;    <span class="comment">// Both operands to the select need to be dereferencable, either</span></div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;    <span class="comment">// absolutely (e.g. allocas) or at this point because we can see other</span></div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;    <span class="comment">// accesses to it.</span></div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;    <span class="keywordflow">if</span> (!TDerefable &amp;&amp;</div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;        !<a class="code" href="namespacellvm.html#a2bb15e529c55b5356aabfb006d1e98aa">isSafeToLoadUnconditionally</a>(TValue, LI, LI-&gt;<a class="code" href="classllvm_1_1LoadInst.html#ad1168fc42bcba1b71217a4969483671a">getAlignment</a>(), DL))</div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;    <span class="keywordflow">if</span> (!FDerefable &amp;&amp;</div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;        !<a class="code" href="namespacellvm.html#a2bb15e529c55b5356aabfb006d1e98aa">isSafeToLoadUnconditionally</a>(FValue, LI, LI-&gt;<a class="code" href="classllvm_1_1LoadInst.html#ad1168fc42bcba1b71217a4969483671a">getAlignment</a>(), DL))</div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;  }</div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;</div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;}</div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;</div><div class="line"><a name="l01150"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#a7493b7d3b84612687869f2c3afed924b"> 1150</a></span>&#160;<span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="SROA_8cpp.html#a7493b7d3b84612687869f2c3afed924b">speculateSelectInstLoads</a>(<a class="code" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;SI) {</div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;  <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;    original: &quot;</span> &lt;&lt; SI &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;</div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;  IRBuilderTy IRB(&amp;SI);</div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *TV = SI.<a class="code" href="classllvm_1_1SelectInst.html#a67bf091383cd61e1225445e78b61d9f9">getTrueValue</a>();</div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *FV = SI.<a class="code" href="classllvm_1_1SelectInst.html#a29a16f32075ee4f23cd769701463952c">getFalseValue</a>();</div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;  <span class="comment">// Replace the loads of the select with a select of two loads.</span></div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;  <span class="keywordflow">while</span> (!SI.<a class="code" href="classllvm_1_1Value.html#ac38c53f76ef532f91f1666c8a87370e9">use_empty</a>()) {</div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;    <a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *LI = cast&lt;LoadInst&gt;(*SI.<a class="code" href="classllvm_1_1Value.html#a413abcab8dbc3900fc2fde96a5d8fca6">use_begin</a>());</div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;    assert(LI-&gt;<a class="code" href="classllvm_1_1LoadInst.html#a156c478ee8e7d1602143cdbad4bd5385">isSimple</a>() &amp;&amp; <span class="stringliteral">&quot;We only speculate simple loads&quot;</span>);</div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;</div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;    IRB.SetInsertPoint(LI);</div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;    <a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *TL =</div><div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;        IRB.CreateLoad(TV, LI-&gt;<a class="code" href="classllvm_1_1Value.html#ad452febc1ac0b394876e640ec03ffa38">getName</a>() + <span class="stringliteral">&quot;.sroa.speculate.load.true&quot;</span>);</div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;    <a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *FL =</div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;        IRB.CreateLoad(FV, LI-&gt;<a class="code" href="classllvm_1_1Value.html#ad452febc1ac0b394876e640ec03ffa38">getName</a>() + <span class="stringliteral">&quot;.sroa.speculate.load.false&quot;</span>);</div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;    NumLoadsSpeculated += 2;</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;</div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;    <span class="comment">// Transfer alignment and TBAA info if present.</span></div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;    TL-&gt;<a class="code" href="classllvm_1_1LoadInst.html#a218ef27c964707a907f12db0f9b002ba">setAlignment</a>(LI-&gt;<a class="code" href="classllvm_1_1LoadInst.html#ad1168fc42bcba1b71217a4969483671a">getAlignment</a>());</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;    FL-&gt;<a class="code" href="classllvm_1_1LoadInst.html#a218ef27c964707a907f12db0f9b002ba">setAlignment</a>(LI-&gt;<a class="code" href="classllvm_1_1LoadInst.html#ad1168fc42bcba1b71217a4969483671a">getAlignment</a>());</div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1MDNode.html">MDNode</a> *Tag = LI-&gt;<a class="code" href="classllvm_1_1Instruction.html#aafa29112cbe02e4adc9b36752c771991">getMetadata</a>(<a class="code" href="classllvm_1_1LLVMContext.html#a0869c4dfee48696ce863fcd367eba52da66682b7e33233c8e51196bbf274726a2">LLVMContext::MD_tbaa</a>)) {</div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;      TL-&gt;<a class="code" href="classllvm_1_1Instruction.html#a9247a212ea89acc9573fa7e7f557eaba">setMetadata</a>(<a class="code" href="classllvm_1_1LLVMContext.html#a0869c4dfee48696ce863fcd367eba52da66682b7e33233c8e51196bbf274726a2">LLVMContext::MD_tbaa</a>, Tag);</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;      FL-&gt;<a class="code" href="classllvm_1_1Instruction.html#a9247a212ea89acc9573fa7e7f557eaba">setMetadata</a>(<a class="code" href="classllvm_1_1LLVMContext.html#a0869c4dfee48696ce863fcd367eba52da66682b7e33233c8e51196bbf274726a2">LLVMContext::MD_tbaa</a>, Tag);</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;    }</div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;</div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *V = IRB.CreateSelect(SI.<a class="code" href="classllvm_1_1SelectInst.html#ad285a69e32ddeee367fed93b5f392801">getCondition</a>(), TL, FL,</div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;                                LI-&gt;<a class="code" href="classllvm_1_1Value.html#ad452febc1ac0b394876e640ec03ffa38">getName</a>() + <span class="stringliteral">&quot;.sroa.speculated&quot;</span>);</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;</div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;          speculated to: &quot;</span> &lt;&lt; *V &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;    LI-&gt;<a class="code" href="classllvm_1_1Value.html#a3ab5fc45117b450e8bb04e564cb6e5f2">replaceAllUsesWith</a>(V);</div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;    LI-&gt;<a class="code" href="classllvm_1_1Instruction.html#a6fe2f06b8a4b2c3d6308afb223a0238a">eraseFromParent</a>();</div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;  }</div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;  SI.<a class="code" href="classllvm_1_1Instruction.html#a6fe2f06b8a4b2c3d6308afb223a0238a">eraseFromParent</a>();</div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;}</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;<span class="comment">/// \brief Build a GEP out of a base pointer and indices.</span></div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;<span class="comment">/// This will return the BasePtr if that is valid, or build a new GEP</span></div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;<span class="comment">/// instruction using the IRBuilder if GEP-ing is needed.</span></div><div class="line"><a name="l01190"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#ab168540e52abb7850fa69ad422a55a31"> 1190</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="SROA_8cpp.html#ab168540e52abb7850fa69ad422a55a31">buildGEP</a>(IRBuilderTy &amp;IRB, <a class="code" href="classllvm_1_1Value.html">Value</a> *BasePtr,</div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;                       <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;Value *&gt;</a> &amp;Indices) {</div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;  <span class="keywordflow">if</span> (Indices.<a class="code" href="classllvm_1_1SmallVectorBase.html#a8a8df4d85555c7954a95f86080cd3b64">empty</a>())</div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;    <span class="keywordflow">return</span> BasePtr;</div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;</div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;  <span class="comment">// A single zero index is a no-op, so check for this and avoid building a GEP</span></div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;  <span class="comment">// in that case.</span></div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;  <span class="keywordflow">if</span> (Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a22a311dfe4c28a897de8a9365a4f0a84">size</a>() == 1 &amp;&amp; cast&lt;ConstantInt&gt;(Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#acd9e771a3296c6b24146955754620557">back</a>())-&gt;<a class="code" href="Lint_8cpp.html#a6cd8c36c54045fd5897b54d4c30e0044">isZero</a>())</div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;    <span class="keywordflow">return</span> BasePtr;</div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;</div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;  <span class="keywordflow">return</span> IRB.CreateInBoundsGEP(BasePtr, Indices, <span class="stringliteral">&quot;idx&quot;</span>);</div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;}</div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;<span class="comment">/// \brief Get a natural GEP off of the BasePtr walking through Ty toward</span></div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;<span class="comment">/// TargetTy without changing the offset of the pointer.</span></div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;<span class="comment">/// This routine assumes we&#39;ve already established a properly offset GEP with</span></div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;<span class="comment">/// Indices, and arrived at the Ty type. The goal is to continue to GEP with</span></div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;<span class="comment">/// zero-indices down through type layers until we find one the same as</span></div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;<span class="comment">/// TargetTy. If we can&#39;t find one with the same type, we at least try to use</span></div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;<span class="comment">/// one with the same size. If none of that works, we just produce the GEP as</span></div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;<span class="comment">/// indicated by Indices to have the correct offset.</span></div><div class="line"><a name="l01212"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#a158e8bdebd7e27fc1fd86613b56f8b9b"> 1212</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="SROA_8cpp.html#a158e8bdebd7e27fc1fd86613b56f8b9b">getNaturalGEPWithType</a>(IRBuilderTy &amp;IRB, <span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL,</div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;                                    <a class="code" href="classllvm_1_1Value.html">Value</a> *BasePtr, <a class="code" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="code" href="classllvm_1_1Type.html">Type</a> *TargetTy,</div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;                                    <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;Value *&gt;</a> &amp;Indices) {</div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;  <span class="keywordflow">if</span> (Ty == TargetTy)</div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SROA_8cpp.html#ab168540e52abb7850fa69ad422a55a31">buildGEP</a>(IRB, BasePtr, Indices);</div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;</div><div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;  <span class="comment">// See if we can descend into a struct and locate a field with the correct</span></div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;  <span class="comment">// type.</span></div><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;  <span class="keywordtype">unsigned</span> NumLayers = 0;</div><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *ElementTy = Ty;</div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;  <span class="keywordflow">do</span> {</div><div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;    <span class="keywordflow">if</span> (ElementTy-&gt;<a class="code" href="classllvm_1_1Type.html#a2eba483f5cc876e824aa6c085736086b">isPointerTy</a>())</div><div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;      <span class="keywordflow">break</span>;</div><div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1SequentialType.html">SequentialType</a> *SeqTy = dyn_cast&lt;SequentialType&gt;(ElementTy)) {</div><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;      ElementTy = SeqTy-&gt;getElementType();</div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;      <span class="comment">// Note that we use the default address space as this index is over an</span></div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;      <span class="comment">// array or a vector, not a pointer.</span></div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;      Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(IRB.getInt(<a class="code" href="classllvm_1_1APInt.html">APInt</a>(DL.<a class="code" href="classllvm_1_1DataLayout.html#a9cb015699ac01dfa6ebb3cc4ce5a6a93">getPointerSizeInBits</a>(0), 0)));</div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1StructType.html">StructType</a> *STy = dyn_cast&lt;StructType&gt;(ElementTy)) {</div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;      <span class="keywordflow">if</span> (STy-&gt;element_begin() == STy-&gt;element_end())</div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;        <span class="keywordflow">break</span>; <span class="comment">// Nothing left to descend into.</span></div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;      ElementTy = *STy-&gt;element_begin();</div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;      Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(IRB.getInt32(0));</div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;      <span class="keywordflow">break</span>;</div><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;    }</div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;    ++NumLayers;</div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;  } <span class="keywordflow">while</span> (ElementTy != TargetTy);</div><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;  <span class="keywordflow">if</span> (ElementTy != TargetTy)</div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;    Indices.<a class="code" href="classllvm_1_1SmallVectorImpl.html#a18c110c35e9133222a37b28d30f8a90f">erase</a>(Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a075e34e98605d0e7c289763a104869ac">end</a>() - NumLayers, Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a075e34e98605d0e7c289763a104869ac">end</a>());</div><div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;</div><div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="SROA_8cpp.html#ab168540e52abb7850fa69ad422a55a31">buildGEP</a>(IRB, BasePtr, Indices);</div><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;}</div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;<span class="comment">/// \brief Recursively compute indices for a natural GEP.</span></div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;<span class="comment">/// This is the recursive step for getNaturalGEPWithOffset that walks down the</span></div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;<span class="comment">/// element types adding appropriate indices for the GEP.</span></div><div class="line"><a name="l01250"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#af058653d4cef0ff14f04d7c612b1d1c9"> 1250</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="SROA_8cpp.html#af058653d4cef0ff14f04d7c612b1d1c9">getNaturalGEPRecursively</a>(IRBuilderTy &amp;IRB, <span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL,</div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;                                       <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr, <a class="code" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="code" href="classllvm_1_1APInt.html">APInt</a> &amp;Offset,</div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;                                       <a class="code" href="classllvm_1_1Type.html">Type</a> *TargetTy,</div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;                                       <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;Value *&gt;</a> &amp;Indices) {</div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;  <span class="keywordflow">if</span> (Offset == 0)</div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SROA_8cpp.html#a158e8bdebd7e27fc1fd86613b56f8b9b">getNaturalGEPWithType</a>(IRB, DL, Ptr, Ty, TargetTy, Indices);</div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;</div><div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;  <span class="comment">// We can&#39;t recurse through pointer types.</span></div><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;  <span class="keywordflow">if</span> (Ty-&gt;<a class="code" href="classllvm_1_1Type.html#a2eba483f5cc876e824aa6c085736086b">isPointerTy</a>())</div><div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;</div><div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;  <span class="comment">// We try to analyze GEPs over vectors here, but note that these GEPs are</span></div><div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;  <span class="comment">// extremely poorly defined currently. The long-term goal is to remove GEPing</span></div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;  <span class="comment">// over a vector from the IR completely.</span></div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1VectorType.html">VectorType</a> *VecTy = dyn_cast&lt;VectorType&gt;(Ty)) {</div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;    <span class="keywordtype">unsigned</span> ElementSizeInBits = DL.<a class="code" href="classllvm_1_1DataLayout.html#add914112e0b2935dda06ad5dfd3a31db">getTypeSizeInBits</a>(VecTy-&gt;getScalarType());</div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;    <span class="keywordflow">if</span> (ElementSizeInBits % 8)</div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;      <span class="keywordflow">return</span> 0; <span class="comment">// GEPs over non-multiple of 8 size vector elements are invalid.</span></div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;    <a class="code" href="classllvm_1_1APInt.html">APInt</a> ElementSize(Offset.<a class="code" href="classllvm_1_1APInt.html#ad081689e23a8f5dea78dedd623d6a8f8">getBitWidth</a>(), ElementSizeInBits / 8);</div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;    <a class="code" href="classllvm_1_1APInt.html">APInt</a> NumSkippedElements = Offset.<a class="code" href="classllvm_1_1APInt.html#a482ad0f63ec145fdba2497e2298a5aa1">sdiv</a>(ElementSize);</div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;    <span class="keywordflow">if</span> (NumSkippedElements.ugt(VecTy-&gt;getNumElements()))</div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;      <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;    Offset -= NumSkippedElements * ElementSize;</div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;    Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(IRB.getInt(NumSkippedElements));</div><div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SROA_8cpp.html#af058653d4cef0ff14f04d7c612b1d1c9">getNaturalGEPRecursively</a>(IRB, DL, Ptr, VecTy-&gt;getElementType(),</div><div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;                                    Offset, TargetTy, Indices);</div><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;  }</div><div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;</div><div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1ArrayType.html">ArrayType</a> *ArrTy = dyn_cast&lt;ArrayType&gt;(Ty)) {</div><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;    <a class="code" href="classllvm_1_1Type.html">Type</a> *ElementTy = ArrTy-&gt;getElementType();</div><div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;    <a class="code" href="classllvm_1_1APInt.html">APInt</a> ElementSize(Offset.<a class="code" href="classllvm_1_1APInt.html#ad081689e23a8f5dea78dedd623d6a8f8">getBitWidth</a>(), DL.<a class="code" href="classllvm_1_1DataLayout.html#a1d6fcc02e91ba24510aba42660c90e29">getTypeAllocSize</a>(ElementTy));</div><div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;    <a class="code" href="classllvm_1_1APInt.html">APInt</a> NumSkippedElements = Offset.<a class="code" href="classllvm_1_1APInt.html#a482ad0f63ec145fdba2497e2298a5aa1">sdiv</a>(ElementSize);</div><div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;    <span class="keywordflow">if</span> (NumSkippedElements.ugt(ArrTy-&gt;getNumElements()))</div><div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;      <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;</div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;    Offset -= NumSkippedElements * ElementSize;</div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;    Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(IRB.getInt(NumSkippedElements));</div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SROA_8cpp.html#af058653d4cef0ff14f04d7c612b1d1c9">getNaturalGEPRecursively</a>(IRB, DL, Ptr, ElementTy, Offset, TargetTy,</div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;                                    Indices);</div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;  }</div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;</div><div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;  <a class="code" href="classllvm_1_1StructType.html">StructType</a> *STy = <a class="code" href="namespacellvm.html#a3f2f98c2a67c9e79f58aad9150a62e42">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1StructType.html">StructType</a>&gt;(Ty);</div><div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;  <span class="keywordflow">if</span> (!STy)</div><div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;</div><div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1StructLayout.html">StructLayout</a> *SL = DL.<a class="code" href="classllvm_1_1DataLayout.html#a35c840104f32575e0d91422cf1ef3ce4">getStructLayout</a>(STy);</div><div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;  uint64_t StructOffset = Offset.<a class="code" href="classllvm_1_1APInt.html#a7dc983ebf0eb2d255fa90a67063c72e2">getZExtValue</a>();</div><div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;  <span class="keywordflow">if</span> (StructOffset &gt;= SL-&gt;<a class="code" href="classllvm_1_1StructLayout.html#a582a5b21a8f91d7f713fa9d57c0525de">getSizeInBytes</a>())</div><div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;  <span class="keywordtype">unsigned</span> Index = SL-&gt;<a class="code" href="classllvm_1_1StructLayout.html#a795cfd43d30c44c33b97fe850bc0451f">getElementContainingOffset</a>(StructOffset);</div><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;  Offset -= <a class="code" href="classllvm_1_1APInt.html">APInt</a>(Offset.<a class="code" href="classllvm_1_1APInt.html#ad081689e23a8f5dea78dedd623d6a8f8">getBitWidth</a>(), SL-&gt;<a class="code" href="classllvm_1_1StructLayout.html#ae10c4483372a357a0d3411b3d64be10c">getElementOffset</a>(Index));</div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *ElementTy = STy-&gt;<a class="code" href="classllvm_1_1StructType.html#a2f54639fcb5162f6f51192eb1697d2ad">getElementType</a>(Index);</div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;  <span class="keywordflow">if</span> (Offset.<a class="code" href="classllvm_1_1APInt.html#a0229ff3a1d7432810a86c8efab115c33">uge</a>(DL.<a class="code" href="classllvm_1_1DataLayout.html#a1d6fcc02e91ba24510aba42660c90e29">getTypeAllocSize</a>(ElementTy)))</div><div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;    <span class="keywordflow">return</span> 0; <span class="comment">// The offset points into alignment padding.</span></div><div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;</div><div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;  Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(IRB.getInt32(Index));</div><div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="SROA_8cpp.html#af058653d4cef0ff14f04d7c612b1d1c9">getNaturalGEPRecursively</a>(IRB, DL, Ptr, ElementTy, Offset, TargetTy,</div><div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;                                  Indices);</div><div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;}</div><div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;<span class="comment">/// \brief Get a natural GEP from a base pointer to a particular offset and</span></div><div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;<span class="comment">/// resulting in a particular type.</span></div><div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;<span class="comment">/// The goal is to produce a &quot;natural&quot; looking GEP that works with the existing</span></div><div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;<span class="comment">/// composite types to arrive at the appropriate offset and element type for</span></div><div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;<span class="comment">/// a pointer. TargetTy is the element type the returned GEP should point-to if</span></div><div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;<span class="comment">/// possible. We recurse by decreasing Offset, adding the appropriate index to</span></div><div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;<span class="comment">/// Indices, and setting Ty to the result subtype.</span></div><div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;<span class="comment">/// If no natural GEP can be constructed, this function returns null.</span></div><div class="line"><a name="l01320"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#ae51507ca5dff9cd52cd782421e71b45b"> 1320</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="SROA_8cpp.html#ae51507ca5dff9cd52cd782421e71b45b">getNaturalGEPWithOffset</a>(IRBuilderTy &amp;IRB, <span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL,</div><div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;                                      <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr, <a class="code" href="classllvm_1_1APInt.html">APInt</a> Offset, <a class="code" href="classllvm_1_1Type.html">Type</a> *TargetTy,</div><div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;                                      <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;Value *&gt;</a> &amp;Indices) {</div><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;  <a class="code" href="classllvm_1_1PointerType.html">PointerType</a> *Ty = cast&lt;PointerType&gt;(Ptr-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>());</div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;</div><div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;  <span class="comment">// Don&#39;t consider any GEPs through an i8* as natural unless the TargetTy is</span></div><div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;  <span class="comment">// an i8.</span></div><div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;  <span class="keywordflow">if</span> (Ty == IRB.<a class="code" href="classllvm_1_1Type.html#a7fe9ccd4893f4e2caa826126c09545ea">getInt8PtrTy</a>() &amp;&amp; TargetTy-&gt;<a class="code" href="classllvm_1_1Type.html#a6e328feb83afa5cf1c966d6704e43fc1">isIntegerTy</a>(8))</div><div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;</div><div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *ElementTy = Ty-&gt;<a class="code" href="classllvm_1_1SequentialType.html#a39f2c3a62f293faf11ac28b15bc53359">getElementType</a>();</div><div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;  <span class="keywordflow">if</span> (!ElementTy-&gt;<a class="code" href="classllvm_1_1Type.html#a9dc5111b1a9b1d5c4652d50f74fe850b">isSized</a>())</div><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;    <span class="keywordflow">return</span> 0; <span class="comment">// We can&#39;t GEP through an unsized element.</span></div><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;  <a class="code" href="classllvm_1_1APInt.html">APInt</a> ElementSize(Offset.<a class="code" href="classllvm_1_1APInt.html#ad081689e23a8f5dea78dedd623d6a8f8">getBitWidth</a>(), DL.<a class="code" href="classllvm_1_1DataLayout.html#a1d6fcc02e91ba24510aba42660c90e29">getTypeAllocSize</a>(ElementTy));</div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;  <span class="keywordflow">if</span> (ElementSize == 0)</div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;    <span class="keywordflow">return</span> 0; <span class="comment">// Zero-length arrays can&#39;t help us build a natural GEP.</span></div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;  <a class="code" href="classllvm_1_1APInt.html">APInt</a> NumSkippedElements = Offset.<a class="code" href="classllvm_1_1APInt.html#a482ad0f63ec145fdba2497e2298a5aa1">sdiv</a>(ElementSize);</div><div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;</div><div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;  Offset -= NumSkippedElements * ElementSize;</div><div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;  Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(IRB.getInt(NumSkippedElements));</div><div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="SROA_8cpp.html#af058653d4cef0ff14f04d7c612b1d1c9">getNaturalGEPRecursively</a>(IRB, DL, Ptr, ElementTy, Offset, TargetTy,</div><div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;                                  Indices);</div><div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;}</div><div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;<span class="comment">/// \brief Compute an adjusted pointer from Ptr by Offset bytes where the</span></div><div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;<span class="comment">/// resulting pointer has PointerTy.</span></div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;<span class="comment">/// This tries very hard to compute a &quot;natural&quot; GEP which arrives at the offset</span></div><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;<span class="comment">/// and produces the pointer type desired. Where it cannot, it will try to use</span></div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;<span class="comment">/// the natural GEP to arrive at the offset and bitcast to the type. Where that</span></div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;<span class="comment">/// fails, it will try to use an existing i8* and GEP to the byte offset and</span></div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;<span class="comment">/// bitcast to the type.</span></div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;<span class="comment">/// The strategy for finding the more natural GEPs is to peel off layers of the</span></div><div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;<span class="comment">/// pointer, walking back through bit casts and GEPs, searching for a base</span></div><div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;<span class="comment">/// pointer from which we can compute a natural GEP with the desired</span></div><div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;<span class="comment">/// properties. The algorithm tries to fold as many constant indices into</span></div><div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;<span class="comment">/// a single GEP as possible, thus making each GEP more independent of the</span></div><div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;<span class="comment">/// surrounding code.</span></div><div class="line"><a name="l01359"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#ab706500bd4aee346f53362dd30531f7f"> 1359</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="SROA_8cpp.html#ab706500bd4aee346f53362dd30531f7f">getAdjustedPtr</a>(IRBuilderTy &amp;IRB, <span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL,</div><div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;                             <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr, <a class="code" href="classllvm_1_1APInt.html">APInt</a> Offset, <a class="code" href="classllvm_1_1Type.html">Type</a> *<a class="code" href="namespacellvm.html#a7aa6722f52f5d4d2cb36ae41cd5044d3">PointerTy</a>) {</div><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;  <span class="comment">// Even though we don&#39;t look through PHI nodes, we could be called on an</span></div><div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;  <span class="comment">// instruction in an unreachable block, which may be on a cycle.</span></div><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;  <a class="code" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet&lt;Value *, 4&gt;</a> Visited;</div><div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;  Visited.<a class="code" href="classllvm_1_1SmallPtrSet.html#a9b6dd0fc7a648a939e571246045b673e">insert</a>(Ptr);</div><div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value *, 4&gt;</a> Indices;</div><div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;</div><div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;  <span class="comment">// We may end up computing an offset pointer that has the wrong type. If we</span></div><div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;  <span class="comment">// never are able to compute one directly that has the correct type, we&#39;ll</span></div><div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;  <span class="comment">// fall back to it, so keep it around here.</span></div><div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *OffsetPtr = 0;</div><div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;</div><div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;  <span class="comment">// Remember any i8 pointer we come across to re-use if we need to do a raw</span></div><div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;  <span class="comment">// byte offset.</span></div><div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *Int8Ptr = 0;</div><div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;  <a class="code" href="classllvm_1_1APInt.html">APInt</a> Int8PtrOffset(Offset.<a class="code" href="classllvm_1_1APInt.html#ad081689e23a8f5dea78dedd623d6a8f8">getBitWidth</a>(), 0);</div><div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;</div><div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *TargetTy = PointerTy-&gt;<a class="code" href="classllvm_1_1Type.html#a5c09d927a0079ad16e8367271efe9bc2">getPointerElementType</a>();</div><div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;</div><div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;  <span class="keywordflow">do</span> {</div><div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;    <span class="comment">// First fold any existing GEPs into the offset.</span></div><div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;    <span class="keywordflow">while</span> (<a class="code" href="classllvm_1_1GEPOperator.html">GEPOperator</a> *GEP = dyn_cast&lt;GEPOperator&gt;(Ptr)) {</div><div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;      <a class="code" href="classllvm_1_1APInt.html">APInt</a> GEPOffset(Offset.<a class="code" href="classllvm_1_1APInt.html#ad081689e23a8f5dea78dedd623d6a8f8">getBitWidth</a>(), 0);</div><div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;      <span class="keywordflow">if</span> (!GEP-&gt;accumulateConstantOffset(DL, GEPOffset))</div><div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;        <span class="keywordflow">break</span>;</div><div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;      Offset += GEPOffset;</div><div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;      Ptr = GEP-&gt;getPointerOperand();</div><div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;      <span class="keywordflow">if</span> (!Visited.<a class="code" href="classllvm_1_1SmallPtrSet.html#a9b6dd0fc7a648a939e571246045b673e">insert</a>(Ptr))</div><div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;        <span class="keywordflow">break</span>;</div><div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;    }</div><div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;</div><div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;    <span class="comment">// See if we can perform a natural GEP here.</span></div><div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;    Indices.<a class="code" href="classllvm_1_1SmallVectorImpl.html#aac0ea55010b7b1a301e65a0baea057aa">clear</a>();</div><div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a> = <a class="code" href="SROA_8cpp.html#ae51507ca5dff9cd52cd782421e71b45b">getNaturalGEPWithOffset</a>(IRB, DL, Ptr, Offset, TargetTy,</div><div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;                                           Indices)) {</div><div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>-&gt;getType() == <a class="code" href="namespacellvm.html#a7aa6722f52f5d4d2cb36ae41cd5044d3">PointerTy</a>) {</div><div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;        <span class="comment">// Zap any offset pointer that we ended up computing in previous rounds.</span></div><div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;        <span class="keywordflow">if</span> (OffsetPtr &amp;&amp; OffsetPtr-&gt;<a class="code" href="classllvm_1_1Value.html#ac38c53f76ef532f91f1666c8a87370e9">use_empty</a>())</div><div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;          <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> = dyn_cast&lt;Instruction&gt;(OffsetPtr))</div><div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;            <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>-&gt;eraseFromParent();</div><div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>;</div><div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;      }</div><div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;      <span class="keywordflow">if</span> (!OffsetPtr) {</div><div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;        OffsetPtr = <a class="code" href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a>;</div><div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;      }</div><div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;    }</div><div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;</div><div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;    <span class="comment">// Stash this pointer if we&#39;ve found an i8*.</span></div><div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;    <span class="keywordflow">if</span> (Ptr-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a6e328feb83afa5cf1c966d6704e43fc1">isIntegerTy</a>(8)) {</div><div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;      Int8Ptr = Ptr;</div><div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;      Int8PtrOffset = Offset;</div><div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;    }</div><div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;</div><div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;    <span class="comment">// Peel off a layer of the pointer and update the offset appropriately.</span></div><div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1Operator.html#a2f14b03fb8025d2bfa20a34da2b20ccf">Operator::getOpcode</a>(Ptr) == Instruction::BitCast) {</div><div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;      Ptr = cast&lt;Operator&gt;(Ptr)-&gt;getOperand(0);</div><div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1GlobalAlias.html">GlobalAlias</a> *GA = dyn_cast&lt;GlobalAlias&gt;(Ptr)) {</div><div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;      <span class="keywordflow">if</span> (GA-&gt;mayBeOverridden())</div><div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;        <span class="keywordflow">break</span>;</div><div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;      Ptr = GA-&gt;getAliasee();</div><div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;      <span class="keywordflow">break</span>;</div><div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;    }</div><div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;    assert(Ptr-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a2eba483f5cc876e824aa6c085736086b">isPointerTy</a>() &amp;&amp; <span class="stringliteral">&quot;Unexpected operand type!&quot;</span>);</div><div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;  } <span class="keywordflow">while</span> (Visited.<a class="code" href="classllvm_1_1SmallPtrSet.html#a9b6dd0fc7a648a939e571246045b673e">insert</a>(Ptr));</div><div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;</div><div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;  <span class="keywordflow">if</span> (!OffsetPtr) {</div><div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;    <span class="keywordflow">if</span> (!Int8Ptr) {</div><div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;      Int8Ptr = IRB.CreateBitCast(Ptr, IRB.getInt8PtrTy(),</div><div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;                                  <span class="stringliteral">&quot;raw_cast&quot;</span>);</div><div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;      Int8PtrOffset = Offset;</div><div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;    }</div><div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;</div><div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;    OffsetPtr = Int8PtrOffset == 0 ? Int8Ptr :</div><div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;      IRB.CreateInBoundsGEP(Int8Ptr, IRB.getInt(Int8PtrOffset),</div><div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;                            <span class="stringliteral">&quot;raw_idx&quot;</span>);</div><div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;  }</div><div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;  Ptr = OffsetPtr;</div><div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;</div><div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;  <span class="comment">// On the off chance we were targeting i8*, guard the bitcast here.</span></div><div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;  <span class="keywordflow">if</span> (Ptr-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>() != <a class="code" href="namespacellvm.html#a7aa6722f52f5d4d2cb36ae41cd5044d3">PointerTy</a>)</div><div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;    Ptr = IRB.CreateBitCast(Ptr, PointerTy, <span class="stringliteral">&quot;cast&quot;</span>);</div><div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;</div><div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;  <span class="keywordflow">return</span> Ptr;</div><div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;}</div><div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;<span class="comment">/// \brief Test whether we can convert a value from the old to the new type.</span></div><div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;<span class="comment">/// This predicate should be used to guard calls to convertValue in order to</span></div><div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;<span class="comment">/// ensure that we only try to convert viable values. The strategy is that we</span></div><div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;<span class="comment">/// will peel off single element struct and array wrappings to get to an</span></div><div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;<span class="comment">/// underlying value, and convert that value.</span></div><div class="line"><a name="l01452"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#a2fb1c078833c17e4c9529b0cf924385c"> 1452</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="SROA_8cpp.html#a2fb1c078833c17e4c9529b0cf924385c">canConvertValue</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="code" href="classllvm_1_1Type.html">Type</a> *OldTy, <a class="code" href="classllvm_1_1Type.html">Type</a> *NewTy) {</div><div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;  <span class="keywordflow">if</span> (OldTy == NewTy)</div><div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1IntegerType.html">IntegerType</a> *OldITy = dyn_cast&lt;IntegerType&gt;(OldTy))</div><div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1IntegerType.html">IntegerType</a> *NewITy = dyn_cast&lt;IntegerType&gt;(NewTy))</div><div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;      <span class="keywordflow">if</span> (NewITy-&gt;getBitWidth() &gt;= OldITy-&gt;getBitWidth())</div><div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;  <span class="keywordflow">if</span> (DL.<a class="code" href="classllvm_1_1DataLayout.html#add914112e0b2935dda06ad5dfd3a31db">getTypeSizeInBits</a>(NewTy) != DL.<a class="code" href="classllvm_1_1DataLayout.html#add914112e0b2935dda06ad5dfd3a31db">getTypeSizeInBits</a>(OldTy))</div><div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;  <span class="keywordflow">if</span> (!NewTy-&gt;<a class="code" href="classllvm_1_1Type.html#a36e21267fe14e69d3251eab1cd3a0076">isSingleValueType</a>() || !OldTy-&gt;<a class="code" href="classllvm_1_1Type.html#a36e21267fe14e69d3251eab1cd3a0076">isSingleValueType</a>())</div><div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;</div><div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;  <span class="comment">// We can convert pointers to integers and vice-versa. Same for vectors</span></div><div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;  <span class="comment">// of pointers and integers.</span></div><div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;  OldTy = OldTy-&gt;<a class="code" href="classllvm_1_1Type.html#a8eafa71cf399da8f21b2af5549f3f9e7">getScalarType</a>();</div><div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;  NewTy = NewTy-&gt;<a class="code" href="classllvm_1_1Type.html#a8eafa71cf399da8f21b2af5549f3f9e7">getScalarType</a>();</div><div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;  <span class="keywordflow">if</span> (NewTy-&gt;<a class="code" href="classllvm_1_1Type.html#a2eba483f5cc876e824aa6c085736086b">isPointerTy</a>() || OldTy-&gt;<a class="code" href="classllvm_1_1Type.html#a2eba483f5cc876e824aa6c085736086b">isPointerTy</a>()) {</div><div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;    <span class="keywordflow">if</span> (NewTy-&gt;<a class="code" href="classllvm_1_1Type.html#a2eba483f5cc876e824aa6c085736086b">isPointerTy</a>() &amp;&amp; OldTy-&gt;<a class="code" href="classllvm_1_1Type.html#a2eba483f5cc876e824aa6c085736086b">isPointerTy</a>())</div><div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;    <span class="keywordflow">if</span> (NewTy-&gt;<a class="code" href="classllvm_1_1Type.html#a6e328feb83afa5cf1c966d6704e43fc1">isIntegerTy</a>() || OldTy-&gt;<a class="code" href="classllvm_1_1Type.html#a6e328feb83afa5cf1c966d6704e43fc1">isIntegerTy</a>())</div><div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;  }</div><div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;</div><div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;}</div><div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;<span class="comment">/// \brief Generic routine to convert an SSA value to a value of a different</span></div><div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;<span class="comment">/// type.</span></div><div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;<span class="comment">/// This will try various different casting techniques, such as bitcasts,</span></div><div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;<span class="comment">/// inttoptr, and ptrtoint casts. Use the \c canConvertValue predicate to test</span></div><div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;<span class="comment">/// two types for viability with this routine.</span></div><div class="line"><a name="l01485"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#a7d6146d9a22768498097b2c53cd2234f"> 1485</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="SROA_8cpp.html#a7d6146d9a22768498097b2c53cd2234f">convertValue</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, IRBuilderTy &amp;IRB, <a class="code" href="classllvm_1_1Value.html">Value</a> *V,</div><div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;                           <a class="code" href="classllvm_1_1Type.html">Type</a> *NewTy) {</div><div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *OldTy = V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>();</div><div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;  assert(<a class="code" href="SROA_8cpp.html#a2fb1c078833c17e4c9529b0cf924385c">canConvertValue</a>(DL, OldTy, NewTy) &amp;&amp; <span class="stringliteral">&quot;Value not convertable to type&quot;</span>);</div><div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;</div><div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;  <span class="keywordflow">if</span> (OldTy == NewTy)</div><div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;    <span class="keywordflow">return</span> V;</div><div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;</div><div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1IntegerType.html">IntegerType</a> *OldITy = dyn_cast&lt;IntegerType&gt;(OldTy))</div><div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1IntegerType.html">IntegerType</a> *NewITy = dyn_cast&lt;IntegerType&gt;(NewTy))</div><div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;      <span class="keywordflow">if</span> (NewITy-&gt;getBitWidth() &gt; OldITy-&gt;getBitWidth())</div><div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;        <span class="keywordflow">return</span> IRB.CreateZExt(V, NewITy);</div><div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;</div><div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;  <span class="comment">// See if we need inttoptr for this type pair. A cast involving both scalars</span></div><div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;  <span class="comment">// and vectors requires and additional bitcast.</span></div><div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;  <span class="keywordflow">if</span> (OldTy-&gt;<a class="code" href="classllvm_1_1Type.html#a8eafa71cf399da8f21b2af5549f3f9e7">getScalarType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a6e328feb83afa5cf1c966d6704e43fc1">isIntegerTy</a>() &amp;&amp;</div><div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;      NewTy-&gt;<a class="code" href="classllvm_1_1Type.html#a8eafa71cf399da8f21b2af5549f3f9e7">getScalarType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a2eba483f5cc876e824aa6c085736086b">isPointerTy</a>()) {</div><div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;    <span class="comment">// Expand &lt;2 x i32&gt; to i8* --&gt; &lt;2 x i32&gt; to i64 to i8*</span></div><div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;    <span class="keywordflow">if</span> (OldTy-&gt;<a class="code" href="classllvm_1_1Type.html#a6f725580f7834e2ca90762965866dad4">isVectorTy</a>() &amp;&amp; !NewTy-&gt;<a class="code" href="classllvm_1_1Type.html#a6f725580f7834e2ca90762965866dad4">isVectorTy</a>())</div><div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;      <span class="keywordflow">return</span> IRB.CreateIntToPtr(IRB.CreateBitCast(V, DL.<a class="code" href="classllvm_1_1DataLayout.html#ae84bb2408dfffa4e8b5fe2ce0714a3bd">getIntPtrType</a>(NewTy)),</div><div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;                                NewTy);</div><div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;</div><div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;    <span class="comment">// Expand i128 to &lt;2 x i8*&gt; --&gt; i128 to &lt;2 x i64&gt; to &lt;2 x i8*&gt;</span></div><div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;    <span class="keywordflow">if</span> (!OldTy-&gt;<a class="code" href="classllvm_1_1Type.html#a6f725580f7834e2ca90762965866dad4">isVectorTy</a>() &amp;&amp; NewTy-&gt;<a class="code" href="classllvm_1_1Type.html#a6f725580f7834e2ca90762965866dad4">isVectorTy</a>())</div><div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;      <span class="keywordflow">return</span> IRB.CreateIntToPtr(IRB.CreateBitCast(V, DL.<a class="code" href="classllvm_1_1DataLayout.html#ae84bb2408dfffa4e8b5fe2ce0714a3bd">getIntPtrType</a>(NewTy)),</div><div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;                                NewTy);</div><div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;</div><div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;    <span class="keywordflow">return</span> IRB.CreateIntToPtr(V, NewTy);</div><div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;  }</div><div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;</div><div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;  <span class="comment">// See if we need ptrtoint for this type pair. A cast involving both scalars</span></div><div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;  <span class="comment">// and vectors requires and additional bitcast.</span></div><div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;  <span class="keywordflow">if</span> (OldTy-&gt;<a class="code" href="classllvm_1_1Type.html#a8eafa71cf399da8f21b2af5549f3f9e7">getScalarType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a2eba483f5cc876e824aa6c085736086b">isPointerTy</a>() &amp;&amp;</div><div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;      NewTy-&gt;<a class="code" href="classllvm_1_1Type.html#a8eafa71cf399da8f21b2af5549f3f9e7">getScalarType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a6e328feb83afa5cf1c966d6704e43fc1">isIntegerTy</a>()) {</div><div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;    <span class="comment">// Expand &lt;2 x i8*&gt; to i128 --&gt; &lt;2 x i8*&gt; to &lt;2 x i64&gt; to i128</span></div><div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;    <span class="keywordflow">if</span> (OldTy-&gt;<a class="code" href="classllvm_1_1Type.html#a6f725580f7834e2ca90762965866dad4">isVectorTy</a>() &amp;&amp; !NewTy-&gt;<a class="code" href="classllvm_1_1Type.html#a6f725580f7834e2ca90762965866dad4">isVectorTy</a>())</div><div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;      <span class="keywordflow">return</span> IRB.CreateBitCast(IRB.CreatePtrToInt(V, DL.<a class="code" href="classllvm_1_1DataLayout.html#ae84bb2408dfffa4e8b5fe2ce0714a3bd">getIntPtrType</a>(OldTy)),</div><div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;                               NewTy);</div><div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;</div><div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;    <span class="comment">// Expand i8* to &lt;2 x i32&gt; --&gt; i8* to i64 to &lt;2 x i32&gt;</span></div><div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;    <span class="keywordflow">if</span> (!OldTy-&gt;<a class="code" href="classllvm_1_1Type.html#a6f725580f7834e2ca90762965866dad4">isVectorTy</a>() &amp;&amp; NewTy-&gt;<a class="code" href="classllvm_1_1Type.html#a6f725580f7834e2ca90762965866dad4">isVectorTy</a>())</div><div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;      <span class="keywordflow">return</span> IRB.CreateBitCast(IRB.CreatePtrToInt(V, DL.<a class="code" href="classllvm_1_1DataLayout.html#ae84bb2408dfffa4e8b5fe2ce0714a3bd">getIntPtrType</a>(OldTy)),</div><div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;                               NewTy);</div><div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;</div><div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;    <span class="keywordflow">return</span> IRB.CreatePtrToInt(V, NewTy);</div><div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;  }</div><div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;</div><div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;  <span class="keywordflow">return</span> IRB.CreateBitCast(V, NewTy);</div><div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;}</div><div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;<span class="comment">/// \brief Test whether the given slice use can be promoted to a vector.</span></div><div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;<span class="comment">/// This function is called to test each entry in a partioning which is slated</span></div><div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;<span class="comment">/// for a single slice.</span></div><div class="line"><a name="l01539"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#afe50201d4e405f7bb74806c62e850140"> 1539</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="SROA_8cpp.html#afe50201d4e405f7bb74806c62e850140">isVectorPromotionViableForSlice</a>(</div><div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, AllocaSlices &amp;<a class="code" href="Target_2ARM_2README_8txt.html#a1b45f45820a60c09244a87eb59824aec">S</a>, uint64_t SliceBeginOffset,</div><div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;    uint64_t SliceEndOffset, <a class="code" href="classllvm_1_1VectorType.html">VectorType</a> *Ty, uint64_t ElementSize,</div><div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;    AllocaSlices::const_iterator <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) {</div><div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;  <span class="comment">// First validate the slice offsets.</span></div><div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;  uint64_t BeginOffset =</div><div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;      std::max(I-&gt;beginOffset(), SliceBeginOffset) - SliceBeginOffset;</div><div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;  uint64_t BeginIndex = BeginOffset / ElementSize;</div><div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;  <span class="keywordflow">if</span> (BeginIndex * ElementSize != BeginOffset ||</div><div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;      BeginIndex &gt;= Ty-&gt;<a class="code" href="classllvm_1_1VectorType.html#a580510fa692dccfb26d0e967d8f164e7">getNumElements</a>())</div><div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;  uint64_t EndOffset =</div><div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;      std::min(I-&gt;endOffset(), SliceEndOffset) - SliceBeginOffset;</div><div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;  uint64_t EndIndex = EndOffset / ElementSize;</div><div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;  <span class="keywordflow">if</span> (EndIndex * ElementSize != EndOffset || EndIndex &gt; Ty-&gt;<a class="code" href="classllvm_1_1VectorType.html#a580510fa692dccfb26d0e967d8f164e7">getNumElements</a>())</div><div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;</div><div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160;  assert(EndIndex &gt; BeginIndex &amp;&amp; <span class="stringliteral">&quot;Empty vector!&quot;</span>);</div><div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;  uint64_t NumElements = EndIndex - BeginIndex;</div><div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *SliceTy =</div><div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;      (NumElements == 1) ? Ty-&gt;<a class="code" href="classllvm_1_1SequentialType.html#a39f2c3a62f293faf11ac28b15bc53359">getElementType</a>()</div><div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;                         : <a class="code" href="classllvm_1_1VectorType.html#ab43657ed1abe2e2ed3a6a394f233ebd0">VectorType::get</a>(Ty-&gt;<a class="code" href="classllvm_1_1SequentialType.html#a39f2c3a62f293faf11ac28b15bc53359">getElementType</a>(), NumElements);</div><div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;</div><div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *SplitIntTy =</div><div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;      <a class="code" href="classllvm_1_1Type.html#acaf8e4c3e40e01e848c1fad5f05b81cd">Type::getIntNTy</a>(Ty-&gt;<a class="code" href="classllvm_1_1Type.html#af348d5ea83429d08ba891ca3dd0e92b2">getContext</a>(), NumElements * ElementSize * 8);</div><div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;</div><div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;  <a class="code" href="classllvm_1_1Use.html">Use</a> *U = I-&gt;getUse();</div><div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;</div><div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1MemIntrinsic.html">MemIntrinsic</a> *<a class="code" href="namespacellvm_1_1A64CC.html#af5804bc0518be9568f73db566e4d6f46a2db5e7546f960277ff98f96cd5624442">MI</a> = dyn_cast&lt;MemIntrinsic&gt;(U-&gt;getUser())) {</div><div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacellvm_1_1A64CC.html#af5804bc0518be9568f73db566e4d6f46a2db5e7546f960277ff98f96cd5624442">MI</a>-&gt;isVolatile())</div><div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;    <span class="keywordflow">if</span> (!I-&gt;isSplittable())</div><div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// Skip any unsplittable intrinsics.</span></div><div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (U-&gt;get()-&gt;getType()-&gt;getPointerElementType()-&gt;isStructTy()) {</div><div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;    <span class="comment">// Disable vector promotion when there are loads or stores of an FCA.</span></div><div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *LI = dyn_cast&lt;LoadInst&gt;(U-&gt;getUser())) {</div><div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;    <span class="keywordflow">if</span> (LI-&gt;isVolatile())</div><div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;    <a class="code" href="classllvm_1_1Type.html">Type</a> *LTy = LI-&gt;getType();</div><div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;    <span class="keywordflow">if</span> (SliceBeginOffset &gt; I-&gt;beginOffset() ||</div><div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;        SliceEndOffset &lt; I-&gt;endOffset()) {</div><div class="line"><a name="l01581"></a><span class="lineno"> 1581</span>&#160;      assert(LTy-&gt;<a class="code" href="classllvm_1_1Type.html#a6e328feb83afa5cf1c966d6704e43fc1">isIntegerTy</a>());</div><div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;      LTy = SplitIntTy;</div><div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;    }</div><div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="SROA_8cpp.html#a2fb1c078833c17e4c9529b0cf924385c">canConvertValue</a>(DL, SliceTy, LTy))</div><div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> *SI = dyn_cast&lt;StoreInst&gt;(U-&gt;getUser())) {</div><div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;    <span class="keywordflow">if</span> (SI-&gt;isVolatile())</div><div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;    <a class="code" href="classllvm_1_1Type.html">Type</a> *STy = SI-&gt;getValueOperand()-&gt;getType();</div><div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;    <span class="keywordflow">if</span> (SliceBeginOffset &gt; I-&gt;beginOffset() ||</div><div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;        SliceEndOffset &lt; I-&gt;endOffset()) {</div><div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;      assert(STy-&gt;<a class="code" href="classllvm_1_1Type.html#a6e328feb83afa5cf1c966d6704e43fc1">isIntegerTy</a>());</div><div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;      STy = SplitIntTy;</div><div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;    }</div><div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="SROA_8cpp.html#a2fb1c078833c17e4c9529b0cf924385c">canConvertValue</a>(DL, STy, SliceTy))</div><div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;  } <span class="keywordflow">else</span> {</div><div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;  }</div><div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;</div><div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;}</div><div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;<span class="comment">/// \brief Test whether the given alloca partitioning and range of slices can be</span></div><div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;<span class="comment">/// promoted to a vector.</span></div><div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160;<span class="comment">/// This is a quick test to check whether we can rewrite a particular alloca</span></div><div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;<span class="comment">/// partition (and its newly formed alloca) into a vector alloca with only</span></div><div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160;<span class="comment">/// whole-vector loads and stores such that it could be promoted to a vector</span></div><div class="line"><a name="l01610"></a><span class="lineno"> 1610</span>&#160;<span class="comment">/// SSA value. We only can ensure this for a limited set of operations, and we</span></div><div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;<span class="comment">/// don&#39;t want to do the rewrites unless we are confident that the result will</span></div><div class="line"><a name="l01612"></a><span class="lineno"> 1612</span>&#160;<span class="comment">/// be promotable, so we have an early test here.</span></div><div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">bool</span></div><div class="line"><a name="l01614"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#a581dd5bca5410ba43e8cf06d949fa7f2"> 1614</a></span>&#160;<a class="code" href="SROA_8cpp.html#a581dd5bca5410ba43e8cf06d949fa7f2">isVectorPromotionViable</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="code" href="classllvm_1_1Type.html">Type</a> *AllocaTy, AllocaSlices &amp;<a class="code" href="Target_2ARM_2README_8txt.html#a1b45f45820a60c09244a87eb59824aec">S</a>,</div><div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;                        uint64_t SliceBeginOffset, uint64_t SliceEndOffset,</div><div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;                        AllocaSlices::const_iterator <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>,</div><div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;                        AllocaSlices::const_iterator E,</div><div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;                        <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;AllocaSlices::iterator&gt;</a> SplitUses) {</div><div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;  <a class="code" href="classllvm_1_1VectorType.html">VectorType</a> *Ty = <a class="code" href="namespacellvm.html#a3f2f98c2a67c9e79f58aad9150a62e42">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1VectorType.html">VectorType</a>&gt;(AllocaTy);</div><div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;  <span class="keywordflow">if</span> (!Ty)</div><div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;</div><div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;  uint64_t ElementSize = DL.<a class="code" href="classllvm_1_1DataLayout.html#add914112e0b2935dda06ad5dfd3a31db">getTypeSizeInBits</a>(Ty-&gt;<a class="code" href="classllvm_1_1Type.html#a8eafa71cf399da8f21b2af5549f3f9e7">getScalarType</a>());</div><div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;</div><div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;  <span class="comment">// While the definition of LLVM vectors is bitpacked, we don&#39;t support sizes</span></div><div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;  <span class="comment">// that aren&#39;t byte sized.</span></div><div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;  <span class="keywordflow">if</span> (ElementSize % 8)</div><div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;  assert((DL.<a class="code" href="classllvm_1_1DataLayout.html#add914112e0b2935dda06ad5dfd3a31db">getTypeSizeInBits</a>(Ty) % 8) == 0 &amp;&amp;</div><div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;         <span class="stringliteral">&quot;vector size not a multiple of element size?&quot;</span>);</div><div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160;  ElementSize /= 8;</div><div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;</div><div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160;  <span class="keywordflow">for</span> (; I != E; ++<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</div><div class="line"><a name="l01634"></a><span class="lineno"> 1634</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="SROA_8cpp.html#afe50201d4e405f7bb74806c62e850140">isVectorPromotionViableForSlice</a>(DL, S, SliceBeginOffset,</div><div class="line"><a name="l01635"></a><span class="lineno"> 1635</span>&#160;                                         SliceEndOffset, Ty, ElementSize, I))</div><div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;</div><div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1SUnit.html">ArrayRef&lt;AllocaSlices::iterator&gt;::const_iterator</a> SUI = SplitUses.<a class="code" href="classllvm_1_1ArrayRef.html#a836367b39ed630bf14db99923c22740e">begin</a>(),</div><div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;                                                        SUE = SplitUses.<a class="code" href="classllvm_1_1ArrayRef.html#a38ed8cc3c342ad6910e8c869d3e2b9cf">end</a>();</div><div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;       SUI != SUE; ++SUI)</div><div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="SROA_8cpp.html#afe50201d4e405f7bb74806c62e850140">isVectorPromotionViableForSlice</a>(DL, S, SliceBeginOffset,</div><div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;                                         SliceEndOffset, Ty, ElementSize, *SUI))</div><div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;</div><div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;}</div><div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01648"></a><span class="lineno"> 1648</span>&#160;<span class="comment">/// \brief Test whether a slice of an alloca is valid for integer widening.</span></div><div class="line"><a name="l01649"></a><span class="lineno"> 1649</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01650"></a><span class="lineno"> 1650</span>&#160;<span class="comment">/// This implements the necessary checking for the \c isIntegerWideningViable</span></div><div class="line"><a name="l01651"></a><span class="lineno"> 1651</span>&#160;<span class="comment">/// test below on a single slice of the alloca.</span></div><div class="line"><a name="l01652"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#a65e014ae237cfe6ed7bc2e25f91ecbe0"> 1652</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="SROA_8cpp.html#a65e014ae237cfe6ed7bc2e25f91ecbe0">isIntegerWideningViableForSlice</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL,</div><div class="line"><a name="l01653"></a><span class="lineno"> 1653</span>&#160;                                            <a class="code" href="classllvm_1_1Type.html">Type</a> *AllocaTy,</div><div class="line"><a name="l01654"></a><span class="lineno"> 1654</span>&#160;                                            uint64_t AllocBeginOffset,</div><div class="line"><a name="l01655"></a><span class="lineno"> 1655</span>&#160;                                            uint64_t Size, AllocaSlices &amp;<a class="code" href="Target_2ARM_2README_8txt.html#a1b45f45820a60c09244a87eb59824aec">S</a>,</div><div class="line"><a name="l01656"></a><span class="lineno"> 1656</span>&#160;                                            AllocaSlices::const_iterator <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>,</div><div class="line"><a name="l01657"></a><span class="lineno"> 1657</span>&#160;                                            <span class="keywordtype">bool</span> &amp;WholeAllocaOp) {</div><div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;  uint64_t RelBegin = I-&gt;beginOffset() - AllocBeginOffset;</div><div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160;  uint64_t RelEnd = I-&gt;endOffset() - AllocBeginOffset;</div><div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;</div><div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;  <span class="comment">// We can&#39;t reasonably handle cases where the load or store extends past</span></div><div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;  <span class="comment">// the end of the aloca&#39;s type and into its padding.</span></div><div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;  <span class="keywordflow">if</span> (RelEnd &gt; Size)</div><div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;</div><div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;  <a class="code" href="classllvm_1_1Use.html">Use</a> *U = I-&gt;getUse();</div><div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;</div><div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *LI = dyn_cast&lt;LoadInst&gt;(U-&gt;getUser())) {</div><div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;    <span class="keywordflow">if</span> (LI-&gt;isVolatile())</div><div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;    <span class="keywordflow">if</span> (RelBegin == 0 &amp;&amp; RelEnd == Size)</div><div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;      WholeAllocaOp = <span class="keyword">true</span>;</div><div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1IntegerType.html">IntegerType</a> *ITy = dyn_cast&lt;IntegerType&gt;(LI-&gt;getType())) {</div><div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;      <span class="keywordflow">if</span> (ITy-&gt;getBitWidth() &lt; DL.<a class="code" href="classllvm_1_1DataLayout.html#a328b37dd0e404674678018ac2f2e38af">getTypeStoreSizeInBits</a>(ITy))</div><div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (RelBegin != 0 || RelEnd != Size ||</div><div class="line"><a name="l01677"></a><span class="lineno"> 1677</span>&#160;               !<a class="code" href="SROA_8cpp.html#a2fb1c078833c17e4c9529b0cf924385c">canConvertValue</a>(DL, AllocaTy, LI-&gt;getType())) {</div><div class="line"><a name="l01678"></a><span class="lineno"> 1678</span>&#160;      <span class="comment">// Non-integer loads need to be convertible from the alloca type so that</span></div><div class="line"><a name="l01679"></a><span class="lineno"> 1679</span>&#160;      <span class="comment">// they are promotable.</span></div><div class="line"><a name="l01680"></a><span class="lineno"> 1680</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01681"></a><span class="lineno"> 1681</span>&#160;    }</div><div class="line"><a name="l01682"></a><span class="lineno"> 1682</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> *SI = dyn_cast&lt;StoreInst&gt;(U-&gt;getUser())) {</div><div class="line"><a name="l01683"></a><span class="lineno"> 1683</span>&#160;    <a class="code" href="classllvm_1_1Type.html">Type</a> *ValueTy = SI-&gt;getValueOperand()-&gt;getType();</div><div class="line"><a name="l01684"></a><span class="lineno"> 1684</span>&#160;    <span class="keywordflow">if</span> (SI-&gt;isVolatile())</div><div class="line"><a name="l01685"></a><span class="lineno"> 1685</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160;    <span class="keywordflow">if</span> (RelBegin == 0 &amp;&amp; RelEnd == Size)</div><div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;      WholeAllocaOp = <span class="keyword">true</span>;</div><div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1IntegerType.html">IntegerType</a> *ITy = dyn_cast&lt;IntegerType&gt;(ValueTy)) {</div><div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;      <span class="keywordflow">if</span> (ITy-&gt;getBitWidth() &lt; DL.<a class="code" href="classllvm_1_1DataLayout.html#a328b37dd0e404674678018ac2f2e38af">getTypeStoreSizeInBits</a>(ITy))</div><div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (RelBegin != 0 || RelEnd != Size ||</div><div class="line"><a name="l01692"></a><span class="lineno"> 1692</span>&#160;               !<a class="code" href="SROA_8cpp.html#a2fb1c078833c17e4c9529b0cf924385c">canConvertValue</a>(DL, ValueTy, AllocaTy)) {</div><div class="line"><a name="l01693"></a><span class="lineno"> 1693</span>&#160;      <span class="comment">// Non-integer stores need to be convertible to the alloca type so that</span></div><div class="line"><a name="l01694"></a><span class="lineno"> 1694</span>&#160;      <span class="comment">// they are promotable.</span></div><div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160;    }</div><div class="line"><a name="l01697"></a><span class="lineno"> 1697</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1MemIntrinsic.html">MemIntrinsic</a> *<a class="code" href="namespacellvm_1_1A64CC.html#af5804bc0518be9568f73db566e4d6f46a2db5e7546f960277ff98f96cd5624442">MI</a> = dyn_cast&lt;MemIntrinsic&gt;(U-&gt;getUser())) {</div><div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacellvm_1_1A64CC.html#af5804bc0518be9568f73db566e4d6f46a2db5e7546f960277ff98f96cd5624442">MI</a>-&gt;isVolatile() || !isa&lt;Constant&gt;(<a class="code" href="namespacellvm_1_1A64CC.html#af5804bc0518be9568f73db566e4d6f46a2db5e7546f960277ff98f96cd5624442">MI</a>-&gt;getLength()))</div><div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160;    <span class="keywordflow">if</span> (!I-&gt;isSplittable())</div><div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// Skip any unsplittable intrinsics.</span></div><div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *II = dyn_cast&lt;IntrinsicInst&gt;(U-&gt;getUser())) {</div><div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;    <span class="keywordflow">if</span> (II-&gt;getIntrinsicID() != <a class="code" href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90ae365354e47542c51f9bd46e329e3323e">Intrinsic::lifetime_start</a> &amp;&amp;</div><div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;        II-&gt;getIntrinsicID() != <a class="code" href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90aa332b90dd5e4ebf4bbbcc0964220d373">Intrinsic::lifetime_end</a>)</div><div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;  } <span class="keywordflow">else</span> {</div><div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;  }</div><div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;</div><div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;}</div><div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;<span class="comment">/// \brief Test whether the given alloca partition&#39;s integer operations can be</span></div><div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;<span class="comment">/// widened to promotable ones.</span></div><div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;<span class="comment">/// This is a quick test to check whether we can rewrite the integer loads and</span></div><div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;<span class="comment">/// stores to a particular alloca into wider loads and stores and be able to</span></div><div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;<span class="comment">/// promote the resulting alloca.</span></div><div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">bool</span></div><div class="line"><a name="l01720"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#a75f170d10487be0c2a7862177b2c18e7"> 1720</a></span>&#160;<a class="code" href="SROA_8cpp.html#a75f170d10487be0c2a7862177b2c18e7">isIntegerWideningViable</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="code" href="classllvm_1_1Type.html">Type</a> *AllocaTy,</div><div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;                        uint64_t AllocBeginOffset, AllocaSlices &amp;<a class="code" href="Target_2ARM_2README_8txt.html#a1b45f45820a60c09244a87eb59824aec">S</a>,</div><div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;                        AllocaSlices::const_iterator <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>,</div><div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;                        AllocaSlices::const_iterator E,</div><div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;                        <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;AllocaSlices::iterator&gt;</a> SplitUses) {</div><div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;  uint64_t SizeInBits = DL.<a class="code" href="classllvm_1_1DataLayout.html#add914112e0b2935dda06ad5dfd3a31db">getTypeSizeInBits</a>(AllocaTy);</div><div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;  <span class="comment">// Don&#39;t create integer types larger than the maximum bitwidth.</span></div><div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;  <span class="keywordflow">if</span> (SizeInBits &gt; <a class="code" href="classllvm_1_1IntegerType.html#ab24bc943998d904e8406af9fa07ca645a1ccefdf8a7414a6829f888e5071e0379">IntegerType::MAX_INT_BITS</a>)</div><div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;</div><div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;  <span class="comment">// Don&#39;t try to handle allocas with bit-padding.</span></div><div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160;  <span class="keywordflow">if</span> (SizeInBits != DL.<a class="code" href="classllvm_1_1DataLayout.html#a328b37dd0e404674678018ac2f2e38af">getTypeStoreSizeInBits</a>(AllocaTy))</div><div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;</div><div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;  <span class="comment">// We need to ensure that an integer type with the appropriate bitwidth can</span></div><div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160;  <span class="comment">// be converted to the alloca type, whatever that is. We don&#39;t want to force</span></div><div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;  <span class="comment">// the alloca itself to have an integer type if there is a more suitable one.</span></div><div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *IntTy = <a class="code" href="classllvm_1_1Type.html#acaf8e4c3e40e01e848c1fad5f05b81cd">Type::getIntNTy</a>(AllocaTy-&gt;<a class="code" href="classllvm_1_1Type.html#af348d5ea83429d08ba891ca3dd0e92b2">getContext</a>(), SizeInBits);</div><div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="SROA_8cpp.html#a2fb1c078833c17e4c9529b0cf924385c">canConvertValue</a>(DL, AllocaTy, IntTy) ||</div><div class="line"><a name="l01739"></a><span class="lineno"> 1739</span>&#160;      !<a class="code" href="SROA_8cpp.html#a2fb1c078833c17e4c9529b0cf924385c">canConvertValue</a>(DL, IntTy, AllocaTy))</div><div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;</div><div class="line"><a name="l01742"></a><span class="lineno"> 1742</span>&#160;  uint64_t Size = DL.<a class="code" href="classllvm_1_1DataLayout.html#a4b979cd93852fd44c48851c94ee00758">getTypeStoreSize</a>(AllocaTy);</div><div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;</div><div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;  <span class="comment">// While examining uses, we ensure that the alloca has a covering load or</span></div><div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;  <span class="comment">// store. We don&#39;t want to widen the integer operations only to fail to</span></div><div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;  <span class="comment">// promote due to some other unsplittable entry (which we may make splittable</span></div><div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;  <span class="comment">// later). However, if there are only splittable uses, go ahead and assume</span></div><div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;  <span class="comment">// that we cover the alloca.</span></div><div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;  <span class="keywordtype">bool</span> WholeAllocaOp = (I != E) ? <span class="keyword">false</span> : DL.<a class="code" href="classllvm_1_1DataLayout.html#a96f1e9abd65fef355bd8f15f9360c871">isLegalInteger</a>(SizeInBits);</div><div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160;</div><div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;  <span class="keywordflow">for</span> (; I != E; ++<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</div><div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="SROA_8cpp.html#a65e014ae237cfe6ed7bc2e25f91ecbe0">isIntegerWideningViableForSlice</a>(DL, AllocaTy, AllocBeginOffset, Size,</div><div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;                                         S, I, WholeAllocaOp))</div><div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;</div><div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1SUnit.html">ArrayRef&lt;AllocaSlices::iterator&gt;::const_iterator</a> SUI = SplitUses.<a class="code" href="classllvm_1_1ArrayRef.html#a836367b39ed630bf14db99923c22740e">begin</a>(),</div><div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;                                                        SUE = SplitUses.<a class="code" href="classllvm_1_1ArrayRef.html#a38ed8cc3c342ad6910e8c869d3e2b9cf">end</a>();</div><div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;       SUI != SUE; ++SUI)</div><div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="SROA_8cpp.html#a65e014ae237cfe6ed7bc2e25f91ecbe0">isIntegerWideningViableForSlice</a>(DL, AllocaTy, AllocBeginOffset, Size,</div><div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;                                         S, *SUI, WholeAllocaOp))</div><div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;</div><div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;  <span class="keywordflow">return</span> WholeAllocaOp;</div><div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;}</div><div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;</div><div class="line"><a name="l01766"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#a94e7aca18fb08798727209385f164f7c"> 1766</a></span>&#160;<span class="keyword">static</span> <a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="SROA_8cpp.html#a94e7aca18fb08798727209385f164f7c">extractInteger</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, IRBuilderTy &amp;IRB, <a class="code" href="classllvm_1_1Value.html">Value</a> *V,</div><div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;                             <a class="code" href="classllvm_1_1IntegerType.html">IntegerType</a> *Ty, uint64_t Offset,</div><div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;                             <span class="keyword">const</span> <a class="code" href="classllvm_1_1Twine.html">Twine</a> &amp;<a class="code" href="namespacellvm_1_1GraphProgram.html#a0ad4685976f8c4d4a697a53fbe05d10b">Name</a>) {</div><div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;  <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;       start: &quot;</span> &lt;&lt; *V &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;  <a class="code" href="classllvm_1_1IntegerType.html">IntegerType</a> *IntTy = cast&lt;IntegerType&gt;(V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>());</div><div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;  assert(DL.<a class="code" href="classllvm_1_1DataLayout.html#a4b979cd93852fd44c48851c94ee00758">getTypeStoreSize</a>(Ty) + Offset &lt;= DL.<a class="code" href="classllvm_1_1DataLayout.html#a4b979cd93852fd44c48851c94ee00758">getTypeStoreSize</a>(IntTy) &amp;&amp;</div><div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;         <span class="stringliteral">&quot;Element extends past full value&quot;</span>);</div><div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;  uint64_t ShAmt = 8*Offset;</div><div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;  <span class="keywordflow">if</span> (DL.<a class="code" href="classllvm_1_1DataLayout.html#a9b876cc57d1884621f481b26b0892633">isBigEndian</a>())</div><div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;    ShAmt = 8*(DL.<a class="code" href="classllvm_1_1DataLayout.html#a4b979cd93852fd44c48851c94ee00758">getTypeStoreSize</a>(IntTy) - DL.<a class="code" href="classllvm_1_1DataLayout.html#a4b979cd93852fd44c48851c94ee00758">getTypeStoreSize</a>(Ty) - Offset);</div><div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;  <span class="keywordflow">if</span> (ShAmt) {</div><div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;    V = IRB.CreateLShr(V, ShAmt, Name + <span class="stringliteral">&quot;.shift&quot;</span>);</div><div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;     shifted: &quot;</span> &lt;&lt; *V &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;  }</div><div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;  assert(Ty-&gt;<a class="code" href="classllvm_1_1IntegerType.html#a6f603ab84f6f7c79985036f58cca9d48">getBitWidth</a>() &lt;= IntTy-&gt;<a class="code" href="classllvm_1_1IntegerType.html#a6f603ab84f6f7c79985036f58cca9d48">getBitWidth</a>() &amp;&amp;</div><div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;         <span class="stringliteral">&quot;Cannot extract to a larger integer!&quot;</span>);</div><div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;  <span class="keywordflow">if</span> (Ty != IntTy) {</div><div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;    V = IRB.CreateTrunc(V, Ty, Name + <span class="stringliteral">&quot;.trunc&quot;</span>);</div><div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;     trunced: &quot;</span> &lt;&lt; *V &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160;  }</div><div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;  <span class="keywordflow">return</span> V;</div><div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;}</div><div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;</div><div class="line"><a name="l01789"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#a7febebe786555d6e0d07ca0f86e294c1"> 1789</a></span>&#160;<span class="keyword">static</span> <a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="SROA_8cpp.html#a7febebe786555d6e0d07ca0f86e294c1">insertInteger</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, IRBuilderTy &amp;IRB, <a class="code" href="classllvm_1_1Value.html">Value</a> *Old,</div><div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;                            <a class="code" href="classllvm_1_1Value.html">Value</a> *V, uint64_t Offset, <span class="keyword">const</span> <a class="code" href="classllvm_1_1Twine.html">Twine</a> &amp;<a class="code" href="namespacellvm_1_1GraphProgram.html#a0ad4685976f8c4d4a697a53fbe05d10b">Name</a>) {</div><div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;  <a class="code" href="classllvm_1_1IntegerType.html">IntegerType</a> *IntTy = cast&lt;IntegerType&gt;(Old-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>());</div><div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;  <a class="code" href="classllvm_1_1IntegerType.html">IntegerType</a> *Ty = cast&lt;IntegerType&gt;(V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>());</div><div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;  assert(Ty-&gt;getBitWidth() &lt;= IntTy-&gt;<a class="code" href="classllvm_1_1IntegerType.html#a6f603ab84f6f7c79985036f58cca9d48">getBitWidth</a>() &amp;&amp;</div><div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;         <span class="stringliteral">&quot;Cannot insert a larger integer!&quot;</span>);</div><div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;  <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;       start: &quot;</span> &lt;&lt; *V &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;  <span class="keywordflow">if</span> (Ty != IntTy) {</div><div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;    V = IRB.CreateZExt(V, IntTy, Name + <span class="stringliteral">&quot;.ext&quot;</span>);</div><div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;    extended: &quot;</span> &lt;&lt; *V &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;  }</div><div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;  assert(DL.<a class="code" href="classllvm_1_1DataLayout.html#a4b979cd93852fd44c48851c94ee00758">getTypeStoreSize</a>(Ty) + Offset &lt;= DL.<a class="code" href="classllvm_1_1DataLayout.html#a4b979cd93852fd44c48851c94ee00758">getTypeStoreSize</a>(IntTy) &amp;&amp;</div><div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160;         <span class="stringliteral">&quot;Element store outside of alloca store&quot;</span>);</div><div class="line"><a name="l01802"></a><span class="lineno"> 1802</span>&#160;  uint64_t ShAmt = 8*Offset;</div><div class="line"><a name="l01803"></a><span class="lineno"> 1803</span>&#160;  <span class="keywordflow">if</span> (DL.<a class="code" href="classllvm_1_1DataLayout.html#a9b876cc57d1884621f481b26b0892633">isBigEndian</a>())</div><div class="line"><a name="l01804"></a><span class="lineno"> 1804</span>&#160;    ShAmt = 8*(DL.<a class="code" href="classllvm_1_1DataLayout.html#a4b979cd93852fd44c48851c94ee00758">getTypeStoreSize</a>(IntTy) - DL.<a class="code" href="classllvm_1_1DataLayout.html#a4b979cd93852fd44c48851c94ee00758">getTypeStoreSize</a>(Ty) - Offset);</div><div class="line"><a name="l01805"></a><span class="lineno"> 1805</span>&#160;  <span class="keywordflow">if</span> (ShAmt) {</div><div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;    V = IRB.CreateShl(V, ShAmt, Name + <span class="stringliteral">&quot;.shift&quot;</span>);</div><div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;     shifted: &quot;</span> &lt;&lt; *V &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;  }</div><div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;</div><div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;  <span class="keywordflow">if</span> (ShAmt || Ty-&gt;getBitWidth() &lt; IntTy-&gt;<a class="code" href="classllvm_1_1IntegerType.html#a6f603ab84f6f7c79985036f58cca9d48">getBitWidth</a>()) {</div><div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;    <a class="code" href="classllvm_1_1APInt.html">APInt</a> Mask = ~Ty-&gt;getMask().<a class="code" href="classllvm_1_1APInt.html#a6142fc5662411269a7ca0217f49f338c">zext</a>(IntTy-&gt;<a class="code" href="classllvm_1_1IntegerType.html#a6f603ab84f6f7c79985036f58cca9d48">getBitWidth</a>()).<a class="code" href="namespacellvm_1_1APIntOps.html#a57f47540fddb72feab9e8afd08f21611">shl</a>(ShAmt);</div><div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;    Old = IRB.CreateAnd(Old, Mask, Name + <span class="stringliteral">&quot;.mask&quot;</span>);</div><div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;      masked: &quot;</span> &lt;&lt; *Old &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;    V = IRB.CreateOr(Old, V, Name + <span class="stringliteral">&quot;.insert&quot;</span>);</div><div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;    inserted: &quot;</span> &lt;&lt; *V &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;  }</div><div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;  <span class="keywordflow">return</span> V;</div><div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;}</div><div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;</div><div class="line"><a name="l01820"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#a06a9071efa992145e210f0b41a52e501"> 1820</a></span>&#160;<span class="keyword">static</span> <a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="SROA_8cpp.html#a06a9071efa992145e210f0b41a52e501">extractVector</a>(IRBuilderTy &amp;IRB, <a class="code" href="classllvm_1_1Value.html">Value</a> *V,</div><div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;                            <span class="keywordtype">unsigned</span> BeginIndex, <span class="keywordtype">unsigned</span> EndIndex,</div><div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;                            <span class="keyword">const</span> <a class="code" href="classllvm_1_1Twine.html">Twine</a> &amp;<a class="code" href="namespacellvm_1_1GraphProgram.html#a0ad4685976f8c4d4a697a53fbe05d10b">Name</a>) {</div><div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;  <a class="code" href="classllvm_1_1VectorType.html">VectorType</a> *VecTy = cast&lt;VectorType&gt;(V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>());</div><div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;  <span class="keywordtype">unsigned</span> NumElements = EndIndex - BeginIndex;</div><div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;  assert(NumElements &lt;= VecTy-&gt;getNumElements() &amp;&amp; <span class="stringliteral">&quot;Too many elements!&quot;</span>);</div><div class="line"><a name="l01826"></a><span class="lineno"> 1826</span>&#160;</div><div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160;  <span class="keywordflow">if</span> (NumElements == VecTy-&gt;<a class="code" href="classllvm_1_1VectorType.html#a580510fa692dccfb26d0e967d8f164e7">getNumElements</a>())</div><div class="line"><a name="l01828"></a><span class="lineno"> 1828</span>&#160;    <span class="keywordflow">return</span> V;</div><div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160;</div><div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;  <span class="keywordflow">if</span> (NumElements == 1) {</div><div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;    V = IRB.CreateExtractElement(V, IRB.getInt32(BeginIndex),</div><div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;                                 Name + <span class="stringliteral">&quot;.extract&quot;</span>);</div><div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;     extract: &quot;</span> &lt;&lt; *V &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160;    <span class="keywordflow">return</span> V;</div><div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;  }</div><div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;</div><div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Constant*, 8&gt;</a> Mask;</div><div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;  Mask.<a class="code" href="classllvm_1_1SmallVectorImpl.html#a4786e64977a3af38f29adee46b70a863">reserve</a>(NumElements);</div><div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a> = BeginIndex; <a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a> != EndIndex; ++<a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div><div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;    Mask.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(IRB.getInt32(<a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a>));</div><div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;  V = IRB.CreateShuffleVector(V, <a class="code" href="classllvm_1_1UndefValue.html#a4ae5ff22b700a42bcc5d889233721335">UndefValue::get</a>(V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()),</div><div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;                              <a class="code" href="classllvm_1_1ConstantVector.html#ade9fa017ca3aa82f7694a47090547bc1">ConstantVector::get</a>(Mask),</div><div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;                              Name + <span class="stringliteral">&quot;.extract&quot;</span>);</div><div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;  <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;     shuffle: &quot;</span> &lt;&lt; *V &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;  <span class="keywordflow">return</span> V;</div><div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;}</div><div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;</div><div class="line"><a name="l01848"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#a42c6a2faff923f431932c6d33cf4092b"> 1848</a></span>&#160;<span class="keyword">static</span> <a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="SROA_8cpp.html#a42c6a2faff923f431932c6d33cf4092b">insertVector</a>(IRBuilderTy &amp;IRB, <a class="code" href="classllvm_1_1Value.html">Value</a> *Old, <a class="code" href="classllvm_1_1Value.html">Value</a> *V,</div><div class="line"><a name="l01849"></a><span class="lineno"> 1849</span>&#160;                           <span class="keywordtype">unsigned</span> BeginIndex, <span class="keyword">const</span> <a class="code" href="classllvm_1_1Twine.html">Twine</a> &amp;<a class="code" href="namespacellvm_1_1GraphProgram.html#a0ad4685976f8c4d4a697a53fbe05d10b">Name</a>) {</div><div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160;  <a class="code" href="classllvm_1_1VectorType.html">VectorType</a> *VecTy = cast&lt;VectorType&gt;(Old-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>());</div><div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160;  assert(VecTy &amp;&amp; <span class="stringliteral">&quot;Can only insert a vector into a vector&quot;</span>);</div><div class="line"><a name="l01852"></a><span class="lineno"> 1852</span>&#160;</div><div class="line"><a name="l01853"></a><span class="lineno"> 1853</span>&#160;  <a class="code" href="classllvm_1_1VectorType.html">VectorType</a> *Ty = <a class="code" href="namespacellvm.html#a3f2f98c2a67c9e79f58aad9150a62e42">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1VectorType.html">VectorType</a>&gt;(V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>());</div><div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;  <span class="keywordflow">if</span> (!Ty) {</div><div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;    <span class="comment">// Single element to insert.</span></div><div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;    V = IRB.CreateInsertElement(Old, V, IRB.getInt32(BeginIndex),</div><div class="line"><a name="l01857"></a><span class="lineno"> 1857</span>&#160;                                Name + <span class="stringliteral">&quot;.insert&quot;</span>);</div><div class="line"><a name="l01858"></a><span class="lineno"> 1858</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt;  <span class="stringliteral">&quot;     insert: &quot;</span> &lt;&lt; *V &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01859"></a><span class="lineno"> 1859</span>&#160;    <span class="keywordflow">return</span> V;</div><div class="line"><a name="l01860"></a><span class="lineno"> 1860</span>&#160;  }</div><div class="line"><a name="l01861"></a><span class="lineno"> 1861</span>&#160;</div><div class="line"><a name="l01862"></a><span class="lineno"> 1862</span>&#160;  assert(Ty-&gt;<a class="code" href="classllvm_1_1VectorType.html#a580510fa692dccfb26d0e967d8f164e7">getNumElements</a>() &lt;= VecTy-&gt;<a class="code" href="classllvm_1_1VectorType.html#a580510fa692dccfb26d0e967d8f164e7">getNumElements</a>() &amp;&amp;</div><div class="line"><a name="l01863"></a><span class="lineno"> 1863</span>&#160;         <span class="stringliteral">&quot;Too many elements!&quot;</span>);</div><div class="line"><a name="l01864"></a><span class="lineno"> 1864</span>&#160;  <span class="keywordflow">if</span> (Ty-&gt;<a class="code" href="classllvm_1_1VectorType.html#a580510fa692dccfb26d0e967d8f164e7">getNumElements</a>() == VecTy-&gt;<a class="code" href="classllvm_1_1VectorType.html#a580510fa692dccfb26d0e967d8f164e7">getNumElements</a>()) {</div><div class="line"><a name="l01865"></a><span class="lineno"> 1865</span>&#160;    assert(V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>() == VecTy &amp;&amp; <span class="stringliteral">&quot;Vector type mismatch&quot;</span>);</div><div class="line"><a name="l01866"></a><span class="lineno"> 1866</span>&#160;    <span class="keywordflow">return</span> V;</div><div class="line"><a name="l01867"></a><span class="lineno"> 1867</span>&#160;  }</div><div class="line"><a name="l01868"></a><span class="lineno"> 1868</span>&#160;  <span class="keywordtype">unsigned</span> EndIndex = BeginIndex + Ty-&gt;<a class="code" href="classllvm_1_1VectorType.html#a580510fa692dccfb26d0e967d8f164e7">getNumElements</a>();</div><div class="line"><a name="l01869"></a><span class="lineno"> 1869</span>&#160;</div><div class="line"><a name="l01870"></a><span class="lineno"> 1870</span>&#160;  <span class="comment">// When inserting a smaller vector into the larger to store, we first</span></div><div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160;  <span class="comment">// use a shuffle vector to widen it with undef elements, and then</span></div><div class="line"><a name="l01872"></a><span class="lineno"> 1872</span>&#160;  <span class="comment">// a second shuffle vector to select between the loaded vector and the</span></div><div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160;  <span class="comment">// incoming vector.</span></div><div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Constant*, 8&gt;</a> Mask;</div><div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;  Mask.<a class="code" href="classllvm_1_1SmallVectorImpl.html#a4786e64977a3af38f29adee46b70a863">reserve</a>(VecTy-&gt;<a class="code" href="classllvm_1_1VectorType.html#a580510fa692dccfb26d0e967d8f164e7">getNumElements</a>());</div><div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a> = 0; <a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a> != VecTy-&gt;<a class="code" href="classllvm_1_1VectorType.html#a580510fa692dccfb26d0e967d8f164e7">getNumElements</a>(); ++<a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div><div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a> &gt;= BeginIndex &amp;&amp; <a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a> &lt; EndIndex)</div><div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;      Mask.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(IRB.getInt32(<a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a> - BeginIndex));</div><div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;      Mask.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(<a class="code" href="classllvm_1_1UndefValue.html#a4ae5ff22b700a42bcc5d889233721335">UndefValue::get</a>(IRB.getInt32Ty()));</div><div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;  V = IRB.CreateShuffleVector(V, <a class="code" href="classllvm_1_1UndefValue.html#a4ae5ff22b700a42bcc5d889233721335">UndefValue::get</a>(V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()),</div><div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;                              <a class="code" href="classllvm_1_1ConstantVector.html#ade9fa017ca3aa82f7694a47090547bc1">ConstantVector::get</a>(Mask),</div><div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;                              Name + <span class="stringliteral">&quot;.expand&quot;</span>);</div><div class="line"><a name="l01884"></a><span class="lineno"> 1884</span>&#160;  <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;    shuffle: &quot;</span> &lt;&lt; *V &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01885"></a><span class="lineno"> 1885</span>&#160;</div><div class="line"><a name="l01886"></a><span class="lineno"> 1886</span>&#160;  Mask.<a class="code" href="classllvm_1_1SmallVectorImpl.html#aac0ea55010b7b1a301e65a0baea057aa">clear</a>();</div><div class="line"><a name="l01887"></a><span class="lineno"> 1887</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a> = 0; <a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a> != VecTy-&gt;<a class="code" href="classllvm_1_1VectorType.html#a580510fa692dccfb26d0e967d8f164e7">getNumElements</a>(); ++<a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a>)</div><div class="line"><a name="l01888"></a><span class="lineno"> 1888</span>&#160;    Mask.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(IRB.getInt1(<a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a> &gt;= BeginIndex &amp;&amp; <a class="code" href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a> &lt; EndIndex));</div><div class="line"><a name="l01889"></a><span class="lineno"> 1889</span>&#160;</div><div class="line"><a name="l01890"></a><span class="lineno"> 1890</span>&#160;  V = IRB.CreateSelect(<a class="code" href="classllvm_1_1ConstantVector.html#ade9fa017ca3aa82f7694a47090547bc1">ConstantVector::get</a>(Mask), V, Old, Name + <span class="stringliteral">&quot;blend&quot;</span>);</div><div class="line"><a name="l01891"></a><span class="lineno"> 1891</span>&#160;</div><div class="line"><a name="l01892"></a><span class="lineno"> 1892</span>&#160;  <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;    blend: &quot;</span> &lt;&lt; *V &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01893"></a><span class="lineno"> 1893</span>&#160;  <span class="keywordflow">return</span> V;</div><div class="line"><a name="l01894"></a><span class="lineno"> 1894</span>&#160;}</div><div class="line"><a name="l01895"></a><span class="lineno"> 1895</span>&#160;</div><div class="line"><a name="l01896"></a><span class="lineno"> 1896</span>&#160;<span class="keyword">namespace </span>{<span class="comment"></span></div><div class="line"><a name="l01897"></a><span class="lineno"> 1897</span>&#160;<span class="comment">/// \brief Visitor to rewrite instructions using p particular slice of an alloca</span></div><div class="line"><a name="l01898"></a><span class="lineno"> 1898</span>&#160;<span class="comment">/// to use a new alloca.</span></div><div class="line"><a name="l01899"></a><span class="lineno"> 1899</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01900"></a><span class="lineno"> 1900</span>&#160;<span class="comment">/// Also implements the rewriting to vector-based accesses when the partition</span></div><div class="line"><a name="l01901"></a><span class="lineno"> 1901</span>&#160;<span class="comment">/// passes the isVectorPromotionViable predicate. Most of the rewriting logic</span></div><div class="line"><a name="l01902"></a><span class="lineno"> 1902</span>&#160;<span class="comment">/// lives here.</span></div><div class="line"><a name="l01903"></a><span class="lineno"> 1903</span>&#160;<span class="comment"></span><span class="keyword">class </span>AllocaSliceRewriter : <span class="keyword">public</span> <a class="code" href="classllvm_1_1InstVisitor.html">InstVisitor</a>&lt;AllocaSliceRewriter, bool&gt; {</div><div class="line"><a name="l01904"></a><span class="lineno"> 1904</span>&#160;  <span class="comment">// Befriend the base class so it can delegate to private visit methods.</span></div><div class="line"><a name="l01905"></a><span class="lineno"> 1905</span>&#160;  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classllvm_1_1InstVisitor.html">llvm::InstVisitor</a>&lt;AllocaSliceRewriter, bool&gt;;</div><div class="line"><a name="l01906"></a><span class="lineno"> 1906</span>&#160;  <span class="keyword">typedef</span> <a class="code" href="classllvm_1_1InstVisitor.html">llvm::InstVisitor&lt;AllocaSliceRewriter, bool&gt;</a> Base;</div><div class="line"><a name="l01907"></a><span class="lineno"> 1907</span>&#160;</div><div class="line"><a name="l01908"></a><span class="lineno"> 1908</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL;</div><div class="line"><a name="l01909"></a><span class="lineno"> 1909</span>&#160;  AllocaSlices &amp;<a class="code" href="Target_2ARM_2README_8txt.html#a1b45f45820a60c09244a87eb59824aec">S</a>;</div><div class="line"><a name="l01910"></a><span class="lineno"> 1910</span>&#160;  SROA &amp;<a class="code" href="classllvm_1_1Pass.html">Pass</a>;</div><div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160;  <a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> &amp;OldAI, &amp;NewAI;</div><div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;  <span class="keyword">const</span> uint64_t NewAllocaBeginOffset, NewAllocaEndOffset;</div><div class="line"><a name="l01913"></a><span class="lineno"> 1913</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *NewAllocaTy;</div><div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;</div><div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;  <span class="comment">// If we are rewriting an alloca partition which can be written as pure</span></div><div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;  <span class="comment">// vector operations, we stash extra information here. When VecTy is</span></div><div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;  <span class="comment">// non-null, we have some strict guarantees about the rewritten alloca:</span></div><div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;  <span class="comment">//   - The new alloca is exactly the size of the vector type here.</span></div><div class="line"><a name="l01919"></a><span class="lineno"> 1919</span>&#160;  <span class="comment">//   - The accesses all either map to the entire vector or to a single</span></div><div class="line"><a name="l01920"></a><span class="lineno"> 1920</span>&#160;  <span class="comment">//     element.</span></div><div class="line"><a name="l01921"></a><span class="lineno"> 1921</span>&#160;  <span class="comment">//   - The set of accessing instructions is only one of those handled above</span></div><div class="line"><a name="l01922"></a><span class="lineno"> 1922</span>&#160;  <span class="comment">//     in isVectorPromotionViable. Generally these are the same access kinds</span></div><div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;  <span class="comment">//     which are promotable via mem2reg.</span></div><div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;  <a class="code" href="classllvm_1_1VectorType.html">VectorType</a> *VecTy;</div><div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *ElementTy;</div><div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;  uint64_t ElementSize;</div><div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160;</div><div class="line"><a name="l01928"></a><span class="lineno"> 1928</span>&#160;  <span class="comment">// This is a convenience and flag variable that will be null unless the new</span></div><div class="line"><a name="l01929"></a><span class="lineno"> 1929</span>&#160;  <span class="comment">// alloca&#39;s integer operations should be widened to this integer type due to</span></div><div class="line"><a name="l01930"></a><span class="lineno"> 1930</span>&#160;  <span class="comment">// passing isIntegerWideningViable above. If it is non-null, the desired</span></div><div class="line"><a name="l01931"></a><span class="lineno"> 1931</span>&#160;  <span class="comment">// integer type will be stored here for easy access during rewriting.</span></div><div class="line"><a name="l01932"></a><span class="lineno"> 1932</span>&#160;  <a class="code" href="classllvm_1_1IntegerType.html">IntegerType</a> *IntTy;</div><div class="line"><a name="l01933"></a><span class="lineno"> 1933</span>&#160;</div><div class="line"><a name="l01934"></a><span class="lineno"> 1934</span>&#160;  <span class="comment">// The offset of the slice currently being rewritten.</span></div><div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;  uint64_t BeginOffset, EndOffset;</div><div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;  <span class="keywordtype">bool</span> IsSplittable;</div><div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;  <span class="keywordtype">bool</span> IsSplit;</div><div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;  <a class="code" href="classllvm_1_1Use.html">Use</a> *OldUse;</div><div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;  <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *OldPtr;</div><div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;</div><div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;  <span class="comment">// Output members carrying state about the result of visiting and rewriting</span></div><div class="line"><a name="l01942"></a><span class="lineno"> 1942</span>&#160;  <span class="comment">// the slice of the alloca.</span></div><div class="line"><a name="l01943"></a><span class="lineno"> 1943</span>&#160;  <span class="keywordtype">bool</span> IsUsedByRewrittenSpeculatableInstructions;</div><div class="line"><a name="l01944"></a><span class="lineno"> 1944</span>&#160;</div><div class="line"><a name="l01945"></a><span class="lineno"> 1945</span>&#160;  <span class="comment">// Utility IR builder, whose name prefix is setup for each visited use, and</span></div><div class="line"><a name="l01946"></a><span class="lineno"> 1946</span>&#160;  <span class="comment">// the insertion point is set to point to the user.</span></div><div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;  IRBuilderTy IRB;</div><div class="line"><a name="l01948"></a><span class="lineno"> 1948</span>&#160;</div><div class="line"><a name="l01949"></a><span class="lineno"> 1949</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l01950"></a><span class="lineno"> 1950</span>&#160;  AllocaSliceRewriter(<span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, AllocaSlices &amp;S, SROA &amp;Pass,</div><div class="line"><a name="l01951"></a><span class="lineno"> 1951</span>&#160;                      <a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> &amp;OldAI, <a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> &amp;NewAI,</div><div class="line"><a name="l01952"></a><span class="lineno"> 1952</span>&#160;                      uint64_t NewBeginOffset, uint64_t NewEndOffset,</div><div class="line"><a name="l01953"></a><span class="lineno"> 1953</span>&#160;                      <span class="keywordtype">bool</span> IsVectorPromotable = <span class="keyword">false</span>,</div><div class="line"><a name="l01954"></a><span class="lineno"> 1954</span>&#160;                      <span class="keywordtype">bool</span> IsIntegerPromotable = <span class="keyword">false</span>)</div><div class="line"><a name="l01955"></a><span class="lineno"> 1955</span>&#160;      : DL(DL), <a class="code" href="Target_2ARM_2README_8txt.html#a1b45f45820a60c09244a87eb59824aec">S</a>(S), Pass(Pass), OldAI(OldAI), NewAI(NewAI),</div><div class="line"><a name="l01956"></a><span class="lineno"> 1956</span>&#160;        NewAllocaBeginOffset(NewBeginOffset), NewAllocaEndOffset(NewEndOffset),</div><div class="line"><a name="l01957"></a><span class="lineno"> 1957</span>&#160;        NewAllocaTy(NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#a214c60dbb4f1ed467e5a3420db6eefd6">getAllocatedType</a>()),</div><div class="line"><a name="l01958"></a><span class="lineno"> 1958</span>&#160;        VecTy(IsVectorPromotable ? cast&lt;VectorType&gt;(NewAllocaTy) : 0),</div><div class="line"><a name="l01959"></a><span class="lineno"> 1959</span>&#160;        ElementTy(VecTy ? VecTy-&gt;<a class="code" href="classllvm_1_1SequentialType.html#a39f2c3a62f293faf11ac28b15bc53359">getElementType</a>() : 0),</div><div class="line"><a name="l01960"></a><span class="lineno"> 1960</span>&#160;        ElementSize(VecTy ? DL.<a class="code" href="classllvm_1_1DataLayout.html#add914112e0b2935dda06ad5dfd3a31db">getTypeSizeInBits</a>(ElementTy) / 8 : 0),</div><div class="line"><a name="l01961"></a><span class="lineno"> 1961</span>&#160;        IntTy(IsIntegerPromotable</div><div class="line"><a name="l01962"></a><span class="lineno"> 1962</span>&#160;                  ? <a class="code" href="classllvm_1_1Type.html#acaf8e4c3e40e01e848c1fad5f05b81cd">Type::getIntNTy</a>(</div><div class="line"><a name="l01963"></a><span class="lineno"> 1963</span>&#160;                        NewAI.<a class="code" href="classllvm_1_1Value.html#af85a4828b6b5a8de7fc0a55cc0e5b52f">getContext</a>(),</div><div class="line"><a name="l01964"></a><span class="lineno"> 1964</span>&#160;                        DL.<a class="code" href="classllvm_1_1DataLayout.html#add914112e0b2935dda06ad5dfd3a31db">getTypeSizeInBits</a>(NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#a214c60dbb4f1ed467e5a3420db6eefd6">getAllocatedType</a>()))</div><div class="line"><a name="l01965"></a><span class="lineno"> 1965</span>&#160;                  : 0),</div><div class="line"><a name="l01966"></a><span class="lineno"> 1966</span>&#160;        BeginOffset(), EndOffset(), IsSplittable(), IsSplit(), OldUse(),</div><div class="line"><a name="l01967"></a><span class="lineno"> 1967</span>&#160;        OldPtr(), IsUsedByRewrittenSpeculatableInstructions(<span class="keyword">false</span>),</div><div class="line"><a name="l01968"></a><span class="lineno"> 1968</span>&#160;        IRB(NewAI.<a class="code" href="classllvm_1_1Value.html#af85a4828b6b5a8de7fc0a55cc0e5b52f">getContext</a>(), <a class="code" href="classllvm_1_1ConstantFolder.html">ConstantFolder</a>()) {</div><div class="line"><a name="l01969"></a><span class="lineno"> 1969</span>&#160;    <span class="keywordflow">if</span> (VecTy) {</div><div class="line"><a name="l01970"></a><span class="lineno"> 1970</span>&#160;      assert((DL.<a class="code" href="classllvm_1_1DataLayout.html#add914112e0b2935dda06ad5dfd3a31db">getTypeSizeInBits</a>(ElementTy) % 8) == 0 &amp;&amp;</div><div class="line"><a name="l01971"></a><span class="lineno"> 1971</span>&#160;             <span class="stringliteral">&quot;Only multiple-of-8 sized vector elements are viable&quot;</span>);</div><div class="line"><a name="l01972"></a><span class="lineno"> 1972</span>&#160;      ++NumVectorized;</div><div class="line"><a name="l01973"></a><span class="lineno"> 1973</span>&#160;    }</div><div class="line"><a name="l01974"></a><span class="lineno"> 1974</span>&#160;    assert((!IsVectorPromotable &amp;&amp; !IsIntegerPromotable) ||</div><div class="line"><a name="l01975"></a><span class="lineno"> 1975</span>&#160;           IsVectorPromotable != IsIntegerPromotable);</div><div class="line"><a name="l01976"></a><span class="lineno"> 1976</span>&#160;  }</div><div class="line"><a name="l01977"></a><span class="lineno"> 1977</span>&#160;</div><div class="line"><a name="l01978"></a><span class="lineno"> 1978</span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1InstVisitor.html#a6352e72d11377a9c62f24434ae869bf0">visit</a>(AllocaSlices::const_iterator <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) {</div><div class="line"><a name="l01979"></a><span class="lineno"> 1979</span>&#160;    <span class="keywordtype">bool</span> CanSROA = <span class="keyword">true</span>;</div><div class="line"><a name="l01980"></a><span class="lineno"> 1980</span>&#160;    BeginOffset = I-&gt;beginOffset();</div><div class="line"><a name="l01981"></a><span class="lineno"> 1981</span>&#160;    EndOffset = I-&gt;endOffset();</div><div class="line"><a name="l01982"></a><span class="lineno"> 1982</span>&#160;    IsSplittable = I-&gt;isSplittable();</div><div class="line"><a name="l01983"></a><span class="lineno"> 1983</span>&#160;    IsSplit =</div><div class="line"><a name="l01984"></a><span class="lineno"> 1984</span>&#160;        BeginOffset &lt; NewAllocaBeginOffset || EndOffset &gt; NewAllocaEndOffset;</div><div class="line"><a name="l01985"></a><span class="lineno"> 1985</span>&#160;</div><div class="line"><a name="l01986"></a><span class="lineno"> 1986</span>&#160;    OldUse = I-&gt;getUse();</div><div class="line"><a name="l01987"></a><span class="lineno"> 1987</span>&#160;    OldPtr = cast&lt;Instruction&gt;(OldUse-&gt;get());</div><div class="line"><a name="l01988"></a><span class="lineno"> 1988</span>&#160;</div><div class="line"><a name="l01989"></a><span class="lineno"> 1989</span>&#160;    <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *OldUserI = cast&lt;Instruction&gt;(OldUse-&gt;getUser());</div><div class="line"><a name="l01990"></a><span class="lineno"> 1990</span>&#160;    IRB.SetInsertPoint(OldUserI);</div><div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160;    IRB.SetCurrentDebugLocation(OldUserI-&gt;getDebugLoc());</div><div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160;    IRB.SetNamePrefix(<a class="code" href="classllvm_1_1Twine.html">Twine</a>(NewAI.<a class="code" href="classllvm_1_1Value.html#ad452febc1ac0b394876e640ec03ffa38">getName</a>()) + <span class="stringliteral">&quot;.&quot;</span> + <a class="code" href="classllvm_1_1Twine.html">Twine</a>(BeginOffset) + <span class="stringliteral">&quot;.&quot;</span>);</div><div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160;</div><div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;    CanSROA &amp;= <a class="code" href="classllvm_1_1InstVisitor.html#a6352e72d11377a9c62f24434ae869bf0">visit</a>(cast&lt;Instruction&gt;(OldUse-&gt;getUser()));</div><div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;    <span class="keywordflow">if</span> (VecTy || IntTy)</div><div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;      assert(CanSROA);</div><div class="line"><a name="l01997"></a><span class="lineno"> 1997</span>&#160;    <span class="keywordflow">return</span> CanSROA;</div><div class="line"><a name="l01998"></a><span class="lineno"> 1998</span>&#160;  }</div><div class="line"><a name="l01999"></a><span class="lineno"> 1999</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02000"></a><span class="lineno"> 2000</span>&#160;<span class="comment">  /// \brief Query whether this slice is used by speculatable instructions after</span></div><div class="line"><a name="l02001"></a><span class="lineno"> 2001</span>&#160;<span class="comment">  /// rewriting.</span></div><div class="line"><a name="l02002"></a><span class="lineno"> 2002</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l02003"></a><span class="lineno"> 2003</span>&#160;<span class="comment">  /// These instructions (PHIs and Selects currently) require the alloca slice</span></div><div class="line"><a name="l02004"></a><span class="lineno"> 2004</span>&#160;<span class="comment">  /// to run back through the rewriter. Thus, they are promotable, but not on</span></div><div class="line"><a name="l02005"></a><span class="lineno"> 2005</span>&#160;<span class="comment">  /// this iteration. This is distinct from a slice which is unpromotable for</span></div><div class="line"><a name="l02006"></a><span class="lineno"> 2006</span>&#160;<span class="comment">  /// some other reason, in which case we don&#39;t even want to perform the</span></div><div class="line"><a name="l02007"></a><span class="lineno"> 2007</span>&#160;<span class="comment">  /// speculation. This can be querried at any time and reflects whether (at</span></div><div class="line"><a name="l02008"></a><span class="lineno"> 2008</span>&#160;<span class="comment">  /// that point) a visit call has rewritten a speculatable instruction on the</span></div><div class="line"><a name="l02009"></a><span class="lineno"> 2009</span>&#160;<span class="comment">  /// current slice.</span></div><div class="line"><a name="l02010"></a><span class="lineno"> 2010</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> isUsedByRewrittenSpeculatableInstructions()<span class="keyword"> const </span>{</div><div class="line"><a name="l02011"></a><span class="lineno"> 2011</span>&#160;    <span class="keywordflow">return</span> IsUsedByRewrittenSpeculatableInstructions;</div><div class="line"><a name="l02012"></a><span class="lineno"> 2012</span>&#160;  }</div><div class="line"><a name="l02013"></a><span class="lineno"> 2013</span>&#160;</div><div class="line"><a name="l02014"></a><span class="lineno"> 2014</span>&#160;<span class="keyword">private</span>:</div><div class="line"><a name="l02015"></a><span class="lineno"> 2015</span>&#160;  <span class="comment">// Make sure the other visit overloads are visible.</span></div><div class="line"><a name="l02016"></a><span class="lineno"> 2016</span>&#160;  <span class="keyword">using</span> Base::visit;</div><div class="line"><a name="l02017"></a><span class="lineno"> 2017</span>&#160;</div><div class="line"><a name="l02018"></a><span class="lineno"> 2018</span>&#160;  <span class="comment">// Every instruction which can end up as a user must have a rewrite rule.</span></div><div class="line"><a name="l02019"></a><span class="lineno"> 2019</span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1InstVisitor.html#af7fc294424421c8b8e16185bd9bc7f8f">visitInstruction</a>(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> &amp;I) {</div><div class="line"><a name="l02020"></a><span class="lineno"> 2020</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;    !!!! Cannot rewrite: &quot;</span> &lt;&lt; I &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02021"></a><span class="lineno"> 2021</span>&#160;    <a class="code" href="ErrorHandling_8h.html#ace243f5c25697a1107cce46626b3dc94">llvm_unreachable</a>(<span class="stringliteral">&quot;No rewrite rule for this instruction!&quot;</span>);</div><div class="line"><a name="l02022"></a><span class="lineno"> 2022</span>&#160;  }</div><div class="line"><a name="l02023"></a><span class="lineno"> 2023</span>&#160;</div><div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *getAdjustedAllocaPtr(IRBuilderTy &amp;IRB, uint64_t Offset,</div><div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;                              <a class="code" href="classllvm_1_1Type.html">Type</a> *<a class="code" href="namespacellvm.html#a7aa6722f52f5d4d2cb36ae41cd5044d3">PointerTy</a>) {</div><div class="line"><a name="l02026"></a><span class="lineno"> 2026</span>&#160;    assert(Offset &gt;= NewAllocaBeginOffset);</div><div class="line"><a name="l02027"></a><span class="lineno"> 2027</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SROA_8cpp.html#ab706500bd4aee346f53362dd30531f7f">getAdjustedPtr</a>(IRB, DL, &amp;NewAI, <a class="code" href="classllvm_1_1APInt.html">APInt</a>(DL.<a class="code" href="classllvm_1_1DataLayout.html#a9cb015699ac01dfa6ebb3cc4ce5a6a93">getPointerSizeInBits</a>(),</div><div class="line"><a name="l02028"></a><span class="lineno"> 2028</span>&#160;                                                 Offset - NewAllocaBeginOffset),</div><div class="line"><a name="l02029"></a><span class="lineno"> 2029</span>&#160;                          PointerTy);</div><div class="line"><a name="l02030"></a><span class="lineno"> 2030</span>&#160;  }</div><div class="line"><a name="l02031"></a><span class="lineno"> 2031</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02032"></a><span class="lineno"> 2032</span>&#160;<span class="comment">  /// \brief Compute suitable alignment to access an offset into the new alloca.</span></div><div class="line"><a name="l02033"></a><span class="lineno"> 2033</span>&#160;<span class="comment"></span>  <span class="keywordtype">unsigned</span> getOffsetAlign(uint64_t Offset) {</div><div class="line"><a name="l02034"></a><span class="lineno"> 2034</span>&#160;    <span class="keywordtype">unsigned</span> NewAIAlign = NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">getAlignment</a>();</div><div class="line"><a name="l02035"></a><span class="lineno"> 2035</span>&#160;    <span class="keywordflow">if</span> (!NewAIAlign)</div><div class="line"><a name="l02036"></a><span class="lineno"> 2036</span>&#160;      NewAIAlign = DL.<a class="code" href="classllvm_1_1DataLayout.html#abb381519d34dcb9ccf673bf7689d0721">getABITypeAlignment</a>(NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#a214c60dbb4f1ed467e5a3420db6eefd6">getAllocatedType</a>());</div><div class="line"><a name="l02037"></a><span class="lineno"> 2037</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacellvm.html#af36d7e69ab16b64b2e3a48c83aa9f0f6">MinAlign</a>(NewAIAlign, Offset);</div><div class="line"><a name="l02038"></a><span class="lineno"> 2038</span>&#160;  }</div><div class="line"><a name="l02039"></a><span class="lineno"> 2039</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02040"></a><span class="lineno"> 2040</span>&#160;<span class="comment">  /// \brief Compute suitable alignment to access a type at an offset of the</span></div><div class="line"><a name="l02041"></a><span class="lineno"> 2041</span>&#160;<span class="comment">  /// new alloca.</span></div><div class="line"><a name="l02042"></a><span class="lineno"> 2042</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l02043"></a><span class="lineno"> 2043</span>&#160;<span class="comment">  /// \returns zero if the type&#39;s ABI alignment is a suitable alignment,</span></div><div class="line"><a name="l02044"></a><span class="lineno"> 2044</span>&#160;<span class="comment">  /// otherwise returns the maximal suitable alignment.</span></div><div class="line"><a name="l02045"></a><span class="lineno"> 2045</span>&#160;<span class="comment"></span>  <span class="keywordtype">unsigned</span> getOffsetTypeAlign(<a class="code" href="classllvm_1_1Type.html">Type</a> *Ty, uint64_t Offset) {</div><div class="line"><a name="l02046"></a><span class="lineno"> 2046</span>&#160;    <span class="keywordtype">unsigned</span> <a class="code" href="ARMSubtarget_8cpp.html#a4bd80d4e433d9f72af26b364036900dc">Align</a> = getOffsetAlign(Offset);</div><div class="line"><a name="l02047"></a><span class="lineno"> 2047</span>&#160;    <span class="keywordflow">return</span> Align == DL.<a class="code" href="classllvm_1_1DataLayout.html#abb381519d34dcb9ccf673bf7689d0721">getABITypeAlignment</a>(Ty) ? 0 : <a class="code" href="ARMSubtarget_8cpp.html#a4bd80d4e433d9f72af26b364036900dc">Align</a>;</div><div class="line"><a name="l02048"></a><span class="lineno"> 2048</span>&#160;  }</div><div class="line"><a name="l02049"></a><span class="lineno"> 2049</span>&#160;</div><div class="line"><a name="l02050"></a><span class="lineno"> 2050</span>&#160;  <span class="keywordtype">unsigned</span> getIndex(uint64_t Offset) {</div><div class="line"><a name="l02051"></a><span class="lineno"> 2051</span>&#160;    assert(VecTy &amp;&amp; <span class="stringliteral">&quot;Can only call getIndex when rewriting a vector&quot;</span>);</div><div class="line"><a name="l02052"></a><span class="lineno"> 2052</span>&#160;    uint64_t RelOffset = Offset - NewAllocaBeginOffset;</div><div class="line"><a name="l02053"></a><span class="lineno"> 2053</span>&#160;    assert(RelOffset / ElementSize &lt; UINT32_MAX &amp;&amp; <span class="stringliteral">&quot;Index out of bounds&quot;</span>);</div><div class="line"><a name="l02054"></a><span class="lineno"> 2054</span>&#160;    uint32_t Index = RelOffset / ElementSize;</div><div class="line"><a name="l02055"></a><span class="lineno"> 2055</span>&#160;    assert(Index * ElementSize == RelOffset);</div><div class="line"><a name="l02056"></a><span class="lineno"> 2056</span>&#160;    <span class="keywordflow">return</span> Index;</div><div class="line"><a name="l02057"></a><span class="lineno"> 2057</span>&#160;  }</div><div class="line"><a name="l02058"></a><span class="lineno"> 2058</span>&#160;</div><div class="line"><a name="l02059"></a><span class="lineno"> 2059</span>&#160;  <span class="keywordtype">void</span> deleteIfTriviallyDead(<a class="code" href="classllvm_1_1Value.html">Value</a> *V) {</div><div class="line"><a name="l02060"></a><span class="lineno"> 2060</span>&#160;    <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *I = cast&lt;Instruction&gt;(V);</div><div class="line"><a name="l02061"></a><span class="lineno"> 2061</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespacellvm.html#abe283966f269761ee387642061c4451e">isInstructionTriviallyDead</a>(I))</div><div class="line"><a name="l02062"></a><span class="lineno"> 2062</span>&#160;      Pass.DeadInsts.insert(I);</div><div class="line"><a name="l02063"></a><span class="lineno"> 2063</span>&#160;  }</div><div class="line"><a name="l02064"></a><span class="lineno"> 2064</span>&#160;</div><div class="line"><a name="l02065"></a><span class="lineno"> 2065</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *rewriteVectorizedLoadInst(uint64_t NewBeginOffset,</div><div class="line"><a name="l02066"></a><span class="lineno"> 2066</span>&#160;                                   uint64_t NewEndOffset) {</div><div class="line"><a name="l02067"></a><span class="lineno"> 2067</span>&#160;    <span class="keywordtype">unsigned</span> BeginIndex = getIndex(NewBeginOffset);</div><div class="line"><a name="l02068"></a><span class="lineno"> 2068</span>&#160;    <span class="keywordtype">unsigned</span> EndIndex = getIndex(NewEndOffset);</div><div class="line"><a name="l02069"></a><span class="lineno"> 2069</span>&#160;    assert(EndIndex &gt; BeginIndex &amp;&amp; <span class="stringliteral">&quot;Empty vector!&quot;</span>);</div><div class="line"><a name="l02070"></a><span class="lineno"> 2070</span>&#160;</div><div class="line"><a name="l02071"></a><span class="lineno"> 2071</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *V = IRB.CreateAlignedLoad(&amp;NewAI, NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">getAlignment</a>(),</div><div class="line"><a name="l02072"></a><span class="lineno"> 2072</span>&#160;                                     <span class="stringliteral">&quot;load&quot;</span>);</div><div class="line"><a name="l02073"></a><span class="lineno"> 2073</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SROA_8cpp.html#a06a9071efa992145e210f0b41a52e501">extractVector</a>(IRB, V, BeginIndex, EndIndex, <span class="stringliteral">&quot;vec&quot;</span>);</div><div class="line"><a name="l02074"></a><span class="lineno"> 2074</span>&#160;  }</div><div class="line"><a name="l02075"></a><span class="lineno"> 2075</span>&#160;</div><div class="line"><a name="l02076"></a><span class="lineno"> 2076</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *rewriteIntegerLoad(<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> &amp;LI, uint64_t NewBeginOffset,</div><div class="line"><a name="l02077"></a><span class="lineno"> 2077</span>&#160;                            uint64_t NewEndOffset) {</div><div class="line"><a name="l02078"></a><span class="lineno"> 2078</span>&#160;    assert(IntTy &amp;&amp; <span class="stringliteral">&quot;We cannot insert an integer to the alloca&quot;</span>);</div><div class="line"><a name="l02079"></a><span class="lineno"> 2079</span>&#160;    assert(!LI.<a class="code" href="classllvm_1_1LoadInst.html#aeb96f1a88b4e58c34a988eebd843f688">isVolatile</a>());</div><div class="line"><a name="l02080"></a><span class="lineno"> 2080</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *V = IRB.CreateAlignedLoad(&amp;NewAI, NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">getAlignment</a>(),</div><div class="line"><a name="l02081"></a><span class="lineno"> 2081</span>&#160;                                     <span class="stringliteral">&quot;load&quot;</span>);</div><div class="line"><a name="l02082"></a><span class="lineno"> 2082</span>&#160;    V = <a class="code" href="SROA_8cpp.html#a7d6146d9a22768498097b2c53cd2234f">convertValue</a>(DL, IRB, V, IntTy);</div><div class="line"><a name="l02083"></a><span class="lineno"> 2083</span>&#160;    assert(NewBeginOffset &gt;= NewAllocaBeginOffset &amp;&amp; <span class="stringliteral">&quot;Out of bounds offset&quot;</span>);</div><div class="line"><a name="l02084"></a><span class="lineno"> 2084</span>&#160;    uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</div><div class="line"><a name="l02085"></a><span class="lineno"> 2085</span>&#160;    <span class="keywordflow">if</span> (Offset &gt; 0 || NewEndOffset &lt; NewAllocaEndOffset)</div><div class="line"><a name="l02086"></a><span class="lineno"> 2086</span>&#160;      V = <a class="code" href="SROA_8cpp.html#a94e7aca18fb08798727209385f164f7c">extractInteger</a>(DL, IRB, V, cast&lt;IntegerType&gt;(LI.<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()), Offset,</div><div class="line"><a name="l02087"></a><span class="lineno"> 2087</span>&#160;                         <span class="stringliteral">&quot;extract&quot;</span>);</div><div class="line"><a name="l02088"></a><span class="lineno"> 2088</span>&#160;    <span class="keywordflow">return</span> V;</div><div class="line"><a name="l02089"></a><span class="lineno"> 2089</span>&#160;  }</div><div class="line"><a name="l02090"></a><span class="lineno"> 2090</span>&#160;</div><div class="line"><a name="l02091"></a><span class="lineno"> 2091</span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1InstVisitor.html#af8829e5fbad4f9606b5b6c0b100493c5">visitLoadInst</a>(<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> &amp;LI) {</div><div class="line"><a name="l02092"></a><span class="lineno"> 2092</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;    original: &quot;</span> &lt;&lt; LI &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02093"></a><span class="lineno"> 2093</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *OldOp = LI.<a class="code" href="classllvm_1_1User.html#a997ff6a1758bf732b9b263fc61011644">getOperand</a>(0);</div><div class="line"><a name="l02094"></a><span class="lineno"> 2094</span>&#160;    assert(OldOp == OldPtr);</div><div class="line"><a name="l02095"></a><span class="lineno"> 2095</span>&#160;</div><div class="line"><a name="l02096"></a><span class="lineno"> 2096</span>&#160;    <span class="comment">// Compute the intersecting offset range.</span></div><div class="line"><a name="l02097"></a><span class="lineno"> 2097</span>&#160;    assert(BeginOffset &lt; NewAllocaEndOffset);</div><div class="line"><a name="l02098"></a><span class="lineno"> 2098</span>&#160;    assert(EndOffset &gt; NewAllocaBeginOffset);</div><div class="line"><a name="l02099"></a><span class="lineno"> 2099</span>&#160;    uint64_t NewBeginOffset = std::max(BeginOffset, NewAllocaBeginOffset);</div><div class="line"><a name="l02100"></a><span class="lineno"> 2100</span>&#160;    uint64_t NewEndOffset = std::min(EndOffset, NewAllocaEndOffset);</div><div class="line"><a name="l02101"></a><span class="lineno"> 2101</span>&#160;</div><div class="line"><a name="l02102"></a><span class="lineno"> 2102</span>&#160;    uint64_t Size = NewEndOffset - NewBeginOffset;</div><div class="line"><a name="l02103"></a><span class="lineno"> 2103</span>&#160;</div><div class="line"><a name="l02104"></a><span class="lineno"> 2104</span>&#160;    <a class="code" href="classllvm_1_1Type.html">Type</a> *TargetTy = IsSplit ? <a class="code" href="classllvm_1_1Type.html#acaf8e4c3e40e01e848c1fad5f05b81cd">Type::getIntNTy</a>(LI.<a class="code" href="classllvm_1_1Value.html#af85a4828b6b5a8de7fc0a55cc0e5b52f">getContext</a>(), Size * 8)</div><div class="line"><a name="l02105"></a><span class="lineno"> 2105</span>&#160;                             : LI.<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>();</div><div class="line"><a name="l02106"></a><span class="lineno"> 2106</span>&#160;    <span class="keywordtype">bool</span> IsPtrAdjusted = <span class="keyword">false</span>;</div><div class="line"><a name="l02107"></a><span class="lineno"> 2107</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *V;</div><div class="line"><a name="l02108"></a><span class="lineno"> 2108</span>&#160;    <span class="keywordflow">if</span> (VecTy) {</div><div class="line"><a name="l02109"></a><span class="lineno"> 2109</span>&#160;      V = rewriteVectorizedLoadInst(NewBeginOffset, NewEndOffset);</div><div class="line"><a name="l02110"></a><span class="lineno"> 2110</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IntTy &amp;&amp; LI.<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a6e328feb83afa5cf1c966d6704e43fc1">isIntegerTy</a>()) {</div><div class="line"><a name="l02111"></a><span class="lineno"> 2111</span>&#160;      V = rewriteIntegerLoad(LI, NewBeginOffset, NewEndOffset);</div><div class="line"><a name="l02112"></a><span class="lineno"> 2112</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (NewBeginOffset == NewAllocaBeginOffset &amp;&amp;</div><div class="line"><a name="l02113"></a><span class="lineno"> 2113</span>&#160;               <a class="code" href="SROA_8cpp.html#a2fb1c078833c17e4c9529b0cf924385c">canConvertValue</a>(DL, NewAllocaTy, LI.<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>())) {</div><div class="line"><a name="l02114"></a><span class="lineno"> 2114</span>&#160;      V = IRB.CreateAlignedLoad(&amp;NewAI, NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">getAlignment</a>(),</div><div class="line"><a name="l02115"></a><span class="lineno"> 2115</span>&#160;                                LI.<a class="code" href="classllvm_1_1LoadInst.html#aeb96f1a88b4e58c34a988eebd843f688">isVolatile</a>(), <span class="stringliteral">&quot;load&quot;</span>);</div><div class="line"><a name="l02116"></a><span class="lineno"> 2116</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l02117"></a><span class="lineno"> 2117</span>&#160;      <a class="code" href="classllvm_1_1Type.html">Type</a> *LTy = TargetTy-&gt;<a class="code" href="classllvm_1_1Type.html#ab6cc070c37c59589af100aab6f48ef4f">getPointerTo</a>();</div><div class="line"><a name="l02118"></a><span class="lineno"> 2118</span>&#160;      V = IRB.CreateAlignedLoad(</div><div class="line"><a name="l02119"></a><span class="lineno"> 2119</span>&#160;          getAdjustedAllocaPtr(IRB, NewBeginOffset, LTy),</div><div class="line"><a name="l02120"></a><span class="lineno"> 2120</span>&#160;          getOffsetTypeAlign(TargetTy, NewBeginOffset - NewAllocaBeginOffset),</div><div class="line"><a name="l02121"></a><span class="lineno"> 2121</span>&#160;          LI.<a class="code" href="classllvm_1_1LoadInst.html#aeb96f1a88b4e58c34a988eebd843f688">isVolatile</a>(), <span class="stringliteral">&quot;load&quot;</span>);</div><div class="line"><a name="l02122"></a><span class="lineno"> 2122</span>&#160;      IsPtrAdjusted = <span class="keyword">true</span>;</div><div class="line"><a name="l02123"></a><span class="lineno"> 2123</span>&#160;    }</div><div class="line"><a name="l02124"></a><span class="lineno"> 2124</span>&#160;    V = <a class="code" href="SROA_8cpp.html#a7d6146d9a22768498097b2c53cd2234f">convertValue</a>(DL, IRB, V, TargetTy);</div><div class="line"><a name="l02125"></a><span class="lineno"> 2125</span>&#160;</div><div class="line"><a name="l02126"></a><span class="lineno"> 2126</span>&#160;    <span class="keywordflow">if</span> (IsSplit) {</div><div class="line"><a name="l02127"></a><span class="lineno"> 2127</span>&#160;      assert(!LI.<a class="code" href="classllvm_1_1LoadInst.html#aeb96f1a88b4e58c34a988eebd843f688">isVolatile</a>());</div><div class="line"><a name="l02128"></a><span class="lineno"> 2128</span>&#160;      assert(LI.<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a6e328feb83afa5cf1c966d6704e43fc1">isIntegerTy</a>() &amp;&amp;</div><div class="line"><a name="l02129"></a><span class="lineno"> 2129</span>&#160;             <span class="stringliteral">&quot;Only integer type loads and stores are split&quot;</span>);</div><div class="line"><a name="l02130"></a><span class="lineno"> 2130</span>&#160;      assert(Size &lt; DL.<a class="code" href="classllvm_1_1DataLayout.html#a4b979cd93852fd44c48851c94ee00758">getTypeStoreSize</a>(LI.<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()) &amp;&amp;</div><div class="line"><a name="l02131"></a><span class="lineno"> 2131</span>&#160;             <span class="stringliteral">&quot;Split load isn&#39;t smaller than original load&quot;</span>);</div><div class="line"><a name="l02132"></a><span class="lineno"> 2132</span>&#160;      assert(LI.<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a0519dc6e2f153aaed61eed17d965a9f0">getIntegerBitWidth</a>() ==</div><div class="line"><a name="l02133"></a><span class="lineno"> 2133</span>&#160;             DL.<a class="code" href="classllvm_1_1DataLayout.html#a328b37dd0e404674678018ac2f2e38af">getTypeStoreSizeInBits</a>(LI.<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()) &amp;&amp;</div><div class="line"><a name="l02134"></a><span class="lineno"> 2134</span>&#160;             <span class="stringliteral">&quot;Non-byte-multiple bit width&quot;</span>);</div><div class="line"><a name="l02135"></a><span class="lineno"> 2135</span>&#160;      <span class="comment">// Move the insertion point just past the load so that we can refer to it.</span></div><div class="line"><a name="l02136"></a><span class="lineno"> 2136</span>&#160;      IRB.SetInsertPoint(<a class="code" href="namespacellvm.html#aa1704159f75e6eacd595962ea6d93ffe">llvm::next</a>(<a class="code" href="classllvm_1_1ilist__iterator.html">BasicBlock::iterator</a>(&amp;LI)));</div><div class="line"><a name="l02137"></a><span class="lineno"> 2137</span>&#160;      <span class="comment">// Create a placeholder value with the same type as LI to use as the</span></div><div class="line"><a name="l02138"></a><span class="lineno"> 2138</span>&#160;      <span class="comment">// basis for the new value. This allows us to replace the uses of LI with</span></div><div class="line"><a name="l02139"></a><span class="lineno"> 2139</span>&#160;      <span class="comment">// the computed value, and then replace the placeholder with LI, leaving</span></div><div class="line"><a name="l02140"></a><span class="lineno"> 2140</span>&#160;      <span class="comment">// LI only used for this computation.</span></div><div class="line"><a name="l02141"></a><span class="lineno"> 2141</span>&#160;      <a class="code" href="classllvm_1_1Value.html">Value</a> *Placeholder</div><div class="line"><a name="l02142"></a><span class="lineno"> 2142</span>&#160;        = <span class="keyword">new</span> <a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a>(<a class="code" href="classllvm_1_1UndefValue.html#a4ae5ff22b700a42bcc5d889233721335">UndefValue::get</a>(LI.<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#ab6cc070c37c59589af100aab6f48ef4f">getPointerTo</a>()));</div><div class="line"><a name="l02143"></a><span class="lineno"> 2143</span>&#160;      V = <a class="code" href="SROA_8cpp.html#a7febebe786555d6e0d07ca0f86e294c1">insertInteger</a>(DL, IRB, Placeholder, V, NewBeginOffset,</div><div class="line"><a name="l02144"></a><span class="lineno"> 2144</span>&#160;                        <span class="stringliteral">&quot;insert&quot;</span>);</div><div class="line"><a name="l02145"></a><span class="lineno"> 2145</span>&#160;      LI.<a class="code" href="classllvm_1_1Value.html#a3ab5fc45117b450e8bb04e564cb6e5f2">replaceAllUsesWith</a>(V);</div><div class="line"><a name="l02146"></a><span class="lineno"> 2146</span>&#160;      Placeholder-&gt;<a class="code" href="classllvm_1_1Value.html#a3ab5fc45117b450e8bb04e564cb6e5f2">replaceAllUsesWith</a>(&amp;LI);</div><div class="line"><a name="l02147"></a><span class="lineno"> 2147</span>&#160;      <span class="keyword">delete</span> Placeholder;</div><div class="line"><a name="l02148"></a><span class="lineno"> 2148</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l02149"></a><span class="lineno"> 2149</span>&#160;      LI.<a class="code" href="classllvm_1_1Value.html#a3ab5fc45117b450e8bb04e564cb6e5f2">replaceAllUsesWith</a>(V);</div><div class="line"><a name="l02150"></a><span class="lineno"> 2150</span>&#160;    }</div><div class="line"><a name="l02151"></a><span class="lineno"> 2151</span>&#160;</div><div class="line"><a name="l02152"></a><span class="lineno"> 2152</span>&#160;    Pass.DeadInsts.insert(&amp;LI);</div><div class="line"><a name="l02153"></a><span class="lineno"> 2153</span>&#160;    deleteIfTriviallyDead(OldOp);</div><div class="line"><a name="l02154"></a><span class="lineno"> 2154</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;          to: &quot;</span> &lt;&lt; *V &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02155"></a><span class="lineno"> 2155</span>&#160;    <span class="keywordflow">return</span> !LI.<a class="code" href="classllvm_1_1LoadInst.html#aeb96f1a88b4e58c34a988eebd843f688">isVolatile</a>() &amp;&amp; !IsPtrAdjusted;</div><div class="line"><a name="l02156"></a><span class="lineno"> 2156</span>&#160;  }</div><div class="line"><a name="l02157"></a><span class="lineno"> 2157</span>&#160;</div><div class="line"><a name="l02158"></a><span class="lineno"> 2158</span>&#160;  <span class="keywordtype">bool</span> rewriteVectorizedStoreInst(<a class="code" href="classllvm_1_1Value.html">Value</a> *V, <a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> &amp;SI, <a class="code" href="classllvm_1_1Value.html">Value</a> *OldOp,</div><div class="line"><a name="l02159"></a><span class="lineno"> 2159</span>&#160;                                  uint64_t NewBeginOffset,</div><div class="line"><a name="l02160"></a><span class="lineno"> 2160</span>&#160;                                  uint64_t NewEndOffset) {</div><div class="line"><a name="l02161"></a><span class="lineno"> 2161</span>&#160;    <span class="keywordflow">if</span> (V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>() != VecTy) {</div><div class="line"><a name="l02162"></a><span class="lineno"> 2162</span>&#160;      <span class="keywordtype">unsigned</span> BeginIndex = getIndex(NewBeginOffset);</div><div class="line"><a name="l02163"></a><span class="lineno"> 2163</span>&#160;      <span class="keywordtype">unsigned</span> EndIndex = getIndex(NewEndOffset);</div><div class="line"><a name="l02164"></a><span class="lineno"> 2164</span>&#160;      assert(EndIndex &gt; BeginIndex &amp;&amp; <span class="stringliteral">&quot;Empty vector!&quot;</span>);</div><div class="line"><a name="l02165"></a><span class="lineno"> 2165</span>&#160;      <span class="keywordtype">unsigned</span> NumElements = EndIndex - BeginIndex;</div><div class="line"><a name="l02166"></a><span class="lineno"> 2166</span>&#160;      assert(NumElements &lt;= VecTy-&gt;getNumElements() &amp;&amp; <span class="stringliteral">&quot;Too many elements!&quot;</span>);</div><div class="line"><a name="l02167"></a><span class="lineno"> 2167</span>&#160;      <a class="code" href="classllvm_1_1Type.html">Type</a> *SliceTy =</div><div class="line"><a name="l02168"></a><span class="lineno"> 2168</span>&#160;          (NumElements == 1) ? ElementTy</div><div class="line"><a name="l02169"></a><span class="lineno"> 2169</span>&#160;                             : <a class="code" href="classllvm_1_1VectorType.html#ab43657ed1abe2e2ed3a6a394f233ebd0">VectorType::get</a>(ElementTy, NumElements);</div><div class="line"><a name="l02170"></a><span class="lineno"> 2170</span>&#160;      <span class="keywordflow">if</span> (V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>() != SliceTy)</div><div class="line"><a name="l02171"></a><span class="lineno"> 2171</span>&#160;        V = <a class="code" href="SROA_8cpp.html#a7d6146d9a22768498097b2c53cd2234f">convertValue</a>(DL, IRB, V, SliceTy);</div><div class="line"><a name="l02172"></a><span class="lineno"> 2172</span>&#160;</div><div class="line"><a name="l02173"></a><span class="lineno"> 2173</span>&#160;      <span class="comment">// Mix in the existing elements.</span></div><div class="line"><a name="l02174"></a><span class="lineno"> 2174</span>&#160;      <a class="code" href="classllvm_1_1Value.html">Value</a> *Old = IRB.CreateAlignedLoad(&amp;NewAI, NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">getAlignment</a>(),</div><div class="line"><a name="l02175"></a><span class="lineno"> 2175</span>&#160;                                         <span class="stringliteral">&quot;load&quot;</span>);</div><div class="line"><a name="l02176"></a><span class="lineno"> 2176</span>&#160;      V = <a class="code" href="SROA_8cpp.html#a42c6a2faff923f431932c6d33cf4092b">insertVector</a>(IRB, Old, V, BeginIndex, <span class="stringliteral">&quot;vec&quot;</span>);</div><div class="line"><a name="l02177"></a><span class="lineno"> 2177</span>&#160;    }</div><div class="line"><a name="l02178"></a><span class="lineno"> 2178</span>&#160;    <a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> *<a class="code" href="namespacellvm_1_1SPII.html#a11e9b8fca4a074643a6a21f444e51406a36b3dd3b84fde3f8494a9b18af131856">Store</a> = IRB.CreateAlignedStore(V, &amp;NewAI, NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">getAlignment</a>());</div><div class="line"><a name="l02179"></a><span class="lineno"> 2179</span>&#160;    Pass.DeadInsts.insert(&amp;SI);</div><div class="line"><a name="l02180"></a><span class="lineno"> 2180</span>&#160;</div><div class="line"><a name="l02181"></a><span class="lineno"> 2181</span>&#160;    (void)Store;</div><div class="line"><a name="l02182"></a><span class="lineno"> 2182</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;          to: &quot;</span> &lt;&lt; *Store &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02183"></a><span class="lineno"> 2183</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l02184"></a><span class="lineno"> 2184</span>&#160;  }</div><div class="line"><a name="l02185"></a><span class="lineno"> 2185</span>&#160;</div><div class="line"><a name="l02186"></a><span class="lineno"> 2186</span>&#160;  <span class="keywordtype">bool</span> rewriteIntegerStore(<a class="code" href="classllvm_1_1Value.html">Value</a> *V, <a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> &amp;SI,</div><div class="line"><a name="l02187"></a><span class="lineno"> 2187</span>&#160;                           uint64_t NewBeginOffset, uint64_t NewEndOffset) {</div><div class="line"><a name="l02188"></a><span class="lineno"> 2188</span>&#160;    assert(IntTy &amp;&amp; <span class="stringliteral">&quot;We cannot extract an integer from the alloca&quot;</span>);</div><div class="line"><a name="l02189"></a><span class="lineno"> 2189</span>&#160;    assert(!SI.<a class="code" href="classllvm_1_1StoreInst.html#a89471513a05fad4bbef69ec411b2586d">isVolatile</a>());</div><div class="line"><a name="l02190"></a><span class="lineno"> 2190</span>&#160;    <span class="keywordflow">if</span> (DL.<a class="code" href="classllvm_1_1DataLayout.html#add914112e0b2935dda06ad5dfd3a31db">getTypeSizeInBits</a>(V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()) != IntTy-&gt;<a class="code" href="classllvm_1_1IntegerType.html#a6f603ab84f6f7c79985036f58cca9d48">getBitWidth</a>()) {</div><div class="line"><a name="l02191"></a><span class="lineno"> 2191</span>&#160;      <a class="code" href="classllvm_1_1Value.html">Value</a> *Old = IRB.CreateAlignedLoad(&amp;NewAI, NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">getAlignment</a>(),</div><div class="line"><a name="l02192"></a><span class="lineno"> 2192</span>&#160;                                         <span class="stringliteral">&quot;oldload&quot;</span>);</div><div class="line"><a name="l02193"></a><span class="lineno"> 2193</span>&#160;      Old = <a class="code" href="SROA_8cpp.html#a7d6146d9a22768498097b2c53cd2234f">convertValue</a>(DL, IRB, Old, IntTy);</div><div class="line"><a name="l02194"></a><span class="lineno"> 2194</span>&#160;      assert(BeginOffset &gt;= NewAllocaBeginOffset &amp;&amp; <span class="stringliteral">&quot;Out of bounds offset&quot;</span>);</div><div class="line"><a name="l02195"></a><span class="lineno"> 2195</span>&#160;      uint64_t Offset = BeginOffset - NewAllocaBeginOffset;</div><div class="line"><a name="l02196"></a><span class="lineno"> 2196</span>&#160;      V = <a class="code" href="SROA_8cpp.html#a7febebe786555d6e0d07ca0f86e294c1">insertInteger</a>(DL, IRB, Old, SI.<a class="code" href="classllvm_1_1StoreInst.html#a14298313bdf734e2db5a921cc6e861a0">getValueOperand</a>(), Offset,</div><div class="line"><a name="l02197"></a><span class="lineno"> 2197</span>&#160;                        <span class="stringliteral">&quot;insert&quot;</span>);</div><div class="line"><a name="l02198"></a><span class="lineno"> 2198</span>&#160;    }</div><div class="line"><a name="l02199"></a><span class="lineno"> 2199</span>&#160;    V = <a class="code" href="SROA_8cpp.html#a7d6146d9a22768498097b2c53cd2234f">convertValue</a>(DL, IRB, V, NewAllocaTy);</div><div class="line"><a name="l02200"></a><span class="lineno"> 2200</span>&#160;    <a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> *<a class="code" href="namespacellvm_1_1SPII.html#a11e9b8fca4a074643a6a21f444e51406a36b3dd3b84fde3f8494a9b18af131856">Store</a> = IRB.CreateAlignedStore(V, &amp;NewAI, NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">getAlignment</a>());</div><div class="line"><a name="l02201"></a><span class="lineno"> 2201</span>&#160;    Pass.DeadInsts.insert(&amp;SI);</div><div class="line"><a name="l02202"></a><span class="lineno"> 2202</span>&#160;    (void)Store;</div><div class="line"><a name="l02203"></a><span class="lineno"> 2203</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;          to: &quot;</span> &lt;&lt; *Store &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02204"></a><span class="lineno"> 2204</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l02205"></a><span class="lineno"> 2205</span>&#160;  }</div><div class="line"><a name="l02206"></a><span class="lineno"> 2206</span>&#160;</div><div class="line"><a name="l02207"></a><span class="lineno"> 2207</span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1InstVisitor.html#a8f006d606ec21cb0e454912ce36d17d8">visitStoreInst</a>(<a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> &amp;SI) {</div><div class="line"><a name="l02208"></a><span class="lineno"> 2208</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;    original: &quot;</span> &lt;&lt; SI &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02209"></a><span class="lineno"> 2209</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *OldOp = SI.<a class="code" href="classllvm_1_1User.html#a997ff6a1758bf732b9b263fc61011644">getOperand</a>(1);</div><div class="line"><a name="l02210"></a><span class="lineno"> 2210</span>&#160;    assert(OldOp == OldPtr);</div><div class="line"><a name="l02211"></a><span class="lineno"> 2211</span>&#160;</div><div class="line"><a name="l02212"></a><span class="lineno"> 2212</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *V = SI.<a class="code" href="classllvm_1_1StoreInst.html#a14298313bdf734e2db5a921cc6e861a0">getValueOperand</a>();</div><div class="line"><a name="l02213"></a><span class="lineno"> 2213</span>&#160;</div><div class="line"><a name="l02214"></a><span class="lineno"> 2214</span>&#160;    <span class="comment">// Strip all inbounds GEPs and pointer casts to try to dig out any root</span></div><div class="line"><a name="l02215"></a><span class="lineno"> 2215</span>&#160;    <span class="comment">// alloca that should be re-examined after promoting this alloca.</span></div><div class="line"><a name="l02216"></a><span class="lineno"> 2216</span>&#160;    <span class="keywordflow">if</span> (V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a2eba483f5cc876e824aa6c085736086b">isPointerTy</a>())</div><div class="line"><a name="l02217"></a><span class="lineno"> 2217</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> *AI = dyn_cast&lt;AllocaInst&gt;(V-&gt;<a class="code" href="classllvm_1_1Value.html#a30fec2a6a53ed66b12318765c8feac13">stripInBoundsOffsets</a>()))</div><div class="line"><a name="l02218"></a><span class="lineno"> 2218</span>&#160;        Pass.PostPromotionWorklist.insert(AI);</div><div class="line"><a name="l02219"></a><span class="lineno"> 2219</span>&#160;</div><div class="line"><a name="l02220"></a><span class="lineno"> 2220</span>&#160;    <span class="comment">// Compute the intersecting offset range.</span></div><div class="line"><a name="l02221"></a><span class="lineno"> 2221</span>&#160;    assert(BeginOffset &lt; NewAllocaEndOffset);</div><div class="line"><a name="l02222"></a><span class="lineno"> 2222</span>&#160;    assert(EndOffset &gt; NewAllocaBeginOffset);</div><div class="line"><a name="l02223"></a><span class="lineno"> 2223</span>&#160;    uint64_t NewBeginOffset = std::max(BeginOffset, NewAllocaBeginOffset);</div><div class="line"><a name="l02224"></a><span class="lineno"> 2224</span>&#160;    uint64_t NewEndOffset = std::min(EndOffset, NewAllocaEndOffset);</div><div class="line"><a name="l02225"></a><span class="lineno"> 2225</span>&#160;</div><div class="line"><a name="l02226"></a><span class="lineno"> 2226</span>&#160;    uint64_t Size = NewEndOffset - NewBeginOffset;</div><div class="line"><a name="l02227"></a><span class="lineno"> 2227</span>&#160;    <span class="keywordflow">if</span> (Size &lt; DL.<a class="code" href="classllvm_1_1DataLayout.html#a4b979cd93852fd44c48851c94ee00758">getTypeStoreSize</a>(V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>())) {</div><div class="line"><a name="l02228"></a><span class="lineno"> 2228</span>&#160;      assert(!SI.<a class="code" href="classllvm_1_1StoreInst.html#a89471513a05fad4bbef69ec411b2586d">isVolatile</a>());</div><div class="line"><a name="l02229"></a><span class="lineno"> 2229</span>&#160;      assert(V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a6e328feb83afa5cf1c966d6704e43fc1">isIntegerTy</a>() &amp;&amp;</div><div class="line"><a name="l02230"></a><span class="lineno"> 2230</span>&#160;             <span class="stringliteral">&quot;Only integer type loads and stores are split&quot;</span>);</div><div class="line"><a name="l02231"></a><span class="lineno"> 2231</span>&#160;      assert(V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a0519dc6e2f153aaed61eed17d965a9f0">getIntegerBitWidth</a>() ==</div><div class="line"><a name="l02232"></a><span class="lineno"> 2232</span>&#160;             DL.<a class="code" href="classllvm_1_1DataLayout.html#a328b37dd0e404674678018ac2f2e38af">getTypeStoreSizeInBits</a>(V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()) &amp;&amp;</div><div class="line"><a name="l02233"></a><span class="lineno"> 2233</span>&#160;             <span class="stringliteral">&quot;Non-byte-multiple bit width&quot;</span>);</div><div class="line"><a name="l02234"></a><span class="lineno"> 2234</span>&#160;      <a class="code" href="classllvm_1_1IntegerType.html">IntegerType</a> *NarrowTy = <a class="code" href="classllvm_1_1Type.html#acaf8e4c3e40e01e848c1fad5f05b81cd">Type::getIntNTy</a>(SI.<a class="code" href="classllvm_1_1Value.html#af85a4828b6b5a8de7fc0a55cc0e5b52f">getContext</a>(), Size * 8);</div><div class="line"><a name="l02235"></a><span class="lineno"> 2235</span>&#160;      V = <a class="code" href="SROA_8cpp.html#a94e7aca18fb08798727209385f164f7c">extractInteger</a>(DL, IRB, V, NarrowTy, NewBeginOffset,</div><div class="line"><a name="l02236"></a><span class="lineno"> 2236</span>&#160;                         <span class="stringliteral">&quot;extract&quot;</span>);</div><div class="line"><a name="l02237"></a><span class="lineno"> 2237</span>&#160;    }</div><div class="line"><a name="l02238"></a><span class="lineno"> 2238</span>&#160;</div><div class="line"><a name="l02239"></a><span class="lineno"> 2239</span>&#160;    <span class="keywordflow">if</span> (VecTy)</div><div class="line"><a name="l02240"></a><span class="lineno"> 2240</span>&#160;      <span class="keywordflow">return</span> rewriteVectorizedStoreInst(V, SI, OldOp, NewBeginOffset,</div><div class="line"><a name="l02241"></a><span class="lineno"> 2241</span>&#160;                                        NewEndOffset);</div><div class="line"><a name="l02242"></a><span class="lineno"> 2242</span>&#160;    <span class="keywordflow">if</span> (IntTy &amp;&amp; V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a6e328feb83afa5cf1c966d6704e43fc1">isIntegerTy</a>())</div><div class="line"><a name="l02243"></a><span class="lineno"> 2243</span>&#160;      <span class="keywordflow">return</span> rewriteIntegerStore(V, SI, NewBeginOffset, NewEndOffset);</div><div class="line"><a name="l02244"></a><span class="lineno"> 2244</span>&#160;</div><div class="line"><a name="l02245"></a><span class="lineno"> 2245</span>&#160;    <a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> *NewSI;</div><div class="line"><a name="l02246"></a><span class="lineno"> 2246</span>&#160;    <span class="keywordflow">if</span> (NewBeginOffset == NewAllocaBeginOffset &amp;&amp;</div><div class="line"><a name="l02247"></a><span class="lineno"> 2247</span>&#160;        NewEndOffset == NewAllocaEndOffset &amp;&amp;</div><div class="line"><a name="l02248"></a><span class="lineno"> 2248</span>&#160;        <a class="code" href="SROA_8cpp.html#a2fb1c078833c17e4c9529b0cf924385c">canConvertValue</a>(DL, V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>(), NewAllocaTy)) {</div><div class="line"><a name="l02249"></a><span class="lineno"> 2249</span>&#160;      V = <a class="code" href="SROA_8cpp.html#a7d6146d9a22768498097b2c53cd2234f">convertValue</a>(DL, IRB, V, NewAllocaTy);</div><div class="line"><a name="l02250"></a><span class="lineno"> 2250</span>&#160;      NewSI = IRB.CreateAlignedStore(V, &amp;NewAI, NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">getAlignment</a>(),</div><div class="line"><a name="l02251"></a><span class="lineno"> 2251</span>&#160;                                     SI.<a class="code" href="classllvm_1_1StoreInst.html#a89471513a05fad4bbef69ec411b2586d">isVolatile</a>());</div><div class="line"><a name="l02252"></a><span class="lineno"> 2252</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l02253"></a><span class="lineno"> 2253</span>&#160;      <a class="code" href="classllvm_1_1Value.html">Value</a> *NewPtr = getAdjustedAllocaPtr(IRB, NewBeginOffset,</div><div class="line"><a name="l02254"></a><span class="lineno"> 2254</span>&#160;                                           V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#ab6cc070c37c59589af100aab6f48ef4f">getPointerTo</a>());</div><div class="line"><a name="l02255"></a><span class="lineno"> 2255</span>&#160;      NewSI = IRB.CreateAlignedStore(</div><div class="line"><a name="l02256"></a><span class="lineno"> 2256</span>&#160;          V, NewPtr, getOffsetTypeAlign(</div><div class="line"><a name="l02257"></a><span class="lineno"> 2257</span>&#160;                         V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>(), NewBeginOffset - NewAllocaBeginOffset),</div><div class="line"><a name="l02258"></a><span class="lineno"> 2258</span>&#160;          SI.<a class="code" href="classllvm_1_1StoreInst.html#a89471513a05fad4bbef69ec411b2586d">isVolatile</a>());</div><div class="line"><a name="l02259"></a><span class="lineno"> 2259</span>&#160;    }</div><div class="line"><a name="l02260"></a><span class="lineno"> 2260</span>&#160;    (void)NewSI;</div><div class="line"><a name="l02261"></a><span class="lineno"> 2261</span>&#160;    Pass.DeadInsts.insert(&amp;SI);</div><div class="line"><a name="l02262"></a><span class="lineno"> 2262</span>&#160;    deleteIfTriviallyDead(OldOp);</div><div class="line"><a name="l02263"></a><span class="lineno"> 2263</span>&#160;</div><div class="line"><a name="l02264"></a><span class="lineno"> 2264</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;          to: &quot;</span> &lt;&lt; *NewSI &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02265"></a><span class="lineno"> 2265</span>&#160;    <span class="keywordflow">return</span> NewSI-&gt;<a class="code" href="classllvm_1_1StoreInst.html#ac03c1c093059ea000216af8dd6f2dbf4">getPointerOperand</a>() == &amp;NewAI &amp;&amp; !SI.<a class="code" href="classllvm_1_1StoreInst.html#a89471513a05fad4bbef69ec411b2586d">isVolatile</a>();</div><div class="line"><a name="l02266"></a><span class="lineno"> 2266</span>&#160;  }</div><div class="line"><a name="l02267"></a><span class="lineno"> 2267</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02268"></a><span class="lineno"> 2268</span>&#160;<span class="comment">  /// \brief Compute an integer value from splatting an i8 across the given</span></div><div class="line"><a name="l02269"></a><span class="lineno"> 2269</span>&#160;<span class="comment">  /// number of bytes.</span></div><div class="line"><a name="l02270"></a><span class="lineno"> 2270</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l02271"></a><span class="lineno"> 2271</span>&#160;<span class="comment">  /// Note that this routine assumes an i8 is a byte. If that isn&#39;t true, don&#39;t</span></div><div class="line"><a name="l02272"></a><span class="lineno"> 2272</span>&#160;<span class="comment">  /// call this routine.</span></div><div class="line"><a name="l02273"></a><span class="lineno"> 2273</span>&#160;<span class="comment">  /// FIXME: Heed the advice above.</span></div><div class="line"><a name="l02274"></a><span class="lineno"> 2274</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l02275"></a><span class="lineno"> 2275</span>&#160;<span class="comment">  /// \param V The i8 value to splat.</span></div><div class="line"><a name="l02276"></a><span class="lineno"> 2276</span>&#160;<span class="comment">  /// \param Size The number of bytes in the output (assuming i8 is one byte)</span></div><div class="line"><a name="l02277"></a><span class="lineno"> 2277</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1Value.html">Value</a> *getIntegerSplat(<a class="code" href="classllvm_1_1Value.html">Value</a> *V, <span class="keywordtype">unsigned</span> Size) {</div><div class="line"><a name="l02278"></a><span class="lineno"> 2278</span>&#160;    assert(Size &gt; 0 &amp;&amp; <span class="stringliteral">&quot;Expected a positive number of bytes.&quot;</span>);</div><div class="line"><a name="l02279"></a><span class="lineno"> 2279</span>&#160;    <a class="code" href="classllvm_1_1IntegerType.html">IntegerType</a> *VTy = cast&lt;IntegerType&gt;(V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>());</div><div class="line"><a name="l02280"></a><span class="lineno"> 2280</span>&#160;    assert(VTy-&gt;<a class="code" href="classllvm_1_1IntegerType.html#a6f603ab84f6f7c79985036f58cca9d48">getBitWidth</a>() == 8 &amp;&amp; <span class="stringliteral">&quot;Expected an i8 value for the byte&quot;</span>);</div><div class="line"><a name="l02281"></a><span class="lineno"> 2281</span>&#160;    <span class="keywordflow">if</span> (Size == 1)</div><div class="line"><a name="l02282"></a><span class="lineno"> 2282</span>&#160;      <span class="keywordflow">return</span> V;</div><div class="line"><a name="l02283"></a><span class="lineno"> 2283</span>&#160;</div><div class="line"><a name="l02284"></a><span class="lineno"> 2284</span>&#160;    <a class="code" href="classllvm_1_1Type.html">Type</a> *SplatIntTy = <a class="code" href="classllvm_1_1Type.html#acaf8e4c3e40e01e848c1fad5f05b81cd">Type::getIntNTy</a>(VTy-&gt;<a class="code" href="classllvm_1_1Type.html#af348d5ea83429d08ba891ca3dd0e92b2">getContext</a>(), Size*8);</div><div class="line"><a name="l02285"></a><span class="lineno"> 2285</span>&#160;    V = IRB.CreateMul(IRB.CreateZExt(V, SplatIntTy, <span class="stringliteral">&quot;zext&quot;</span>),</div><div class="line"><a name="l02286"></a><span class="lineno"> 2286</span>&#160;                      <a class="code" href="classllvm_1_1ConstantExpr.html#ab2767c28bc3ded2d683a93f0ce1ed502">ConstantExpr::getUDiv</a>(</div><div class="line"><a name="l02287"></a><span class="lineno"> 2287</span>&#160;                        <a class="code" href="classllvm_1_1Constant.html#a4d51384de6e1798bb6aa875aebeea9f0">Constant::getAllOnesValue</a>(SplatIntTy),</div><div class="line"><a name="l02288"></a><span class="lineno"> 2288</span>&#160;                        <a class="code" href="classllvm_1_1ConstantExpr.html#a80e82791d4d7f4d1d23d68ca0a2b1f64">ConstantExpr::getZExt</a>(</div><div class="line"><a name="l02289"></a><span class="lineno"> 2289</span>&#160;                          <a class="code" href="classllvm_1_1Constant.html#a4d51384de6e1798bb6aa875aebeea9f0">Constant::getAllOnesValue</a>(V-&gt;getType()),</div><div class="line"><a name="l02290"></a><span class="lineno"> 2290</span>&#160;                          SplatIntTy)),</div><div class="line"><a name="l02291"></a><span class="lineno"> 2291</span>&#160;                      <span class="stringliteral">&quot;isplat&quot;</span>);</div><div class="line"><a name="l02292"></a><span class="lineno"> 2292</span>&#160;    <span class="keywordflow">return</span> V;</div><div class="line"><a name="l02293"></a><span class="lineno"> 2293</span>&#160;  }</div><div class="line"><a name="l02294"></a><span class="lineno"> 2294</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02295"></a><span class="lineno"> 2295</span>&#160;<span class="comment">  /// \brief Compute a vector splat for a given element value.</span></div><div class="line"><a name="l02296"></a><span class="lineno"> 2296</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1Value.html">Value</a> *getVectorSplat(<a class="code" href="classllvm_1_1Value.html">Value</a> *V, <span class="keywordtype">unsigned</span> NumElements) {</div><div class="line"><a name="l02297"></a><span class="lineno"> 2297</span>&#160;    V = IRB.CreateVectorSplat(NumElements, V, <span class="stringliteral">&quot;vsplat&quot;</span>);</div><div class="line"><a name="l02298"></a><span class="lineno"> 2298</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;       splat: &quot;</span> &lt;&lt; *V &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02299"></a><span class="lineno"> 2299</span>&#160;    <span class="keywordflow">return</span> V;</div><div class="line"><a name="l02300"></a><span class="lineno"> 2300</span>&#160;  }</div><div class="line"><a name="l02301"></a><span class="lineno"> 2301</span>&#160;</div><div class="line"><a name="l02302"></a><span class="lineno"> 2302</span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1InstVisitor.html#ad401dce38c15719e37382c854618dd15">visitMemSetInst</a>(<a class="code" href="classllvm_1_1MemSetInst.html">MemSetInst</a> &amp;II) {</div><div class="line"><a name="l02303"></a><span class="lineno"> 2303</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;    original: &quot;</span> &lt;&lt; II &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02304"></a><span class="lineno"> 2304</span>&#160;    assert(II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a3ec0c47a5532e568d54c8d452dfb58df">getRawDest</a>() == OldPtr);</div><div class="line"><a name="l02305"></a><span class="lineno"> 2305</span>&#160;</div><div class="line"><a name="l02306"></a><span class="lineno"> 2306</span>&#160;    <span class="comment">// If the memset has a variable size, it cannot be split, just adjust the</span></div><div class="line"><a name="l02307"></a><span class="lineno"> 2307</span>&#160;    <span class="comment">// pointer to the new alloca.</span></div><div class="line"><a name="l02308"></a><span class="lineno"> 2308</span>&#160;    <span class="keywordflow">if</span> (!isa&lt;Constant&gt;(II.<a class="code" href="classllvm_1_1MemIntrinsic.html#abad10f74789466601c7a025540c1c072">getLength</a>())) {</div><div class="line"><a name="l02309"></a><span class="lineno"> 2309</span>&#160;      assert(!IsSplit);</div><div class="line"><a name="l02310"></a><span class="lineno"> 2310</span>&#160;      assert(BeginOffset &gt;= NewAllocaBeginOffset);</div><div class="line"><a name="l02311"></a><span class="lineno"> 2311</span>&#160;      II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a3bca2c8dcf6ef46eff601e8738b2d3b0">setDest</a>(</div><div class="line"><a name="l02312"></a><span class="lineno"> 2312</span>&#160;          getAdjustedAllocaPtr(IRB, BeginOffset, II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a3ec0c47a5532e568d54c8d452dfb58df">getRawDest</a>()-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()));</div><div class="line"><a name="l02313"></a><span class="lineno"> 2313</span>&#160;      <a class="code" href="classllvm_1_1Type.html">Type</a> *CstTy = II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a5938120897cc6e41505886618fe2748d">getAlignmentCst</a>()-&gt;<a class="code" href="classllvm_1_1ConstantInt.html#a240475f85dea79ec272c578fdf89acf1">getType</a>();</div><div class="line"><a name="l02314"></a><span class="lineno"> 2314</span>&#160;      II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a2dc2a7867d2c559ae17261d3f595f0d9">setAlignment</a>(<a class="code" href="classllvm_1_1ConstantInt.html#a9105541412dab869e18b3cceebfff07d">ConstantInt::get</a>(CstTy, getOffsetAlign(BeginOffset)));</div><div class="line"><a name="l02315"></a><span class="lineno"> 2315</span>&#160;</div><div class="line"><a name="l02316"></a><span class="lineno"> 2316</span>&#160;      deleteIfTriviallyDead(OldPtr);</div><div class="line"><a name="l02317"></a><span class="lineno"> 2317</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l02318"></a><span class="lineno"> 2318</span>&#160;    }</div><div class="line"><a name="l02319"></a><span class="lineno"> 2319</span>&#160;</div><div class="line"><a name="l02320"></a><span class="lineno"> 2320</span>&#160;    <span class="comment">// Record this instruction for deletion.</span></div><div class="line"><a name="l02321"></a><span class="lineno"> 2321</span>&#160;    Pass.DeadInsts.insert(&amp;II);</div><div class="line"><a name="l02322"></a><span class="lineno"> 2322</span>&#160;</div><div class="line"><a name="l02323"></a><span class="lineno"> 2323</span>&#160;    <a class="code" href="classllvm_1_1Type.html">Type</a> *AllocaTy = NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#a214c60dbb4f1ed467e5a3420db6eefd6">getAllocatedType</a>();</div><div class="line"><a name="l02324"></a><span class="lineno"> 2324</span>&#160;    <a class="code" href="classllvm_1_1Type.html">Type</a> *ScalarTy = AllocaTy-&gt;<a class="code" href="classllvm_1_1Type.html#a8eafa71cf399da8f21b2af5549f3f9e7">getScalarType</a>();</div><div class="line"><a name="l02325"></a><span class="lineno"> 2325</span>&#160;</div><div class="line"><a name="l02326"></a><span class="lineno"> 2326</span>&#160;    <span class="comment">// Compute the intersecting offset range.</span></div><div class="line"><a name="l02327"></a><span class="lineno"> 2327</span>&#160;    assert(BeginOffset &lt; NewAllocaEndOffset);</div><div class="line"><a name="l02328"></a><span class="lineno"> 2328</span>&#160;    assert(EndOffset &gt; NewAllocaBeginOffset);</div><div class="line"><a name="l02329"></a><span class="lineno"> 2329</span>&#160;    uint64_t NewBeginOffset = std::max(BeginOffset, NewAllocaBeginOffset);</div><div class="line"><a name="l02330"></a><span class="lineno"> 2330</span>&#160;    uint64_t NewEndOffset = std::min(EndOffset, NewAllocaEndOffset);</div><div class="line"><a name="l02331"></a><span class="lineno"> 2331</span>&#160;    uint64_t SliceOffset = NewBeginOffset - NewAllocaBeginOffset;</div><div class="line"><a name="l02332"></a><span class="lineno"> 2332</span>&#160;</div><div class="line"><a name="l02333"></a><span class="lineno"> 2333</span>&#160;    <span class="comment">// If this doesn&#39;t map cleanly onto the alloca type, and that type isn&#39;t</span></div><div class="line"><a name="l02334"></a><span class="lineno"> 2334</span>&#160;    <span class="comment">// a single value type, just emit a memset.</span></div><div class="line"><a name="l02335"></a><span class="lineno"> 2335</span>&#160;    <span class="keywordflow">if</span> (!VecTy &amp;&amp; !IntTy &amp;&amp;</div><div class="line"><a name="l02336"></a><span class="lineno"> 2336</span>&#160;        (BeginOffset &gt; NewAllocaBeginOffset ||</div><div class="line"><a name="l02337"></a><span class="lineno"> 2337</span>&#160;         EndOffset &lt; NewAllocaEndOffset ||</div><div class="line"><a name="l02338"></a><span class="lineno"> 2338</span>&#160;         !AllocaTy-&gt;<a class="code" href="classllvm_1_1Type.html#a36e21267fe14e69d3251eab1cd3a0076">isSingleValueType</a>() ||</div><div class="line"><a name="l02339"></a><span class="lineno"> 2339</span>&#160;         !DL.<a class="code" href="classllvm_1_1DataLayout.html#a96f1e9abd65fef355bd8f15f9360c871">isLegalInteger</a>(DL.<a class="code" href="classllvm_1_1DataLayout.html#add914112e0b2935dda06ad5dfd3a31db">getTypeSizeInBits</a>(ScalarTy)) ||</div><div class="line"><a name="l02340"></a><span class="lineno"> 2340</span>&#160;         DL.<a class="code" href="classllvm_1_1DataLayout.html#add914112e0b2935dda06ad5dfd3a31db">getTypeSizeInBits</a>(ScalarTy)%8 != 0)) {</div><div class="line"><a name="l02341"></a><span class="lineno"> 2341</span>&#160;      <a class="code" href="classllvm_1_1Type.html">Type</a> *SizeTy = II.<a class="code" href="classllvm_1_1MemIntrinsic.html#abad10f74789466601c7a025540c1c072">getLength</a>()-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>();</div><div class="line"><a name="l02342"></a><span class="lineno"> 2342</span>&#160;      <a class="code" href="classllvm_1_1Constant.html">Constant</a> *Size = <a class="code" href="classllvm_1_1ConstantInt.html#a9105541412dab869e18b3cceebfff07d">ConstantInt::get</a>(SizeTy, NewEndOffset - NewBeginOffset);</div><div class="line"><a name="l02343"></a><span class="lineno"> 2343</span>&#160;      <a class="code" href="classllvm_1_1CallInst.html">CallInst</a> *New = IRB.CreateMemSet(</div><div class="line"><a name="l02344"></a><span class="lineno"> 2344</span>&#160;          getAdjustedAllocaPtr(IRB, NewBeginOffset, II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a3ec0c47a5532e568d54c8d452dfb58df">getRawDest</a>()-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()),</div><div class="line"><a name="l02345"></a><span class="lineno"> 2345</span>&#160;          II.<a class="code" href="classllvm_1_1MemSetInst.html#a357f35c4ac1c01e84d73a4a9e26f6aac">getValue</a>(), Size, getOffsetAlign(SliceOffset), II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a9558faebdbb62c072aed98e33604889d">isVolatile</a>());</div><div class="line"><a name="l02346"></a><span class="lineno"> 2346</span>&#160;      (void)New;</div><div class="line"><a name="l02347"></a><span class="lineno"> 2347</span>&#160;      <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;          to: &quot;</span> &lt;&lt; *New &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02348"></a><span class="lineno"> 2348</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l02349"></a><span class="lineno"> 2349</span>&#160;    }</div><div class="line"><a name="l02350"></a><span class="lineno"> 2350</span>&#160;</div><div class="line"><a name="l02351"></a><span class="lineno"> 2351</span>&#160;    <span class="comment">// If we can represent this as a simple value, we have to build the actual</span></div><div class="line"><a name="l02352"></a><span class="lineno"> 2352</span>&#160;    <span class="comment">// value to store, which requires expanding the byte present in memset to</span></div><div class="line"><a name="l02353"></a><span class="lineno"> 2353</span>&#160;    <span class="comment">// a sensible representation for the alloca type. This is essentially</span></div><div class="line"><a name="l02354"></a><span class="lineno"> 2354</span>&#160;    <span class="comment">// splatting the byte to a sufficiently wide integer, splatting it across</span></div><div class="line"><a name="l02355"></a><span class="lineno"> 2355</span>&#160;    <span class="comment">// any desired vector width, and bitcasting to the final type.</span></div><div class="line"><a name="l02356"></a><span class="lineno"> 2356</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *V;</div><div class="line"><a name="l02357"></a><span class="lineno"> 2357</span>&#160;</div><div class="line"><a name="l02358"></a><span class="lineno"> 2358</span>&#160;    <span class="keywordflow">if</span> (VecTy) {</div><div class="line"><a name="l02359"></a><span class="lineno"> 2359</span>&#160;      <span class="comment">// If this is a memset of a vectorized alloca, insert it.</span></div><div class="line"><a name="l02360"></a><span class="lineno"> 2360</span>&#160;      assert(ElementTy == ScalarTy);</div><div class="line"><a name="l02361"></a><span class="lineno"> 2361</span>&#160;</div><div class="line"><a name="l02362"></a><span class="lineno"> 2362</span>&#160;      <span class="keywordtype">unsigned</span> BeginIndex = getIndex(NewBeginOffset);</div><div class="line"><a name="l02363"></a><span class="lineno"> 2363</span>&#160;      <span class="keywordtype">unsigned</span> EndIndex = getIndex(NewEndOffset);</div><div class="line"><a name="l02364"></a><span class="lineno"> 2364</span>&#160;      assert(EndIndex &gt; BeginIndex &amp;&amp; <span class="stringliteral">&quot;Empty vector!&quot;</span>);</div><div class="line"><a name="l02365"></a><span class="lineno"> 2365</span>&#160;      <span class="keywordtype">unsigned</span> NumElements = EndIndex - BeginIndex;</div><div class="line"><a name="l02366"></a><span class="lineno"> 2366</span>&#160;      assert(NumElements &lt;= VecTy-&gt;getNumElements() &amp;&amp; <span class="stringliteral">&quot;Too many elements!&quot;</span>);</div><div class="line"><a name="l02367"></a><span class="lineno"> 2367</span>&#160;</div><div class="line"><a name="l02368"></a><span class="lineno"> 2368</span>&#160;      <a class="code" href="classllvm_1_1Value.html">Value</a> *Splat =</div><div class="line"><a name="l02369"></a><span class="lineno"> 2369</span>&#160;          getIntegerSplat(II.<a class="code" href="classllvm_1_1MemSetInst.html#a357f35c4ac1c01e84d73a4a9e26f6aac">getValue</a>(), DL.<a class="code" href="classllvm_1_1DataLayout.html#add914112e0b2935dda06ad5dfd3a31db">getTypeSizeInBits</a>(ElementTy) / 8);</div><div class="line"><a name="l02370"></a><span class="lineno"> 2370</span>&#160;      Splat = <a class="code" href="SROA_8cpp.html#a7d6146d9a22768498097b2c53cd2234f">convertValue</a>(DL, IRB, Splat, ElementTy);</div><div class="line"><a name="l02371"></a><span class="lineno"> 2371</span>&#160;      <span class="keywordflow">if</span> (NumElements &gt; 1)</div><div class="line"><a name="l02372"></a><span class="lineno"> 2372</span>&#160;        Splat = getVectorSplat(Splat, NumElements);</div><div class="line"><a name="l02373"></a><span class="lineno"> 2373</span>&#160;</div><div class="line"><a name="l02374"></a><span class="lineno"> 2374</span>&#160;      <a class="code" href="classllvm_1_1Value.html">Value</a> *Old = IRB.CreateAlignedLoad(&amp;NewAI, NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">getAlignment</a>(),</div><div class="line"><a name="l02375"></a><span class="lineno"> 2375</span>&#160;                                         <span class="stringliteral">&quot;oldload&quot;</span>);</div><div class="line"><a name="l02376"></a><span class="lineno"> 2376</span>&#160;      V = <a class="code" href="SROA_8cpp.html#a42c6a2faff923f431932c6d33cf4092b">insertVector</a>(IRB, Old, Splat, BeginIndex, <span class="stringliteral">&quot;vec&quot;</span>);</div><div class="line"><a name="l02377"></a><span class="lineno"> 2377</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IntTy) {</div><div class="line"><a name="l02378"></a><span class="lineno"> 2378</span>&#160;      <span class="comment">// If this is a memset on an alloca where we can widen stores, insert the</span></div><div class="line"><a name="l02379"></a><span class="lineno"> 2379</span>&#160;      <span class="comment">// set integer.</span></div><div class="line"><a name="l02380"></a><span class="lineno"> 2380</span>&#160;      assert(!II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a9558faebdbb62c072aed98e33604889d">isVolatile</a>());</div><div class="line"><a name="l02381"></a><span class="lineno"> 2381</span>&#160;</div><div class="line"><a name="l02382"></a><span class="lineno"> 2382</span>&#160;      uint64_t Size = NewEndOffset - NewBeginOffset;</div><div class="line"><a name="l02383"></a><span class="lineno"> 2383</span>&#160;      V = getIntegerSplat(II.<a class="code" href="classllvm_1_1MemSetInst.html#a357f35c4ac1c01e84d73a4a9e26f6aac">getValue</a>(), Size);</div><div class="line"><a name="l02384"></a><span class="lineno"> 2384</span>&#160;</div><div class="line"><a name="l02385"></a><span class="lineno"> 2385</span>&#160;      <span class="keywordflow">if</span> (IntTy &amp;&amp; (BeginOffset != NewAllocaBeginOffset ||</div><div class="line"><a name="l02386"></a><span class="lineno"> 2386</span>&#160;                    EndOffset != NewAllocaBeginOffset)) {</div><div class="line"><a name="l02387"></a><span class="lineno"> 2387</span>&#160;        <a class="code" href="classllvm_1_1Value.html">Value</a> *Old = IRB.CreateAlignedLoad(&amp;NewAI, NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">getAlignment</a>(),</div><div class="line"><a name="l02388"></a><span class="lineno"> 2388</span>&#160;                                           <span class="stringliteral">&quot;oldload&quot;</span>);</div><div class="line"><a name="l02389"></a><span class="lineno"> 2389</span>&#160;        Old = <a class="code" href="SROA_8cpp.html#a7d6146d9a22768498097b2c53cd2234f">convertValue</a>(DL, IRB, Old, IntTy);</div><div class="line"><a name="l02390"></a><span class="lineno"> 2390</span>&#160;        uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</div><div class="line"><a name="l02391"></a><span class="lineno"> 2391</span>&#160;        V = <a class="code" href="SROA_8cpp.html#a7febebe786555d6e0d07ca0f86e294c1">insertInteger</a>(DL, IRB, Old, V, Offset, <span class="stringliteral">&quot;insert&quot;</span>);</div><div class="line"><a name="l02392"></a><span class="lineno"> 2392</span>&#160;      } <span class="keywordflow">else</span> {</div><div class="line"><a name="l02393"></a><span class="lineno"> 2393</span>&#160;        assert(V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>() == IntTy &amp;&amp;</div><div class="line"><a name="l02394"></a><span class="lineno"> 2394</span>&#160;               <span class="stringliteral">&quot;Wrong type for an alloca wide integer!&quot;</span>);</div><div class="line"><a name="l02395"></a><span class="lineno"> 2395</span>&#160;      }</div><div class="line"><a name="l02396"></a><span class="lineno"> 2396</span>&#160;      V = <a class="code" href="SROA_8cpp.html#a7d6146d9a22768498097b2c53cd2234f">convertValue</a>(DL, IRB, V, AllocaTy);</div><div class="line"><a name="l02397"></a><span class="lineno"> 2397</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l02398"></a><span class="lineno"> 2398</span>&#160;      <span class="comment">// Established these invariants above.</span></div><div class="line"><a name="l02399"></a><span class="lineno"> 2399</span>&#160;      assert(NewBeginOffset == NewAllocaBeginOffset);</div><div class="line"><a name="l02400"></a><span class="lineno"> 2400</span>&#160;      assert(NewEndOffset == NewAllocaEndOffset);</div><div class="line"><a name="l02401"></a><span class="lineno"> 2401</span>&#160;</div><div class="line"><a name="l02402"></a><span class="lineno"> 2402</span>&#160;      V = getIntegerSplat(II.<a class="code" href="classllvm_1_1MemSetInst.html#a357f35c4ac1c01e84d73a4a9e26f6aac">getValue</a>(), DL.<a class="code" href="classllvm_1_1DataLayout.html#add914112e0b2935dda06ad5dfd3a31db">getTypeSizeInBits</a>(ScalarTy) / 8);</div><div class="line"><a name="l02403"></a><span class="lineno"> 2403</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1VectorType.html">VectorType</a> *AllocaVecTy = dyn_cast&lt;VectorType&gt;(AllocaTy))</div><div class="line"><a name="l02404"></a><span class="lineno"> 2404</span>&#160;        V = getVectorSplat(V, AllocaVecTy-&gt;getNumElements());</div><div class="line"><a name="l02405"></a><span class="lineno"> 2405</span>&#160;</div><div class="line"><a name="l02406"></a><span class="lineno"> 2406</span>&#160;      V = <a class="code" href="SROA_8cpp.html#a7d6146d9a22768498097b2c53cd2234f">convertValue</a>(DL, IRB, V, AllocaTy);</div><div class="line"><a name="l02407"></a><span class="lineno"> 2407</span>&#160;    }</div><div class="line"><a name="l02408"></a><span class="lineno"> 2408</span>&#160;</div><div class="line"><a name="l02409"></a><span class="lineno"> 2409</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *New = IRB.CreateAlignedStore(V, &amp;NewAI, NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">getAlignment</a>(),</div><div class="line"><a name="l02410"></a><span class="lineno"> 2410</span>&#160;                                        II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a9558faebdbb62c072aed98e33604889d">isVolatile</a>());</div><div class="line"><a name="l02411"></a><span class="lineno"> 2411</span>&#160;    (void)New;</div><div class="line"><a name="l02412"></a><span class="lineno"> 2412</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;          to: &quot;</span> &lt;&lt; *New &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02413"></a><span class="lineno"> 2413</span>&#160;    <span class="keywordflow">return</span> !II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a9558faebdbb62c072aed98e33604889d">isVolatile</a>();</div><div class="line"><a name="l02414"></a><span class="lineno"> 2414</span>&#160;  }</div><div class="line"><a name="l02415"></a><span class="lineno"> 2415</span>&#160;</div><div class="line"><a name="l02416"></a><span class="lineno"> 2416</span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1InstVisitor.html#acaad755824bda1ce0066749c8655d3df">visitMemTransferInst</a>(<a class="code" href="classllvm_1_1MemTransferInst.html">MemTransferInst</a> &amp;II) {</div><div class="line"><a name="l02417"></a><span class="lineno"> 2417</span>&#160;    <span class="comment">// Rewriting of memory transfer instructions can be a bit tricky. We break</span></div><div class="line"><a name="l02418"></a><span class="lineno"> 2418</span>&#160;    <span class="comment">// them into two categories: split intrinsics and unsplit intrinsics.</span></div><div class="line"><a name="l02419"></a><span class="lineno"> 2419</span>&#160;</div><div class="line"><a name="l02420"></a><span class="lineno"> 2420</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;    original: &quot;</span> &lt;&lt; II &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02421"></a><span class="lineno"> 2421</span>&#160;</div><div class="line"><a name="l02422"></a><span class="lineno"> 2422</span>&#160;    <span class="comment">// Compute the intersecting offset range.</span></div><div class="line"><a name="l02423"></a><span class="lineno"> 2423</span>&#160;    assert(BeginOffset &lt; NewAllocaEndOffset);</div><div class="line"><a name="l02424"></a><span class="lineno"> 2424</span>&#160;    assert(EndOffset &gt; NewAllocaBeginOffset);</div><div class="line"><a name="l02425"></a><span class="lineno"> 2425</span>&#160;    uint64_t NewBeginOffset = std::max(BeginOffset, NewAllocaBeginOffset);</div><div class="line"><a name="l02426"></a><span class="lineno"> 2426</span>&#160;    uint64_t NewEndOffset = std::min(EndOffset, NewAllocaEndOffset);</div><div class="line"><a name="l02427"></a><span class="lineno"> 2427</span>&#160;</div><div class="line"><a name="l02428"></a><span class="lineno"> 2428</span>&#160;    assert(II.<a class="code" href="classllvm_1_1MemTransferInst.html#a26bfca1607622229a625f2db73aed2ba">getRawSource</a>() == OldPtr || II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a3ec0c47a5532e568d54c8d452dfb58df">getRawDest</a>() == OldPtr);</div><div class="line"><a name="l02429"></a><span class="lineno"> 2429</span>&#160;    <span class="keywordtype">bool</span> IsDest = II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a3ec0c47a5532e568d54c8d452dfb58df">getRawDest</a>() == OldPtr;</div><div class="line"><a name="l02430"></a><span class="lineno"> 2430</span>&#160;</div><div class="line"><a name="l02431"></a><span class="lineno"> 2431</span>&#160;    <span class="comment">// Compute the relative offset within the transfer.</span></div><div class="line"><a name="l02432"></a><span class="lineno"> 2432</span>&#160;    <span class="keywordtype">unsigned</span> IntPtrWidth = DL.<a class="code" href="classllvm_1_1DataLayout.html#a9cb015699ac01dfa6ebb3cc4ce5a6a93">getPointerSizeInBits</a>();</div><div class="line"><a name="l02433"></a><span class="lineno"> 2433</span>&#160;    <a class="code" href="classllvm_1_1APInt.html">APInt</a> RelOffset(IntPtrWidth, NewBeginOffset - BeginOffset);</div><div class="line"><a name="l02434"></a><span class="lineno"> 2434</span>&#160;</div><div class="line"><a name="l02435"></a><span class="lineno"> 2435</span>&#160;    <span class="keywordtype">unsigned</span> <a class="code" href="ARMSubtarget_8cpp.html#a4bd80d4e433d9f72af26b364036900dc">Align</a> = II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a42dd65db3521498f10afb8c6f66e1bb5">getAlignment</a>();</div><div class="line"><a name="l02436"></a><span class="lineno"> 2436</span>&#160;    uint64_t SliceOffset = NewBeginOffset - NewAllocaBeginOffset;</div><div class="line"><a name="l02437"></a><span class="lineno"> 2437</span>&#160;    <span class="keywordflow">if</span> (Align &gt; 1)</div><div class="line"><a name="l02438"></a><span class="lineno"> 2438</span>&#160;      Align =</div><div class="line"><a name="l02439"></a><span class="lineno"> 2439</span>&#160;          <a class="code" href="namespacellvm.html#af36d7e69ab16b64b2e3a48c83aa9f0f6">MinAlign</a>(RelOffset.<a class="code" href="classllvm_1_1APInt.html#a7fe47410bb825eccb20f010dab13c72f">zextOrTrunc</a>(64).<a class="code" href="classllvm_1_1APInt.html#a7dc983ebf0eb2d255fa90a67063c72e2">getZExtValue</a>(),</div><div class="line"><a name="l02440"></a><span class="lineno"> 2440</span>&#160;                   <a class="code" href="namespacellvm.html#af36d7e69ab16b64b2e3a48c83aa9f0f6">MinAlign</a>(II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a42dd65db3521498f10afb8c6f66e1bb5">getAlignment</a>(), getOffsetAlign(SliceOffset)));</div><div class="line"><a name="l02441"></a><span class="lineno"> 2441</span>&#160;</div><div class="line"><a name="l02442"></a><span class="lineno"> 2442</span>&#160;    <span class="comment">// For unsplit intrinsics, we simply modify the source and destination</span></div><div class="line"><a name="l02443"></a><span class="lineno"> 2443</span>&#160;    <span class="comment">// pointers in place. This isn&#39;t just an optimization, it is a matter of</span></div><div class="line"><a name="l02444"></a><span class="lineno"> 2444</span>&#160;    <span class="comment">// correctness. With unsplit intrinsics we may be dealing with transfers</span></div><div class="line"><a name="l02445"></a><span class="lineno"> 2445</span>&#160;    <span class="comment">// within a single alloca before SROA ran, or with transfers that have</span></div><div class="line"><a name="l02446"></a><span class="lineno"> 2446</span>&#160;    <span class="comment">// a variable length. We may also be dealing with memmove instead of</span></div><div class="line"><a name="l02447"></a><span class="lineno"> 2447</span>&#160;    <span class="comment">// memcpy, and so simply updating the pointers is the necessary for us to</span></div><div class="line"><a name="l02448"></a><span class="lineno"> 2448</span>&#160;    <span class="comment">// update both source and dest of a single call.</span></div><div class="line"><a name="l02449"></a><span class="lineno"> 2449</span>&#160;    <span class="keywordflow">if</span> (!IsSplittable) {</div><div class="line"><a name="l02450"></a><span class="lineno"> 2450</span>&#160;      <a class="code" href="classllvm_1_1Value.html">Value</a> *OldOp = IsDest ? II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a3ec0c47a5532e568d54c8d452dfb58df">getRawDest</a>() : II.<a class="code" href="classllvm_1_1MemTransferInst.html#a26bfca1607622229a625f2db73aed2ba">getRawSource</a>();</div><div class="line"><a name="l02451"></a><span class="lineno"> 2451</span>&#160;      <span class="keywordflow">if</span> (IsDest)</div><div class="line"><a name="l02452"></a><span class="lineno"> 2452</span>&#160;        II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a3bca2c8dcf6ef46eff601e8738b2d3b0">setDest</a>(</div><div class="line"><a name="l02453"></a><span class="lineno"> 2453</span>&#160;            getAdjustedAllocaPtr(IRB, BeginOffset, II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a3ec0c47a5532e568d54c8d452dfb58df">getRawDest</a>()-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()));</div><div class="line"><a name="l02454"></a><span class="lineno"> 2454</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l02455"></a><span class="lineno"> 2455</span>&#160;        II.<a class="code" href="classllvm_1_1MemTransferInst.html#a94436025d48b34387528b438374c547b">setSource</a>(getAdjustedAllocaPtr(IRB, BeginOffset,</div><div class="line"><a name="l02456"></a><span class="lineno"> 2456</span>&#160;                                          II.<a class="code" href="classllvm_1_1MemTransferInst.html#a26bfca1607622229a625f2db73aed2ba">getRawSource</a>()-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()));</div><div class="line"><a name="l02457"></a><span class="lineno"> 2457</span>&#160;</div><div class="line"><a name="l02458"></a><span class="lineno"> 2458</span>&#160;      <a class="code" href="classllvm_1_1Type.html">Type</a> *CstTy = II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a5938120897cc6e41505886618fe2748d">getAlignmentCst</a>()-&gt;<a class="code" href="classllvm_1_1ConstantInt.html#a240475f85dea79ec272c578fdf89acf1">getType</a>();</div><div class="line"><a name="l02459"></a><span class="lineno"> 2459</span>&#160;      II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a2dc2a7867d2c559ae17261d3f595f0d9">setAlignment</a>(<a class="code" href="classllvm_1_1ConstantInt.html#a9105541412dab869e18b3cceebfff07d">ConstantInt::get</a>(CstTy, Align));</div><div class="line"><a name="l02460"></a><span class="lineno"> 2460</span>&#160;</div><div class="line"><a name="l02461"></a><span class="lineno"> 2461</span>&#160;      <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;          to: &quot;</span> &lt;&lt; II &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02462"></a><span class="lineno"> 2462</span>&#160;      deleteIfTriviallyDead(OldOp);</div><div class="line"><a name="l02463"></a><span class="lineno"> 2463</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l02464"></a><span class="lineno"> 2464</span>&#160;    }</div><div class="line"><a name="l02465"></a><span class="lineno"> 2465</span>&#160;    <span class="comment">// For split transfer intrinsics we have an incredibly useful assurance:</span></div><div class="line"><a name="l02466"></a><span class="lineno"> 2466</span>&#160;    <span class="comment">// the source and destination do not reside within the same alloca, and at</span></div><div class="line"><a name="l02467"></a><span class="lineno"> 2467</span>&#160;    <span class="comment">// least one of them does not escape. This means that we can replace</span></div><div class="line"><a name="l02468"></a><span class="lineno"> 2468</span>&#160;    <span class="comment">// memmove with memcpy, and we don&#39;t need to worry about all manner of</span></div><div class="line"><a name="l02469"></a><span class="lineno"> 2469</span>&#160;    <span class="comment">// downsides to splitting and transforming the operations.</span></div><div class="line"><a name="l02470"></a><span class="lineno"> 2470</span>&#160;</div><div class="line"><a name="l02471"></a><span class="lineno"> 2471</span>&#160;    <span class="comment">// If this doesn&#39;t map cleanly onto the alloca type, and that type isn&#39;t</span></div><div class="line"><a name="l02472"></a><span class="lineno"> 2472</span>&#160;    <span class="comment">// a single value type, just emit a memcpy.</span></div><div class="line"><a name="l02473"></a><span class="lineno"> 2473</span>&#160;    <span class="keywordtype">bool</span> EmitMemCpy</div><div class="line"><a name="l02474"></a><span class="lineno"> 2474</span>&#160;      = !VecTy &amp;&amp; !IntTy &amp;&amp; (BeginOffset &gt; NewAllocaBeginOffset ||</div><div class="line"><a name="l02475"></a><span class="lineno"> 2475</span>&#160;                             EndOffset &lt; NewAllocaEndOffset ||</div><div class="line"><a name="l02476"></a><span class="lineno"> 2476</span>&#160;                             !NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#a214c60dbb4f1ed467e5a3420db6eefd6">getAllocatedType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a36e21267fe14e69d3251eab1cd3a0076">isSingleValueType</a>());</div><div class="line"><a name="l02477"></a><span class="lineno"> 2477</span>&#160;</div><div class="line"><a name="l02478"></a><span class="lineno"> 2478</span>&#160;    <span class="comment">// If we&#39;re just going to emit a memcpy, the alloca hasn&#39;t changed, and the</span></div><div class="line"><a name="l02479"></a><span class="lineno"> 2479</span>&#160;    <span class="comment">// size hasn&#39;t been shrunk based on analysis of the viable range, this is</span></div><div class="line"><a name="l02480"></a><span class="lineno"> 2480</span>&#160;    <span class="comment">// a no-op.</span></div><div class="line"><a name="l02481"></a><span class="lineno"> 2481</span>&#160;    <span class="keywordflow">if</span> (EmitMemCpy &amp;&amp; &amp;OldAI == &amp;NewAI) {</div><div class="line"><a name="l02482"></a><span class="lineno"> 2482</span>&#160;      <span class="comment">// Ensure the start lines up.</span></div><div class="line"><a name="l02483"></a><span class="lineno"> 2483</span>&#160;      assert(NewBeginOffset == BeginOffset);</div><div class="line"><a name="l02484"></a><span class="lineno"> 2484</span>&#160;</div><div class="line"><a name="l02485"></a><span class="lineno"> 2485</span>&#160;      <span class="comment">// Rewrite the size as needed.</span></div><div class="line"><a name="l02486"></a><span class="lineno"> 2486</span>&#160;      <span class="keywordflow">if</span> (NewEndOffset != EndOffset)</div><div class="line"><a name="l02487"></a><span class="lineno"> 2487</span>&#160;        II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a898aa65c5d00f6073df71f3dd709a84d">setLength</a>(<a class="code" href="classllvm_1_1ConstantInt.html#a9105541412dab869e18b3cceebfff07d">ConstantInt::get</a>(II.<a class="code" href="classllvm_1_1MemIntrinsic.html#abad10f74789466601c7a025540c1c072">getLength</a>()-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>(),</div><div class="line"><a name="l02488"></a><span class="lineno"> 2488</span>&#160;                                      NewEndOffset - NewBeginOffset));</div><div class="line"><a name="l02489"></a><span class="lineno"> 2489</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l02490"></a><span class="lineno"> 2490</span>&#160;    }</div><div class="line"><a name="l02491"></a><span class="lineno"> 2491</span>&#160;    <span class="comment">// Record this instruction for deletion.</span></div><div class="line"><a name="l02492"></a><span class="lineno"> 2492</span>&#160;    Pass.DeadInsts.insert(&amp;II);</div><div class="line"><a name="l02493"></a><span class="lineno"> 2493</span>&#160;</div><div class="line"><a name="l02494"></a><span class="lineno"> 2494</span>&#160;    <span class="comment">// Strip all inbounds GEPs and pointer casts to try to dig out any root</span></div><div class="line"><a name="l02495"></a><span class="lineno"> 2495</span>&#160;    <span class="comment">// alloca that should be re-examined after rewriting this instruction.</span></div><div class="line"><a name="l02496"></a><span class="lineno"> 2496</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *OtherPtr = IsDest ? II.<a class="code" href="classllvm_1_1MemTransferInst.html#a26bfca1607622229a625f2db73aed2ba">getRawSource</a>() : II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a3ec0c47a5532e568d54c8d452dfb58df">getRawDest</a>();</div><div class="line"><a name="l02497"></a><span class="lineno"> 2497</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> *AI</div><div class="line"><a name="l02498"></a><span class="lineno"> 2498</span>&#160;          = dyn_cast&lt;AllocaInst&gt;(OtherPtr-&gt;<a class="code" href="classllvm_1_1Value.html#a30fec2a6a53ed66b12318765c8feac13">stripInBoundsOffsets</a>()))</div><div class="line"><a name="l02499"></a><span class="lineno"> 2499</span>&#160;      Pass.Worklist.insert(AI);</div><div class="line"><a name="l02500"></a><span class="lineno"> 2500</span>&#160;</div><div class="line"><a name="l02501"></a><span class="lineno"> 2501</span>&#160;    <span class="keywordflow">if</span> (EmitMemCpy) {</div><div class="line"><a name="l02502"></a><span class="lineno"> 2502</span>&#160;      <a class="code" href="classllvm_1_1Type.html">Type</a> *OtherPtrTy = IsDest ? II.<a class="code" href="classllvm_1_1MemTransferInst.html#a26bfca1607622229a625f2db73aed2ba">getRawSource</a>()-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()</div><div class="line"><a name="l02503"></a><span class="lineno"> 2503</span>&#160;                                : II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a3ec0c47a5532e568d54c8d452dfb58df">getRawDest</a>()-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>();</div><div class="line"><a name="l02504"></a><span class="lineno"> 2504</span>&#160;</div><div class="line"><a name="l02505"></a><span class="lineno"> 2505</span>&#160;      <span class="comment">// Compute the other pointer, folding as much as possible to produce</span></div><div class="line"><a name="l02506"></a><span class="lineno"> 2506</span>&#160;      <span class="comment">// a single, simple GEP in most cases.</span></div><div class="line"><a name="l02507"></a><span class="lineno"> 2507</span>&#160;      OtherPtr = <a class="code" href="SROA_8cpp.html#ab706500bd4aee346f53362dd30531f7f">getAdjustedPtr</a>(IRB, DL, OtherPtr, RelOffset, OtherPtrTy);</div><div class="line"><a name="l02508"></a><span class="lineno"> 2508</span>&#160;</div><div class="line"><a name="l02509"></a><span class="lineno"> 2509</span>&#160;      <a class="code" href="classllvm_1_1Value.html">Value</a> *OurPtr = getAdjustedAllocaPtr(</div><div class="line"><a name="l02510"></a><span class="lineno"> 2510</span>&#160;          IRB, NewBeginOffset,</div><div class="line"><a name="l02511"></a><span class="lineno"> 2511</span>&#160;          IsDest ? II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a3ec0c47a5532e568d54c8d452dfb58df">getRawDest</a>()-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>() : II.<a class="code" href="classllvm_1_1MemTransferInst.html#a26bfca1607622229a625f2db73aed2ba">getRawSource</a>()-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>());</div><div class="line"><a name="l02512"></a><span class="lineno"> 2512</span>&#160;      <a class="code" href="classllvm_1_1Type.html">Type</a> *SizeTy = II.<a class="code" href="classllvm_1_1MemIntrinsic.html#abad10f74789466601c7a025540c1c072">getLength</a>()-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>();</div><div class="line"><a name="l02513"></a><span class="lineno"> 2513</span>&#160;      <a class="code" href="classllvm_1_1Constant.html">Constant</a> *Size = <a class="code" href="classllvm_1_1ConstantInt.html#a9105541412dab869e18b3cceebfff07d">ConstantInt::get</a>(SizeTy, NewEndOffset - NewBeginOffset);</div><div class="line"><a name="l02514"></a><span class="lineno"> 2514</span>&#160;</div><div class="line"><a name="l02515"></a><span class="lineno"> 2515</span>&#160;      <a class="code" href="classllvm_1_1CallInst.html">CallInst</a> *New = IRB.CreateMemCpy(IsDest ? OurPtr : OtherPtr,</div><div class="line"><a name="l02516"></a><span class="lineno"> 2516</span>&#160;                                       IsDest ? OtherPtr : OurPtr,</div><div class="line"><a name="l02517"></a><span class="lineno"> 2517</span>&#160;                                       Size, Align, II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a9558faebdbb62c072aed98e33604889d">isVolatile</a>());</div><div class="line"><a name="l02518"></a><span class="lineno"> 2518</span>&#160;      (void)New;</div><div class="line"><a name="l02519"></a><span class="lineno"> 2519</span>&#160;      <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;          to: &quot;</span> &lt;&lt; *New &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02520"></a><span class="lineno"> 2520</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l02521"></a><span class="lineno"> 2521</span>&#160;    }</div><div class="line"><a name="l02522"></a><span class="lineno"> 2522</span>&#160;</div><div class="line"><a name="l02523"></a><span class="lineno"> 2523</span>&#160;    <span class="comment">// Note that we clamp the alignment to 1 here as a 0 alignment for a memcpy</span></div><div class="line"><a name="l02524"></a><span class="lineno"> 2524</span>&#160;    <span class="comment">// is equivalent to 1, but that isn&#39;t true if we end up rewriting this as</span></div><div class="line"><a name="l02525"></a><span class="lineno"> 2525</span>&#160;    <span class="comment">// a load or store.</span></div><div class="line"><a name="l02526"></a><span class="lineno"> 2526</span>&#160;    <span class="keywordflow">if</span> (!Align)</div><div class="line"><a name="l02527"></a><span class="lineno"> 2527</span>&#160;      Align = 1;</div><div class="line"><a name="l02528"></a><span class="lineno"> 2528</span>&#160;</div><div class="line"><a name="l02529"></a><span class="lineno"> 2529</span>&#160;    <span class="keywordtype">bool</span> IsWholeAlloca = NewBeginOffset == NewAllocaBeginOffset &amp;&amp;</div><div class="line"><a name="l02530"></a><span class="lineno"> 2530</span>&#160;                         NewEndOffset == NewAllocaEndOffset;</div><div class="line"><a name="l02531"></a><span class="lineno"> 2531</span>&#160;    uint64_t Size = NewEndOffset - NewBeginOffset;</div><div class="line"><a name="l02532"></a><span class="lineno"> 2532</span>&#160;    <span class="keywordtype">unsigned</span> BeginIndex = VecTy ? getIndex(NewBeginOffset) : 0;</div><div class="line"><a name="l02533"></a><span class="lineno"> 2533</span>&#160;    <span class="keywordtype">unsigned</span> EndIndex = VecTy ? getIndex(NewEndOffset) : 0;</div><div class="line"><a name="l02534"></a><span class="lineno"> 2534</span>&#160;    <span class="keywordtype">unsigned</span> NumElements = EndIndex - BeginIndex;</div><div class="line"><a name="l02535"></a><span class="lineno"> 2535</span>&#160;    <a class="code" href="classllvm_1_1IntegerType.html">IntegerType</a> *SubIntTy</div><div class="line"><a name="l02536"></a><span class="lineno"> 2536</span>&#160;      = IntTy ? <a class="code" href="classllvm_1_1Type.html#acaf8e4c3e40e01e848c1fad5f05b81cd">Type::getIntNTy</a>(IntTy-&gt;<a class="code" href="classllvm_1_1Type.html#af348d5ea83429d08ba891ca3dd0e92b2">getContext</a>(), Size*8) : 0;</div><div class="line"><a name="l02537"></a><span class="lineno"> 2537</span>&#160;</div><div class="line"><a name="l02538"></a><span class="lineno"> 2538</span>&#160;    <a class="code" href="classllvm_1_1Type.html">Type</a> *OtherPtrTy = NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#a597c918a615f26a0cea7adb84f06fc3f">getType</a>();</div><div class="line"><a name="l02539"></a><span class="lineno"> 2539</span>&#160;    <span class="keywordflow">if</span> (VecTy &amp;&amp; !IsWholeAlloca) {</div><div class="line"><a name="l02540"></a><span class="lineno"> 2540</span>&#160;      <span class="keywordflow">if</span> (NumElements == 1)</div><div class="line"><a name="l02541"></a><span class="lineno"> 2541</span>&#160;        OtherPtrTy = VecTy-&gt;<a class="code" href="classllvm_1_1SequentialType.html#a39f2c3a62f293faf11ac28b15bc53359">getElementType</a>();</div><div class="line"><a name="l02542"></a><span class="lineno"> 2542</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l02543"></a><span class="lineno"> 2543</span>&#160;        OtherPtrTy = <a class="code" href="classllvm_1_1VectorType.html#ab43657ed1abe2e2ed3a6a394f233ebd0">VectorType::get</a>(VecTy-&gt;<a class="code" href="classllvm_1_1SequentialType.html#a39f2c3a62f293faf11ac28b15bc53359">getElementType</a>(), NumElements);</div><div class="line"><a name="l02544"></a><span class="lineno"> 2544</span>&#160;</div><div class="line"><a name="l02545"></a><span class="lineno"> 2545</span>&#160;      OtherPtrTy = OtherPtrTy-&gt;<a class="code" href="classllvm_1_1Type.html#ab6cc070c37c59589af100aab6f48ef4f">getPointerTo</a>();</div><div class="line"><a name="l02546"></a><span class="lineno"> 2546</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IntTy &amp;&amp; !IsWholeAlloca) {</div><div class="line"><a name="l02547"></a><span class="lineno"> 2547</span>&#160;      OtherPtrTy = SubIntTy-&gt;<a class="code" href="classllvm_1_1Type.html#ab6cc070c37c59589af100aab6f48ef4f">getPointerTo</a>();</div><div class="line"><a name="l02548"></a><span class="lineno"> 2548</span>&#160;    }</div><div class="line"><a name="l02549"></a><span class="lineno"> 2549</span>&#160;</div><div class="line"><a name="l02550"></a><span class="lineno"> 2550</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *SrcPtr = <a class="code" href="SROA_8cpp.html#ab706500bd4aee346f53362dd30531f7f">getAdjustedPtr</a>(IRB, DL, OtherPtr, RelOffset, OtherPtrTy);</div><div class="line"><a name="l02551"></a><span class="lineno"> 2551</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *DstPtr = &amp;NewAI;</div><div class="line"><a name="l02552"></a><span class="lineno"> 2552</span>&#160;    <span class="keywordflow">if</span> (!IsDest)</div><div class="line"><a name="l02553"></a><span class="lineno"> 2553</span>&#160;      <a class="code" href="namespacestd.html#ab8424022895aee3e366fb9a32f2883cb">std::swap</a>(SrcPtr, DstPtr);</div><div class="line"><a name="l02554"></a><span class="lineno"> 2554</span>&#160;</div><div class="line"><a name="l02555"></a><span class="lineno"> 2555</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *Src;</div><div class="line"><a name="l02556"></a><span class="lineno"> 2556</span>&#160;    <span class="keywordflow">if</span> (VecTy &amp;&amp; !IsWholeAlloca &amp;&amp; !IsDest) {</div><div class="line"><a name="l02557"></a><span class="lineno"> 2557</span>&#160;      Src = IRB.CreateAlignedLoad(&amp;NewAI, NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">getAlignment</a>(),</div><div class="line"><a name="l02558"></a><span class="lineno"> 2558</span>&#160;                                  <span class="stringliteral">&quot;load&quot;</span>);</div><div class="line"><a name="l02559"></a><span class="lineno"> 2559</span>&#160;      Src = <a class="code" href="SROA_8cpp.html#a06a9071efa992145e210f0b41a52e501">extractVector</a>(IRB, Src, BeginIndex, EndIndex, <span class="stringliteral">&quot;vec&quot;</span>);</div><div class="line"><a name="l02560"></a><span class="lineno"> 2560</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IntTy &amp;&amp; !IsWholeAlloca &amp;&amp; !IsDest) {</div><div class="line"><a name="l02561"></a><span class="lineno"> 2561</span>&#160;      Src = IRB.CreateAlignedLoad(&amp;NewAI, NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">getAlignment</a>(),</div><div class="line"><a name="l02562"></a><span class="lineno"> 2562</span>&#160;                                  <span class="stringliteral">&quot;load&quot;</span>);</div><div class="line"><a name="l02563"></a><span class="lineno"> 2563</span>&#160;      Src = <a class="code" href="SROA_8cpp.html#a7d6146d9a22768498097b2c53cd2234f">convertValue</a>(DL, IRB, Src, IntTy);</div><div class="line"><a name="l02564"></a><span class="lineno"> 2564</span>&#160;      uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</div><div class="line"><a name="l02565"></a><span class="lineno"> 2565</span>&#160;      Src = <a class="code" href="SROA_8cpp.html#a94e7aca18fb08798727209385f164f7c">extractInteger</a>(DL, IRB, Src, SubIntTy, Offset, <span class="stringliteral">&quot;extract&quot;</span>);</div><div class="line"><a name="l02566"></a><span class="lineno"> 2566</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l02567"></a><span class="lineno"> 2567</span>&#160;      Src = IRB.CreateAlignedLoad(SrcPtr, Align, II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a9558faebdbb62c072aed98e33604889d">isVolatile</a>(),</div><div class="line"><a name="l02568"></a><span class="lineno"> 2568</span>&#160;                                  <span class="stringliteral">&quot;copyload&quot;</span>);</div><div class="line"><a name="l02569"></a><span class="lineno"> 2569</span>&#160;    }</div><div class="line"><a name="l02570"></a><span class="lineno"> 2570</span>&#160;</div><div class="line"><a name="l02571"></a><span class="lineno"> 2571</span>&#160;    <span class="keywordflow">if</span> (VecTy &amp;&amp; !IsWholeAlloca &amp;&amp; IsDest) {</div><div class="line"><a name="l02572"></a><span class="lineno"> 2572</span>&#160;      <a class="code" href="classllvm_1_1Value.html">Value</a> *Old = IRB.CreateAlignedLoad(&amp;NewAI, NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">getAlignment</a>(),</div><div class="line"><a name="l02573"></a><span class="lineno"> 2573</span>&#160;                                         <span class="stringliteral">&quot;oldload&quot;</span>);</div><div class="line"><a name="l02574"></a><span class="lineno"> 2574</span>&#160;      Src = <a class="code" href="SROA_8cpp.html#a42c6a2faff923f431932c6d33cf4092b">insertVector</a>(IRB, Old, Src, BeginIndex, <span class="stringliteral">&quot;vec&quot;</span>);</div><div class="line"><a name="l02575"></a><span class="lineno"> 2575</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (IntTy &amp;&amp; !IsWholeAlloca &amp;&amp; IsDest) {</div><div class="line"><a name="l02576"></a><span class="lineno"> 2576</span>&#160;      <a class="code" href="classllvm_1_1Value.html">Value</a> *Old = IRB.CreateAlignedLoad(&amp;NewAI, NewAI.<a class="code" href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">getAlignment</a>(),</div><div class="line"><a name="l02577"></a><span class="lineno"> 2577</span>&#160;                                         <span class="stringliteral">&quot;oldload&quot;</span>);</div><div class="line"><a name="l02578"></a><span class="lineno"> 2578</span>&#160;      Old = <a class="code" href="SROA_8cpp.html#a7d6146d9a22768498097b2c53cd2234f">convertValue</a>(DL, IRB, Old, IntTy);</div><div class="line"><a name="l02579"></a><span class="lineno"> 2579</span>&#160;      uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</div><div class="line"><a name="l02580"></a><span class="lineno"> 2580</span>&#160;      Src = <a class="code" href="SROA_8cpp.html#a7febebe786555d6e0d07ca0f86e294c1">insertInteger</a>(DL, IRB, Old, Src, Offset, <span class="stringliteral">&quot;insert&quot;</span>);</div><div class="line"><a name="l02581"></a><span class="lineno"> 2581</span>&#160;      Src = <a class="code" href="SROA_8cpp.html#a7d6146d9a22768498097b2c53cd2234f">convertValue</a>(DL, IRB, Src, NewAllocaTy);</div><div class="line"><a name="l02582"></a><span class="lineno"> 2582</span>&#160;    }</div><div class="line"><a name="l02583"></a><span class="lineno"> 2583</span>&#160;</div><div class="line"><a name="l02584"></a><span class="lineno"> 2584</span>&#160;    <a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> *<a class="code" href="namespacellvm_1_1SPII.html#a11e9b8fca4a074643a6a21f444e51406a36b3dd3b84fde3f8494a9b18af131856">Store</a> = cast&lt;StoreInst&gt;(</div><div class="line"><a name="l02585"></a><span class="lineno"> 2585</span>&#160;      IRB.CreateAlignedStore(Src, DstPtr, Align, II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a9558faebdbb62c072aed98e33604889d">isVolatile</a>()));</div><div class="line"><a name="l02586"></a><span class="lineno"> 2586</span>&#160;    (void)Store;</div><div class="line"><a name="l02587"></a><span class="lineno"> 2587</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;          to: &quot;</span> &lt;&lt; *Store &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02588"></a><span class="lineno"> 2588</span>&#160;    <span class="keywordflow">return</span> !II.<a class="code" href="classllvm_1_1MemIntrinsic.html#a9558faebdbb62c072aed98e33604889d">isVolatile</a>();</div><div class="line"><a name="l02589"></a><span class="lineno"> 2589</span>&#160;  }</div><div class="line"><a name="l02590"></a><span class="lineno"> 2590</span>&#160;</div><div class="line"><a name="l02591"></a><span class="lineno"> 2591</span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1InstVisitor.html#a432d533de0923ad3b0fd6dfc22c7ebd6">visitIntrinsicInst</a>(<a class="code" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> &amp;II) {</div><div class="line"><a name="l02592"></a><span class="lineno"> 2592</span>&#160;    assert(II.<a class="code" href="classllvm_1_1IntrinsicInst.html#a6cbb4809b81f3994ee0c79b38556bd66">getIntrinsicID</a>() == <a class="code" href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90ae365354e47542c51f9bd46e329e3323e">Intrinsic::lifetime_start</a> ||</div><div class="line"><a name="l02593"></a><span class="lineno"> 2593</span>&#160;           II.<a class="code" href="classllvm_1_1IntrinsicInst.html#a6cbb4809b81f3994ee0c79b38556bd66">getIntrinsicID</a>() == <a class="code" href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90aa332b90dd5e4ebf4bbbcc0964220d373">Intrinsic::lifetime_end</a>);</div><div class="line"><a name="l02594"></a><span class="lineno"> 2594</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;    original: &quot;</span> &lt;&lt; II &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02595"></a><span class="lineno"> 2595</span>&#160;    assert(II.<a class="code" href="classllvm_1_1CallInst.html#a150b33ecedbc8c7803c2db8040fbe3f8">getArgOperand</a>(1) == OldPtr);</div><div class="line"><a name="l02596"></a><span class="lineno"> 2596</span>&#160;</div><div class="line"><a name="l02597"></a><span class="lineno"> 2597</span>&#160;    <span class="comment">// Compute the intersecting offset range.</span></div><div class="line"><a name="l02598"></a><span class="lineno"> 2598</span>&#160;    assert(BeginOffset &lt; NewAllocaEndOffset);</div><div class="line"><a name="l02599"></a><span class="lineno"> 2599</span>&#160;    assert(EndOffset &gt; NewAllocaBeginOffset);</div><div class="line"><a name="l02600"></a><span class="lineno"> 2600</span>&#160;    uint64_t NewBeginOffset = std::max(BeginOffset, NewAllocaBeginOffset);</div><div class="line"><a name="l02601"></a><span class="lineno"> 2601</span>&#160;    uint64_t NewEndOffset = std::min(EndOffset, NewAllocaEndOffset);</div><div class="line"><a name="l02602"></a><span class="lineno"> 2602</span>&#160;</div><div class="line"><a name="l02603"></a><span class="lineno"> 2603</span>&#160;    <span class="comment">// Record this instruction for deletion.</span></div><div class="line"><a name="l02604"></a><span class="lineno"> 2604</span>&#160;    Pass.DeadInsts.insert(&amp;II);</div><div class="line"><a name="l02605"></a><span class="lineno"> 2605</span>&#160;</div><div class="line"><a name="l02606"></a><span class="lineno"> 2606</span>&#160;    <a class="code" href="classllvm_1_1ConstantInt.html">ConstantInt</a> *Size</div><div class="line"><a name="l02607"></a><span class="lineno"> 2607</span>&#160;      = <a class="code" href="classllvm_1_1ConstantInt.html#a9105541412dab869e18b3cceebfff07d">ConstantInt::get</a>(cast&lt;IntegerType&gt;(II.<a class="code" href="classllvm_1_1CallInst.html#a150b33ecedbc8c7803c2db8040fbe3f8">getArgOperand</a>(0)-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()),</div><div class="line"><a name="l02608"></a><span class="lineno"> 2608</span>&#160;                         NewEndOffset - NewBeginOffset);</div><div class="line"><a name="l02609"></a><span class="lineno"> 2609</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr =</div><div class="line"><a name="l02610"></a><span class="lineno"> 2610</span>&#160;        getAdjustedAllocaPtr(IRB, NewBeginOffset, II.<a class="code" href="classllvm_1_1CallInst.html#a150b33ecedbc8c7803c2db8040fbe3f8">getArgOperand</a>(1)-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>());</div><div class="line"><a name="l02611"></a><span class="lineno"> 2611</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *New;</div><div class="line"><a name="l02612"></a><span class="lineno"> 2612</span>&#160;    <span class="keywordflow">if</span> (II.<a class="code" href="classllvm_1_1IntrinsicInst.html#a6cbb4809b81f3994ee0c79b38556bd66">getIntrinsicID</a>() == <a class="code" href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90ae365354e47542c51f9bd46e329e3323e">Intrinsic::lifetime_start</a>)</div><div class="line"><a name="l02613"></a><span class="lineno"> 2613</span>&#160;      New = IRB.CreateLifetimeStart(Ptr, Size);</div><div class="line"><a name="l02614"></a><span class="lineno"> 2614</span>&#160;    <span class="keywordflow">else</span></div><div class="line"><a name="l02615"></a><span class="lineno"> 2615</span>&#160;      New = IRB.CreateLifetimeEnd(Ptr, Size);</div><div class="line"><a name="l02616"></a><span class="lineno"> 2616</span>&#160;</div><div class="line"><a name="l02617"></a><span class="lineno"> 2617</span>&#160;    (void)New;</div><div class="line"><a name="l02618"></a><span class="lineno"> 2618</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;          to: &quot;</span> &lt;&lt; *New &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02619"></a><span class="lineno"> 2619</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l02620"></a><span class="lineno"> 2620</span>&#160;  }</div><div class="line"><a name="l02621"></a><span class="lineno"> 2621</span>&#160;</div><div class="line"><a name="l02622"></a><span class="lineno"> 2622</span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1InstVisitor.html#a6b5f364cdf10081c74343b149fbc325f">visitPHINode</a>(<a class="code" href="classllvm_1_1PHINode.html">PHINode</a> &amp;PN) {</div><div class="line"><a name="l02623"></a><span class="lineno"> 2623</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;    original: &quot;</span> &lt;&lt; PN &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02624"></a><span class="lineno"> 2624</span>&#160;    assert(BeginOffset &gt;= NewAllocaBeginOffset &amp;&amp; <span class="stringliteral">&quot;PHIs are unsplittable&quot;</span>);</div><div class="line"><a name="l02625"></a><span class="lineno"> 2625</span>&#160;    assert(EndOffset &lt;= NewAllocaEndOffset &amp;&amp; <span class="stringliteral">&quot;PHIs are unsplittable&quot;</span>);</div><div class="line"><a name="l02626"></a><span class="lineno"> 2626</span>&#160;</div><div class="line"><a name="l02627"></a><span class="lineno"> 2627</span>&#160;    <span class="comment">// We would like to compute a new pointer in only one place, but have it be</span></div><div class="line"><a name="l02628"></a><span class="lineno"> 2628</span>&#160;    <span class="comment">// as local as possible to the PHI. To do that, we re-use the location of</span></div><div class="line"><a name="l02629"></a><span class="lineno"> 2629</span>&#160;    <span class="comment">// the old pointer, which necessarily must be in the right position to</span></div><div class="line"><a name="l02630"></a><span class="lineno"> 2630</span>&#160;    <span class="comment">// dominate the PHI.</span></div><div class="line"><a name="l02631"></a><span class="lineno"> 2631</span>&#160;    IRBuilderTy PtrBuilder(OldPtr);</div><div class="line"><a name="l02632"></a><span class="lineno"> 2632</span>&#160;    PtrBuilder.SetNamePrefix(<a class="code" href="classllvm_1_1Twine.html">Twine</a>(NewAI.<a class="code" href="classllvm_1_1Value.html#ad452febc1ac0b394876e640ec03ffa38">getName</a>()) + <span class="stringliteral">&quot;.&quot;</span> + <a class="code" href="classllvm_1_1Twine.html">Twine</a>(BeginOffset) +</div><div class="line"><a name="l02633"></a><span class="lineno"> 2633</span>&#160;                             <span class="stringliteral">&quot;.&quot;</span>);</div><div class="line"><a name="l02634"></a><span class="lineno"> 2634</span>&#160;</div><div class="line"><a name="l02635"></a><span class="lineno"> 2635</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *NewPtr =</div><div class="line"><a name="l02636"></a><span class="lineno"> 2636</span>&#160;        getAdjustedAllocaPtr(PtrBuilder, BeginOffset, OldPtr-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>());</div><div class="line"><a name="l02637"></a><span class="lineno"> 2637</span>&#160;    <span class="comment">// Replace the operands which were using the old pointer.</span></div><div class="line"><a name="l02638"></a><span class="lineno"> 2638</span>&#160;    std::replace(PN.<a class="code" href="classllvm_1_1User.html#a2eeb1c7ed1cfe403f2ae0470e36c07e2">op_begin</a>(), PN.<a class="code" href="classllvm_1_1User.html#af41f58e730804d10b91fcff39b035f74">op_end</a>(), cast&lt;Value&gt;(OldPtr), NewPtr);</div><div class="line"><a name="l02639"></a><span class="lineno"> 2639</span>&#160;</div><div class="line"><a name="l02640"></a><span class="lineno"> 2640</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;          to: &quot;</span> &lt;&lt; PN &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02641"></a><span class="lineno"> 2641</span>&#160;    deleteIfTriviallyDead(OldPtr);</div><div class="line"><a name="l02642"></a><span class="lineno"> 2642</span>&#160;</div><div class="line"><a name="l02643"></a><span class="lineno"> 2643</span>&#160;    <span class="comment">// Check whether we can speculate this PHI node, and if so remember that</span></div><div class="line"><a name="l02644"></a><span class="lineno"> 2644</span>&#160;    <span class="comment">// fact and queue it up for another iteration after the speculation</span></div><div class="line"><a name="l02645"></a><span class="lineno"> 2645</span>&#160;    <span class="comment">// occurs.</span></div><div class="line"><a name="l02646"></a><span class="lineno"> 2646</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="SROA_8cpp.html#a40145cc8bb126bba70637669bbb6dad8">isSafePHIToSpeculate</a>(PN, &amp;DL)) {</div><div class="line"><a name="l02647"></a><span class="lineno"> 2647</span>&#160;      Pass.SpeculatablePHIs.insert(&amp;PN);</div><div class="line"><a name="l02648"></a><span class="lineno"> 2648</span>&#160;      IsUsedByRewrittenSpeculatableInstructions = <span class="keyword">true</span>;</div><div class="line"><a name="l02649"></a><span class="lineno"> 2649</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l02650"></a><span class="lineno"> 2650</span>&#160;    }</div><div class="line"><a name="l02651"></a><span class="lineno"> 2651</span>&#160;</div><div class="line"><a name="l02652"></a><span class="lineno"> 2652</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// PHIs can&#39;t be promoted on their own.</span></div><div class="line"><a name="l02653"></a><span class="lineno"> 2653</span>&#160;  }</div><div class="line"><a name="l02654"></a><span class="lineno"> 2654</span>&#160;</div><div class="line"><a name="l02655"></a><span class="lineno"> 2655</span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1InstVisitor.html#aeb67eff747cfcdb17ca1079aff8ed9ca">visitSelectInst</a>(<a class="code" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;SI) {</div><div class="line"><a name="l02656"></a><span class="lineno"> 2656</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;    original: &quot;</span> &lt;&lt; SI &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02657"></a><span class="lineno"> 2657</span>&#160;    assert((SI.<a class="code" href="classllvm_1_1SelectInst.html#a67bf091383cd61e1225445e78b61d9f9">getTrueValue</a>() == OldPtr || SI.<a class="code" href="classllvm_1_1SelectInst.html#a29a16f32075ee4f23cd769701463952c">getFalseValue</a>() == OldPtr) &amp;&amp;</div><div class="line"><a name="l02658"></a><span class="lineno"> 2658</span>&#160;           <span class="stringliteral">&quot;Pointer isn&#39;t an operand!&quot;</span>);</div><div class="line"><a name="l02659"></a><span class="lineno"> 2659</span>&#160;    assert(BeginOffset &gt;= NewAllocaBeginOffset &amp;&amp; <span class="stringliteral">&quot;Selects are unsplittable&quot;</span>);</div><div class="line"><a name="l02660"></a><span class="lineno"> 2660</span>&#160;    assert(EndOffset &lt;= NewAllocaEndOffset &amp;&amp; <span class="stringliteral">&quot;Selects are unsplittable&quot;</span>);</div><div class="line"><a name="l02661"></a><span class="lineno"> 2661</span>&#160;</div><div class="line"><a name="l02662"></a><span class="lineno"> 2662</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *NewPtr = getAdjustedAllocaPtr(IRB, BeginOffset, OldPtr-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>());</div><div class="line"><a name="l02663"></a><span class="lineno"> 2663</span>&#160;    <span class="comment">// Replace the operands which were using the old pointer.</span></div><div class="line"><a name="l02664"></a><span class="lineno"> 2664</span>&#160;    <span class="keywordflow">if</span> (SI.<a class="code" href="classllvm_1_1User.html#a997ff6a1758bf732b9b263fc61011644">getOperand</a>(1) == OldPtr)</div><div class="line"><a name="l02665"></a><span class="lineno"> 2665</span>&#160;      SI.<a class="code" href="classllvm_1_1User.html#a5fa9b8e1842b354f64c1ba6be0a4a17f">setOperand</a>(1, NewPtr);</div><div class="line"><a name="l02666"></a><span class="lineno"> 2666</span>&#160;    <span class="keywordflow">if</span> (SI.<a class="code" href="classllvm_1_1User.html#a997ff6a1758bf732b9b263fc61011644">getOperand</a>(2) == OldPtr)</div><div class="line"><a name="l02667"></a><span class="lineno"> 2667</span>&#160;      SI.<a class="code" href="classllvm_1_1User.html#a5fa9b8e1842b354f64c1ba6be0a4a17f">setOperand</a>(2, NewPtr);</div><div class="line"><a name="l02668"></a><span class="lineno"> 2668</span>&#160;</div><div class="line"><a name="l02669"></a><span class="lineno"> 2669</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;          to: &quot;</span> &lt;&lt; SI &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02670"></a><span class="lineno"> 2670</span>&#160;    deleteIfTriviallyDead(OldPtr);</div><div class="line"><a name="l02671"></a><span class="lineno"> 2671</span>&#160;</div><div class="line"><a name="l02672"></a><span class="lineno"> 2672</span>&#160;    <span class="comment">// Check whether we can speculate this select instruction, and if so</span></div><div class="line"><a name="l02673"></a><span class="lineno"> 2673</span>&#160;    <span class="comment">// remember that fact and queue it up for another iteration after the</span></div><div class="line"><a name="l02674"></a><span class="lineno"> 2674</span>&#160;    <span class="comment">// speculation occurs.</span></div><div class="line"><a name="l02675"></a><span class="lineno"> 2675</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="SROA_8cpp.html#a908c20a486274e383f5261012a7c36da">isSafeSelectToSpeculate</a>(SI, &amp;DL)) {</div><div class="line"><a name="l02676"></a><span class="lineno"> 2676</span>&#160;      Pass.SpeculatableSelects.insert(&amp;SI);</div><div class="line"><a name="l02677"></a><span class="lineno"> 2677</span>&#160;      IsUsedByRewrittenSpeculatableInstructions = <span class="keyword">true</span>;</div><div class="line"><a name="l02678"></a><span class="lineno"> 2678</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l02679"></a><span class="lineno"> 2679</span>&#160;    }</div><div class="line"><a name="l02680"></a><span class="lineno"> 2680</span>&#160;</div><div class="line"><a name="l02681"></a><span class="lineno"> 2681</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// Selects can&#39;t be promoted on their own.</span></div><div class="line"><a name="l02682"></a><span class="lineno"> 2682</span>&#160;  }</div><div class="line"><a name="l02683"></a><span class="lineno"> 2683</span>&#160;</div><div class="line"><a name="l02684"></a><span class="lineno"> 2684</span>&#160;};</div><div class="line"><a name="l02685"></a><span class="lineno"> 2685</span>&#160;}</div><div class="line"><a name="l02686"></a><span class="lineno"> 2686</span>&#160;</div><div class="line"><a name="l02687"></a><span class="lineno"> 2687</span>&#160;<span class="keyword">namespace </span>{<span class="comment"></span></div><div class="line"><a name="l02688"></a><span class="lineno"> 2688</span>&#160;<span class="comment">/// \brief Visitor to rewrite aggregate loads and stores as scalar.</span></div><div class="line"><a name="l02689"></a><span class="lineno"> 2689</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l02690"></a><span class="lineno"> 2690</span>&#160;<span class="comment">/// This pass aggressively rewrites all aggregate loads and stores on</span></div><div class="line"><a name="l02691"></a><span class="lineno"> 2691</span>&#160;<span class="comment">/// a particular pointer (or any pointer derived from it which we can identify)</span></div><div class="line"><a name="l02692"></a><span class="lineno"> 2692</span>&#160;<span class="comment">/// with scalar loads and stores.</span></div><div class="line"><a name="l02693"></a><span class="lineno"> 2693</span>&#160;<span class="comment"></span><span class="keyword">class </span>AggLoadStoreRewriter : <span class="keyword">public</span> <a class="code" href="classllvm_1_1InstVisitor.html">InstVisitor</a>&lt;AggLoadStoreRewriter, bool&gt; {</div><div class="line"><a name="l02694"></a><span class="lineno"> 2694</span>&#160;  <span class="comment">// Befriend the base class so it can delegate to private visit methods.</span></div><div class="line"><a name="l02695"></a><span class="lineno"> 2695</span>&#160;  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classllvm_1_1InstVisitor.html">llvm::InstVisitor</a>&lt;AggLoadStoreRewriter, bool&gt;;</div><div class="line"><a name="l02696"></a><span class="lineno"> 2696</span>&#160;</div><div class="line"><a name="l02697"></a><span class="lineno"> 2697</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL;</div><div class="line"><a name="l02698"></a><span class="lineno"> 2698</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02699"></a><span class="lineno"> 2699</span>&#160;<span class="comment">  /// Queue of pointer uses to analyze and potentially rewrite.</span></div><div class="line"><a name="l02700"></a><span class="lineno"> 2700</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Use *, 8&gt;</a> Queue;</div><div class="line"><a name="l02701"></a><span class="lineno"> 2701</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02702"></a><span class="lineno"> 2702</span>&#160;<span class="comment">  /// Set to prevent us from cycling with phi nodes and loops.</span></div><div class="line"><a name="l02703"></a><span class="lineno"> 2703</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet&lt;User *, 8&gt;</a> Visited;</div><div class="line"><a name="l02704"></a><span class="lineno"> 2704</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02705"></a><span class="lineno"> 2705</span>&#160;<span class="comment">  /// The current pointer use being rewritten. This is used to dig up the used</span></div><div class="line"><a name="l02706"></a><span class="lineno"> 2706</span>&#160;<span class="comment">  /// value (as opposed to the user).</span></div><div class="line"><a name="l02707"></a><span class="lineno"> 2707</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1Use.html">Use</a> *U;</div><div class="line"><a name="l02708"></a><span class="lineno"> 2708</span>&#160;</div><div class="line"><a name="l02709"></a><span class="lineno"> 2709</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l02710"></a><span class="lineno"> 2710</span>&#160;  AggLoadStoreRewriter(<span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL) : DL(DL) {}</div><div class="line"><a name="l02711"></a><span class="lineno"> 2711</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02712"></a><span class="lineno"> 2712</span>&#160;<span class="comment">  /// Rewrite loads and stores through a pointer and all pointers derived from</span></div><div class="line"><a name="l02713"></a><span class="lineno"> 2713</span>&#160;<span class="comment">  /// it.</span></div><div class="line"><a name="l02714"></a><span class="lineno"> 2714</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> rewrite(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> &amp;<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) {</div><div class="line"><a name="l02715"></a><span class="lineno"> 2715</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;  Rewriting FCA loads and stores...\n&quot;</span>);</div><div class="line"><a name="l02716"></a><span class="lineno"> 2716</span>&#160;    enqueueUsers(I);</div><div class="line"><a name="l02717"></a><span class="lineno"> 2717</span>&#160;    <span class="keywordtype">bool</span> Changed = <span class="keyword">false</span>;</div><div class="line"><a name="l02718"></a><span class="lineno"> 2718</span>&#160;    <span class="keywordflow">while</span> (!Queue.<a class="code" href="classllvm_1_1SmallVectorBase.html#a8a8df4d85555c7954a95f86080cd3b64">empty</a>()) {</div><div class="line"><a name="l02719"></a><span class="lineno"> 2719</span>&#160;      U = Queue.<a class="code" href="classllvm_1_1SmallVectorImpl.html#a400eaca9881c8dcab97e9f42b1ab1815">pop_back_val</a>();</div><div class="line"><a name="l02720"></a><span class="lineno"> 2720</span>&#160;      Changed |= <a class="code" href="classllvm_1_1InstVisitor.html#a6352e72d11377a9c62f24434ae869bf0">visit</a>(cast&lt;Instruction&gt;(U-&gt;getUser()));</div><div class="line"><a name="l02721"></a><span class="lineno"> 2721</span>&#160;    }</div><div class="line"><a name="l02722"></a><span class="lineno"> 2722</span>&#160;    <span class="keywordflow">return</span> Changed;</div><div class="line"><a name="l02723"></a><span class="lineno"> 2723</span>&#160;  }</div><div class="line"><a name="l02724"></a><span class="lineno"> 2724</span>&#160;</div><div class="line"><a name="l02725"></a><span class="lineno"> 2725</span>&#160;<span class="keyword">private</span>:<span class="comment"></span></div><div class="line"><a name="l02726"></a><span class="lineno"> 2726</span>&#160;<span class="comment">  /// Enqueue all the users of the given instruction for further processing.</span></div><div class="line"><a name="l02727"></a><span class="lineno"> 2727</span>&#160;<span class="comment">  /// This uses a set to de-duplicate users.</span></div><div class="line"><a name="l02728"></a><span class="lineno"> 2728</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> enqueueUsers(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> &amp;I) {</div><div class="line"><a name="l02729"></a><span class="lineno"> 2729</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1value__use__iterator.html">Value::use_iterator</a> UI = I.<a class="code" href="classllvm_1_1Value.html#a413abcab8dbc3900fc2fde96a5d8fca6">use_begin</a>(), UE = I.<a class="code" href="classllvm_1_1Value.html#ad86469939d2a8bdd4169be9403b89f5a">use_end</a>(); UI != UE;</div><div class="line"><a name="l02730"></a><span class="lineno"> 2730</span>&#160;         ++UI)</div><div class="line"><a name="l02731"></a><span class="lineno"> 2731</span>&#160;      <span class="keywordflow">if</span> (Visited.<a class="code" href="classllvm_1_1SmallPtrSet.html#a9b6dd0fc7a648a939e571246045b673e">insert</a>(*UI))</div><div class="line"><a name="l02732"></a><span class="lineno"> 2732</span>&#160;        Queue.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(&amp;UI.getUse());</div><div class="line"><a name="l02733"></a><span class="lineno"> 2733</span>&#160;  }</div><div class="line"><a name="l02734"></a><span class="lineno"> 2734</span>&#160;</div><div class="line"><a name="l02735"></a><span class="lineno"> 2735</span>&#160;  <span class="comment">// Conservative default is to not rewrite anything.</span></div><div class="line"><a name="l02736"></a><span class="lineno"> 2736</span>&#160;  <span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1InstVisitor.html#af7fc294424421c8b8e16185bd9bc7f8f">visitInstruction</a>(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> &amp;I) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div><div class="line"><a name="l02737"></a><span class="lineno"> 2737</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02738"></a><span class="lineno"> 2738</span>&#160;<span class="comment">  /// \brief Generic recursive split emission class.</span></div><div class="line"><a name="l02739"></a><span class="lineno"> 2739</span>&#160;<span class="comment"></span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</div><div class="line"><a name="l02740"></a><span class="lineno"> 2740</span>&#160;  <span class="keyword">class </span>OpSplitter {</div><div class="line"><a name="l02741"></a><span class="lineno"> 2741</span>&#160;  <span class="keyword">protected</span>:<span class="comment"></span></div><div class="line"><a name="l02742"></a><span class="lineno"> 2742</span>&#160;<span class="comment">    /// The builder used to form new instructions.</span></div><div class="line"><a name="l02743"></a><span class="lineno"> 2743</span>&#160;<span class="comment"></span>    IRBuilderTy IRB;<span class="comment"></span></div><div class="line"><a name="l02744"></a><span class="lineno"> 2744</span>&#160;<span class="comment">    /// The indices which to be used with insert- or extractvalue to select the</span></div><div class="line"><a name="l02745"></a><span class="lineno"> 2745</span>&#160;<span class="comment">    /// appropriate value within the aggregate.</span></div><div class="line"><a name="l02746"></a><span class="lineno"> 2746</span>&#160;<span class="comment"></span>    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;unsigned, 4&gt;</a> Indices;<span class="comment"></span></div><div class="line"><a name="l02747"></a><span class="lineno"> 2747</span>&#160;<span class="comment">    /// The indices to a GEP instruction which will move Ptr to the correct slot</span></div><div class="line"><a name="l02748"></a><span class="lineno"> 2748</span>&#160;<span class="comment">    /// within the aggregate.</span></div><div class="line"><a name="l02749"></a><span class="lineno"> 2749</span>&#160;<span class="comment"></span>    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Value *, 4&gt;</a> GEPIndices;<span class="comment"></span></div><div class="line"><a name="l02750"></a><span class="lineno"> 2750</span>&#160;<span class="comment">    /// The base pointer of the original op, used as a base for GEPing the</span></div><div class="line"><a name="l02751"></a><span class="lineno"> 2751</span>&#160;<span class="comment">    /// split operations.</span></div><div class="line"><a name="l02752"></a><span class="lineno"> 2752</span>&#160;<span class="comment"></span>    <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr;</div><div class="line"><a name="l02753"></a><span class="lineno"> 2753</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02754"></a><span class="lineno"> 2754</span>&#160;<span class="comment">    /// Initialize the splitter with an insertion point, Ptr and start with a</span></div><div class="line"><a name="l02755"></a><span class="lineno"> 2755</span>&#160;<span class="comment">    /// single zero GEP index.</span></div><div class="line"><a name="l02756"></a><span class="lineno"> 2756</span>&#160;<span class="comment"></span>    OpSplitter(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *InsertionPoint, <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr)</div><div class="line"><a name="l02757"></a><span class="lineno"> 2757</span>&#160;      : IRB(InsertionPoint), GEPIndices(1, IRB.getInt32(0)), Ptr(Ptr) {}</div><div class="line"><a name="l02758"></a><span class="lineno"> 2758</span>&#160;</div><div class="line"><a name="l02759"></a><span class="lineno"> 2759</span>&#160;  <span class="keyword">public</span>:<span class="comment"></span></div><div class="line"><a name="l02760"></a><span class="lineno"> 2760</span>&#160;<span class="comment">    /// \brief Generic recursive split emission routine.</span></div><div class="line"><a name="l02761"></a><span class="lineno"> 2761</span>&#160;<span class="comment">    ///</span></div><div class="line"><a name="l02762"></a><span class="lineno"> 2762</span>&#160;<span class="comment">    /// This method recursively splits an aggregate op (load or store) into</span></div><div class="line"><a name="l02763"></a><span class="lineno"> 2763</span>&#160;<span class="comment">    /// scalar or vector ops. It splits recursively until it hits a single value</span></div><div class="line"><a name="l02764"></a><span class="lineno"> 2764</span>&#160;<span class="comment">    /// and emits that single value operation via the template argument.</span></div><div class="line"><a name="l02765"></a><span class="lineno"> 2765</span>&#160;<span class="comment">    ///</span></div><div class="line"><a name="l02766"></a><span class="lineno"> 2766</span>&#160;<span class="comment">    /// The logic of this routine relies on GEPs and insertvalue and</span></div><div class="line"><a name="l02767"></a><span class="lineno"> 2767</span>&#160;<span class="comment">    /// extractvalue all operating with the same fundamental index list, merely</span></div><div class="line"><a name="l02768"></a><span class="lineno"> 2768</span>&#160;<span class="comment">    /// formatted differently (GEPs need actual values).</span></div><div class="line"><a name="l02769"></a><span class="lineno"> 2769</span>&#160;<span class="comment">    ///</span></div><div class="line"><a name="l02770"></a><span class="lineno"> 2770</span>&#160;<span class="comment">    /// \param Ty  The type being split recursively into smaller ops.</span></div><div class="line"><a name="l02771"></a><span class="lineno"> 2771</span>&#160;<span class="comment">    /// \param Agg The aggregate value being built up or stored, depending on</span></div><div class="line"><a name="l02772"></a><span class="lineno"> 2772</span>&#160;<span class="comment">    /// whether this is splitting a load or a store respectively.</span></div><div class="line"><a name="l02773"></a><span class="lineno"> 2773</span>&#160;<span class="comment"></span>    <span class="keywordtype">void</span> emitSplitOps(<a class="code" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="code" href="classllvm_1_1Value.html">Value</a> *&amp;Agg, <span class="keyword">const</span> <a class="code" href="classllvm_1_1Twine.html">Twine</a> &amp;<a class="code" href="namespacellvm_1_1GraphProgram.html#a0ad4685976f8c4d4a697a53fbe05d10b">Name</a>) {</div><div class="line"><a name="l02774"></a><span class="lineno"> 2774</span>&#160;      <span class="keywordflow">if</span> (Ty-&gt;<a class="code" href="classllvm_1_1Type.html#a36e21267fe14e69d3251eab1cd3a0076">isSingleValueType</a>())</div><div class="line"><a name="l02775"></a><span class="lineno"> 2775</span>&#160;        <span class="keywordflow">return</span> static_cast&lt;Derived *&gt;(<span class="keyword">this</span>)-&gt;emitFunc(Ty, Agg, Name);</div><div class="line"><a name="l02776"></a><span class="lineno"> 2776</span>&#160;</div><div class="line"><a name="l02777"></a><span class="lineno"> 2777</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1ArrayType.html">ArrayType</a> *ATy = dyn_cast&lt;ArrayType&gt;(Ty)) {</div><div class="line"><a name="l02778"></a><span class="lineno"> 2778</span>&#160;        <span class="keywordtype">unsigned</span> OldSize = Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a22a311dfe4c28a897de8a9365a4f0a84">size</a>();</div><div class="line"><a name="l02779"></a><span class="lineno"> 2779</span>&#160;        (void)OldSize;</div><div class="line"><a name="l02780"></a><span class="lineno"> 2780</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> Idx = 0, Size = ATy-&gt;getNumElements(); Idx != Size;</div><div class="line"><a name="l02781"></a><span class="lineno"> 2781</span>&#160;             ++Idx) {</div><div class="line"><a name="l02782"></a><span class="lineno"> 2782</span>&#160;          assert(Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a22a311dfe4c28a897de8a9365a4f0a84">size</a>() == OldSize &amp;&amp; <span class="stringliteral">&quot;Did not return to the old size&quot;</span>);</div><div class="line"><a name="l02783"></a><span class="lineno"> 2783</span>&#160;          Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(Idx);</div><div class="line"><a name="l02784"></a><span class="lineno"> 2784</span>&#160;          GEPIndices.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(IRB.getInt32(Idx));</div><div class="line"><a name="l02785"></a><span class="lineno"> 2785</span>&#160;          emitSplitOps(ATy-&gt;getElementType(), Agg, Name + <span class="stringliteral">&quot;.&quot;</span> + <a class="code" href="classllvm_1_1Twine.html">Twine</a>(Idx));</div><div class="line"><a name="l02786"></a><span class="lineno"> 2786</span>&#160;          GEPIndices.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#a1f2303df9bbee2233c11d61c2f6f7930">pop_back</a>();</div><div class="line"><a name="l02787"></a><span class="lineno"> 2787</span>&#160;          Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#a1f2303df9bbee2233c11d61c2f6f7930">pop_back</a>();</div><div class="line"><a name="l02788"></a><span class="lineno"> 2788</span>&#160;        }</div><div class="line"><a name="l02789"></a><span class="lineno"> 2789</span>&#160;        <span class="keywordflow">return</span>;</div><div class="line"><a name="l02790"></a><span class="lineno"> 2790</span>&#160;      }</div><div class="line"><a name="l02791"></a><span class="lineno"> 2791</span>&#160;</div><div class="line"><a name="l02792"></a><span class="lineno"> 2792</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1StructType.html">StructType</a> *STy = dyn_cast&lt;StructType&gt;(Ty)) {</div><div class="line"><a name="l02793"></a><span class="lineno"> 2793</span>&#160;        <span class="keywordtype">unsigned</span> OldSize = Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a22a311dfe4c28a897de8a9365a4f0a84">size</a>();</div><div class="line"><a name="l02794"></a><span class="lineno"> 2794</span>&#160;        (void)OldSize;</div><div class="line"><a name="l02795"></a><span class="lineno"> 2795</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> Idx = 0, Size = STy-&gt;getNumElements(); Idx != Size;</div><div class="line"><a name="l02796"></a><span class="lineno"> 2796</span>&#160;             ++Idx) {</div><div class="line"><a name="l02797"></a><span class="lineno"> 2797</span>&#160;          assert(Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a22a311dfe4c28a897de8a9365a4f0a84">size</a>() == OldSize &amp;&amp; <span class="stringliteral">&quot;Did not return to the old size&quot;</span>);</div><div class="line"><a name="l02798"></a><span class="lineno"> 2798</span>&#160;          Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(Idx);</div><div class="line"><a name="l02799"></a><span class="lineno"> 2799</span>&#160;          GEPIndices.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(IRB.getInt32(Idx));</div><div class="line"><a name="l02800"></a><span class="lineno"> 2800</span>&#160;          emitSplitOps(STy-&gt;getElementType(Idx), Agg, Name + <span class="stringliteral">&quot;.&quot;</span> + <a class="code" href="classllvm_1_1Twine.html">Twine</a>(Idx));</div><div class="line"><a name="l02801"></a><span class="lineno"> 2801</span>&#160;          GEPIndices.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#a1f2303df9bbee2233c11d61c2f6f7930">pop_back</a>();</div><div class="line"><a name="l02802"></a><span class="lineno"> 2802</span>&#160;          Indices.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#a1f2303df9bbee2233c11d61c2f6f7930">pop_back</a>();</div><div class="line"><a name="l02803"></a><span class="lineno"> 2803</span>&#160;        }</div><div class="line"><a name="l02804"></a><span class="lineno"> 2804</span>&#160;        <span class="keywordflow">return</span>;</div><div class="line"><a name="l02805"></a><span class="lineno"> 2805</span>&#160;      }</div><div class="line"><a name="l02806"></a><span class="lineno"> 2806</span>&#160;</div><div class="line"><a name="l02807"></a><span class="lineno"> 2807</span>&#160;      <a class="code" href="ErrorHandling_8h.html#ace243f5c25697a1107cce46626b3dc94">llvm_unreachable</a>(<span class="stringliteral">&quot;Only arrays and structs are aggregate loadable types&quot;</span>);</div><div class="line"><a name="l02808"></a><span class="lineno"> 2808</span>&#160;    }</div><div class="line"><a name="l02809"></a><span class="lineno"> 2809</span>&#160;  };</div><div class="line"><a name="l02810"></a><span class="lineno"> 2810</span>&#160;</div><div class="line"><a name="l02811"></a><span class="lineno"> 2811</span>&#160;  <span class="keyword">struct </span>LoadOpSplitter : <span class="keyword">public</span> OpSplitter&lt;LoadOpSplitter&gt; {</div><div class="line"><a name="l02812"></a><span class="lineno"> 2812</span>&#160;    LoadOpSplitter(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *InsertionPoint, <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr)</div><div class="line"><a name="l02813"></a><span class="lineno"> 2813</span>&#160;      : OpSplitter&lt;LoadOpSplitter&gt;(InsertionPoint, Ptr) {}</div><div class="line"><a name="l02814"></a><span class="lineno"> 2814</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02815"></a><span class="lineno"> 2815</span>&#160;<span class="comment">    /// Emit a leaf load of a single value. This is called at the leaves of the</span></div><div class="line"><a name="l02816"></a><span class="lineno"> 2816</span>&#160;<span class="comment">    /// recursive emission to actually load values.</span></div><div class="line"><a name="l02817"></a><span class="lineno"> 2817</span>&#160;<span class="comment"></span>    <span class="keywordtype">void</span> emitFunc(<a class="code" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="code" href="classllvm_1_1Value.html">Value</a> *&amp;Agg, <span class="keyword">const</span> <a class="code" href="classllvm_1_1Twine.html">Twine</a> &amp;<a class="code" href="namespacellvm_1_1GraphProgram.html#a0ad4685976f8c4d4a697a53fbe05d10b">Name</a>) {</div><div class="line"><a name="l02818"></a><span class="lineno"> 2818</span>&#160;      assert(Ty-&gt;<a class="code" href="classllvm_1_1Type.html#a36e21267fe14e69d3251eab1cd3a0076">isSingleValueType</a>());</div><div class="line"><a name="l02819"></a><span class="lineno"> 2819</span>&#160;      <span class="comment">// Load the single value and insert it using the indices.</span></div><div class="line"><a name="l02820"></a><span class="lineno"> 2820</span>&#160;      <a class="code" href="classllvm_1_1Value.html">Value</a> *GEP = IRB.CreateInBoundsGEP(Ptr, GEPIndices, Name + <span class="stringliteral">&quot;.gep&quot;</span>);</div><div class="line"><a name="l02821"></a><span class="lineno"> 2821</span>&#160;      <a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="namespacellvm_1_1SPII.html#a11e9b8fca4a074643a6a21f444e51406a5069619ca8fdce305534f3fe85091a0f">Load</a> = IRB.CreateLoad(GEP, Name + <span class="stringliteral">&quot;.load&quot;</span>);</div><div class="line"><a name="l02822"></a><span class="lineno"> 2822</span>&#160;      Agg = IRB.CreateInsertValue(Agg, Load, Indices, Name + <span class="stringliteral">&quot;.insert&quot;</span>);</div><div class="line"><a name="l02823"></a><span class="lineno"> 2823</span>&#160;      <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;          to: &quot;</span> &lt;&lt; *Load &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02824"></a><span class="lineno"> 2824</span>&#160;    }</div><div class="line"><a name="l02825"></a><span class="lineno"> 2825</span>&#160;  };</div><div class="line"><a name="l02826"></a><span class="lineno"> 2826</span>&#160;</div><div class="line"><a name="l02827"></a><span class="lineno"> 2827</span>&#160;  <span class="keywordtype">bool</span> visitLoadInst(<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> &amp;LI) {</div><div class="line"><a name="l02828"></a><span class="lineno"> 2828</span>&#160;    assert(LI.<a class="code" href="classllvm_1_1LoadInst.html#ad47eefa1d094f60494b6b927061ca001">getPointerOperand</a>() == *U);</div><div class="line"><a name="l02829"></a><span class="lineno"> 2829</span>&#160;    <span class="keywordflow">if</span> (!LI.<a class="code" href="classllvm_1_1LoadInst.html#a156c478ee8e7d1602143cdbad4bd5385">isSimple</a>() || LI.<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a36e21267fe14e69d3251eab1cd3a0076">isSingleValueType</a>())</div><div class="line"><a name="l02830"></a><span class="lineno"> 2830</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l02831"></a><span class="lineno"> 2831</span>&#160;</div><div class="line"><a name="l02832"></a><span class="lineno"> 2832</span>&#160;    <span class="comment">// We have an aggregate being loaded, split it apart.</span></div><div class="line"><a name="l02833"></a><span class="lineno"> 2833</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;    original: &quot;</span> &lt;&lt; LI &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02834"></a><span class="lineno"> 2834</span>&#160;    LoadOpSplitter Splitter(&amp;LI, *U);</div><div class="line"><a name="l02835"></a><span class="lineno"> 2835</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *V = <a class="code" href="classllvm_1_1UndefValue.html#a4ae5ff22b700a42bcc5d889233721335">UndefValue::get</a>(LI.<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>());</div><div class="line"><a name="l02836"></a><span class="lineno"> 2836</span>&#160;    Splitter.emitSplitOps(LI.<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>(), V, LI.<a class="code" href="classllvm_1_1Value.html#ad452febc1ac0b394876e640ec03ffa38">getName</a>() + <span class="stringliteral">&quot;.fca&quot;</span>);</div><div class="line"><a name="l02837"></a><span class="lineno"> 2837</span>&#160;    LI.<a class="code" href="classllvm_1_1Value.html#a3ab5fc45117b450e8bb04e564cb6e5f2">replaceAllUsesWith</a>(V);</div><div class="line"><a name="l02838"></a><span class="lineno"> 2838</span>&#160;    LI.<a class="code" href="classllvm_1_1Instruction.html#a6fe2f06b8a4b2c3d6308afb223a0238a">eraseFromParent</a>();</div><div class="line"><a name="l02839"></a><span class="lineno"> 2839</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l02840"></a><span class="lineno"> 2840</span>&#160;  }</div><div class="line"><a name="l02841"></a><span class="lineno"> 2841</span>&#160;</div><div class="line"><a name="l02842"></a><span class="lineno"> 2842</span>&#160;  <span class="keyword">struct </span>StoreOpSplitter : <span class="keyword">public</span> OpSplitter&lt;StoreOpSplitter&gt; {</div><div class="line"><a name="l02843"></a><span class="lineno"> 2843</span>&#160;    StoreOpSplitter(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *InsertionPoint, <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr)</div><div class="line"><a name="l02844"></a><span class="lineno"> 2844</span>&#160;      : OpSplitter&lt;StoreOpSplitter&gt;(InsertionPoint, Ptr) {}</div><div class="line"><a name="l02845"></a><span class="lineno"> 2845</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02846"></a><span class="lineno"> 2846</span>&#160;<span class="comment">    /// Emit a leaf store of a single value. This is called at the leaves of the</span></div><div class="line"><a name="l02847"></a><span class="lineno"> 2847</span>&#160;<span class="comment">    /// recursive emission to actually produce stores.</span></div><div class="line"><a name="l02848"></a><span class="lineno"> 2848</span>&#160;<span class="comment"></span>    <span class="keywordtype">void</span> emitFunc(<a class="code" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="code" href="classllvm_1_1Value.html">Value</a> *&amp;Agg, <span class="keyword">const</span> <a class="code" href="classllvm_1_1Twine.html">Twine</a> &amp;<a class="code" href="namespacellvm_1_1GraphProgram.html#a0ad4685976f8c4d4a697a53fbe05d10b">Name</a>) {</div><div class="line"><a name="l02849"></a><span class="lineno"> 2849</span>&#160;      assert(Ty-&gt;<a class="code" href="classllvm_1_1Type.html#a36e21267fe14e69d3251eab1cd3a0076">isSingleValueType</a>());</div><div class="line"><a name="l02850"></a><span class="lineno"> 2850</span>&#160;      <span class="comment">// Extract the single value and store it using the indices.</span></div><div class="line"><a name="l02851"></a><span class="lineno"> 2851</span>&#160;      <a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="namespacellvm_1_1SPII.html#a11e9b8fca4a074643a6a21f444e51406a36b3dd3b84fde3f8494a9b18af131856">Store</a> = IRB.CreateStore(</div><div class="line"><a name="l02852"></a><span class="lineno"> 2852</span>&#160;        IRB.CreateExtractValue(Agg, Indices, Name + <span class="stringliteral">&quot;.extract&quot;</span>),</div><div class="line"><a name="l02853"></a><span class="lineno"> 2853</span>&#160;        IRB.CreateInBoundsGEP(Ptr, GEPIndices, Name + <span class="stringliteral">&quot;.gep&quot;</span>));</div><div class="line"><a name="l02854"></a><span class="lineno"> 2854</span>&#160;      (void)Store;</div><div class="line"><a name="l02855"></a><span class="lineno"> 2855</span>&#160;      <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;          to: &quot;</span> &lt;&lt; *Store &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02856"></a><span class="lineno"> 2856</span>&#160;    }</div><div class="line"><a name="l02857"></a><span class="lineno"> 2857</span>&#160;  };</div><div class="line"><a name="l02858"></a><span class="lineno"> 2858</span>&#160;</div><div class="line"><a name="l02859"></a><span class="lineno"> 2859</span>&#160;  <span class="keywordtype">bool</span> visitStoreInst(<a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> &amp;SI) {</div><div class="line"><a name="l02860"></a><span class="lineno"> 2860</span>&#160;    <span class="keywordflow">if</span> (!SI.<a class="code" href="classllvm_1_1StoreInst.html#a1149c7eeefca671ac2685bca13843568">isSimple</a>() || SI.<a class="code" href="classllvm_1_1StoreInst.html#ac03c1c093059ea000216af8dd6f2dbf4">getPointerOperand</a>() != *U)</div><div class="line"><a name="l02861"></a><span class="lineno"> 2861</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l02862"></a><span class="lineno"> 2862</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *V = SI.<a class="code" href="classllvm_1_1StoreInst.html#a14298313bdf734e2db5a921cc6e861a0">getValueOperand</a>();</div><div class="line"><a name="l02863"></a><span class="lineno"> 2863</span>&#160;    <span class="keywordflow">if</span> (V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a36e21267fe14e69d3251eab1cd3a0076">isSingleValueType</a>())</div><div class="line"><a name="l02864"></a><span class="lineno"> 2864</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l02865"></a><span class="lineno"> 2865</span>&#160;</div><div class="line"><a name="l02866"></a><span class="lineno"> 2866</span>&#160;    <span class="comment">// We have an aggregate being stored, split it apart.</span></div><div class="line"><a name="l02867"></a><span class="lineno"> 2867</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;    original: &quot;</span> &lt;&lt; SI &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02868"></a><span class="lineno"> 2868</span>&#160;    StoreOpSplitter Splitter(&amp;SI, *U);</div><div class="line"><a name="l02869"></a><span class="lineno"> 2869</span>&#160;    Splitter.emitSplitOps(V-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>(), V, V-&gt;<a class="code" href="classllvm_1_1Value.html#ad452febc1ac0b394876e640ec03ffa38">getName</a>() + <span class="stringliteral">&quot;.fca&quot;</span>);</div><div class="line"><a name="l02870"></a><span class="lineno"> 2870</span>&#160;    SI.<a class="code" href="classllvm_1_1Instruction.html#a6fe2f06b8a4b2c3d6308afb223a0238a">eraseFromParent</a>();</div><div class="line"><a name="l02871"></a><span class="lineno"> 2871</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l02872"></a><span class="lineno"> 2872</span>&#160;  }</div><div class="line"><a name="l02873"></a><span class="lineno"> 2873</span>&#160;</div><div class="line"><a name="l02874"></a><span class="lineno"> 2874</span>&#160;  <span class="keywordtype">bool</span> visitBitCastInst(<a class="code" href="classllvm_1_1BitCastInst.html">BitCastInst</a> &amp;BC) {</div><div class="line"><a name="l02875"></a><span class="lineno"> 2875</span>&#160;    enqueueUsers(BC);</div><div class="line"><a name="l02876"></a><span class="lineno"> 2876</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l02877"></a><span class="lineno"> 2877</span>&#160;  }</div><div class="line"><a name="l02878"></a><span class="lineno"> 2878</span>&#160;</div><div class="line"><a name="l02879"></a><span class="lineno"> 2879</span>&#160;  <span class="keywordtype">bool</span> visitGetElementPtrInst(<a class="code" href="classllvm_1_1GetElementPtrInst.html">GetElementPtrInst</a> &amp;GEPI) {</div><div class="line"><a name="l02880"></a><span class="lineno"> 2880</span>&#160;    enqueueUsers(GEPI);</div><div class="line"><a name="l02881"></a><span class="lineno"> 2881</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l02882"></a><span class="lineno"> 2882</span>&#160;  }</div><div class="line"><a name="l02883"></a><span class="lineno"> 2883</span>&#160;</div><div class="line"><a name="l02884"></a><span class="lineno"> 2884</span>&#160;  <span class="keywordtype">bool</span> visitPHINode(<a class="code" href="classllvm_1_1PHINode.html">PHINode</a> &amp;PN) {</div><div class="line"><a name="l02885"></a><span class="lineno"> 2885</span>&#160;    enqueueUsers(PN);</div><div class="line"><a name="l02886"></a><span class="lineno"> 2886</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l02887"></a><span class="lineno"> 2887</span>&#160;  }</div><div class="line"><a name="l02888"></a><span class="lineno"> 2888</span>&#160;</div><div class="line"><a name="l02889"></a><span class="lineno"> 2889</span>&#160;  <span class="keywordtype">bool</span> visitSelectInst(<a class="code" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;SI) {</div><div class="line"><a name="l02890"></a><span class="lineno"> 2890</span>&#160;    enqueueUsers(SI);</div><div class="line"><a name="l02891"></a><span class="lineno"> 2891</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l02892"></a><span class="lineno"> 2892</span>&#160;  }</div><div class="line"><a name="l02893"></a><span class="lineno"> 2893</span>&#160;};</div><div class="line"><a name="l02894"></a><span class="lineno"> 2894</span>&#160;}</div><div class="line"><a name="l02895"></a><span class="lineno"> 2895</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02896"></a><span class="lineno"> 2896</span>&#160;<span class="comment">/// \brief Strip aggregate type wrapping.</span></div><div class="line"><a name="l02897"></a><span class="lineno"> 2897</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l02898"></a><span class="lineno"> 2898</span>&#160;<span class="comment">/// This removes no-op aggregate types wrapping an underlying type. It will</span></div><div class="line"><a name="l02899"></a><span class="lineno"> 2899</span>&#160;<span class="comment">/// strip as many layers of types as it can without changing either the type</span></div><div class="line"><a name="l02900"></a><span class="lineno"> 2900</span>&#160;<span class="comment">/// size or the allocated size.</span></div><div class="line"><a name="l02901"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#ac102ff32dace1cf8e8e6f9c9ec4d159c"> 2901</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="classllvm_1_1Type.html">Type</a> *<a class="code" href="SROA_8cpp.html#ac102ff32dace1cf8e8e6f9c9ec4d159c">stripAggregateTypeWrapping</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="code" href="classllvm_1_1Type.html">Type</a> *Ty) {</div><div class="line"><a name="l02902"></a><span class="lineno"> 2902</span>&#160;  <span class="keywordflow">if</span> (Ty-&gt;<a class="code" href="classllvm_1_1Type.html#a36e21267fe14e69d3251eab1cd3a0076">isSingleValueType</a>())</div><div class="line"><a name="l02903"></a><span class="lineno"> 2903</span>&#160;    <span class="keywordflow">return</span> Ty;</div><div class="line"><a name="l02904"></a><span class="lineno"> 2904</span>&#160;</div><div class="line"><a name="l02905"></a><span class="lineno"> 2905</span>&#160;  uint64_t AllocSize = DL.<a class="code" href="classllvm_1_1DataLayout.html#a1d6fcc02e91ba24510aba42660c90e29">getTypeAllocSize</a>(Ty);</div><div class="line"><a name="l02906"></a><span class="lineno"> 2906</span>&#160;  uint64_t TypeSize = DL.<a class="code" href="classllvm_1_1DataLayout.html#add914112e0b2935dda06ad5dfd3a31db">getTypeSizeInBits</a>(Ty);</div><div class="line"><a name="l02907"></a><span class="lineno"> 2907</span>&#160;</div><div class="line"><a name="l02908"></a><span class="lineno"> 2908</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *InnerTy;</div><div class="line"><a name="l02909"></a><span class="lineno"> 2909</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1ArrayType.html">ArrayType</a> *ArrTy = dyn_cast&lt;ArrayType&gt;(Ty)) {</div><div class="line"><a name="l02910"></a><span class="lineno"> 2910</span>&#160;    InnerTy = ArrTy-&gt;getElementType();</div><div class="line"><a name="l02911"></a><span class="lineno"> 2911</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1StructType.html">StructType</a> *STy = dyn_cast&lt;StructType&gt;(Ty)) {</div><div class="line"><a name="l02912"></a><span class="lineno"> 2912</span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1StructLayout.html">StructLayout</a> *SL = DL.<a class="code" href="classllvm_1_1DataLayout.html#a35c840104f32575e0d91422cf1ef3ce4">getStructLayout</a>(STy);</div><div class="line"><a name="l02913"></a><span class="lineno"> 2913</span>&#160;    <span class="keywordtype">unsigned</span> Index = SL-&gt;<a class="code" href="classllvm_1_1StructLayout.html#a795cfd43d30c44c33b97fe850bc0451f">getElementContainingOffset</a>(0);</div><div class="line"><a name="l02914"></a><span class="lineno"> 2914</span>&#160;    InnerTy = STy-&gt;getElementType(Index);</div><div class="line"><a name="l02915"></a><span class="lineno"> 2915</span>&#160;  } <span class="keywordflow">else</span> {</div><div class="line"><a name="l02916"></a><span class="lineno"> 2916</span>&#160;    <span class="keywordflow">return</span> Ty;</div><div class="line"><a name="l02917"></a><span class="lineno"> 2917</span>&#160;  }</div><div class="line"><a name="l02918"></a><span class="lineno"> 2918</span>&#160;</div><div class="line"><a name="l02919"></a><span class="lineno"> 2919</span>&#160;  <span class="keywordflow">if</span> (AllocSize &gt; DL.<a class="code" href="classllvm_1_1DataLayout.html#a1d6fcc02e91ba24510aba42660c90e29">getTypeAllocSize</a>(InnerTy) ||</div><div class="line"><a name="l02920"></a><span class="lineno"> 2920</span>&#160;      TypeSize &gt; DL.<a class="code" href="classllvm_1_1DataLayout.html#add914112e0b2935dda06ad5dfd3a31db">getTypeSizeInBits</a>(InnerTy))</div><div class="line"><a name="l02921"></a><span class="lineno"> 2921</span>&#160;    <span class="keywordflow">return</span> Ty;</div><div class="line"><a name="l02922"></a><span class="lineno"> 2922</span>&#160;</div><div class="line"><a name="l02923"></a><span class="lineno"> 2923</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="SROA_8cpp.html#ac102ff32dace1cf8e8e6f9c9ec4d159c">stripAggregateTypeWrapping</a>(DL, InnerTy);</div><div class="line"><a name="l02924"></a><span class="lineno"> 2924</span>&#160;}</div><div class="line"><a name="l02925"></a><span class="lineno"> 2925</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02926"></a><span class="lineno"> 2926</span>&#160;<span class="comment">/// \brief Try to find a partition of the aggregate type passed in for a given</span></div><div class="line"><a name="l02927"></a><span class="lineno"> 2927</span>&#160;<span class="comment">/// offset and size.</span></div><div class="line"><a name="l02928"></a><span class="lineno"> 2928</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l02929"></a><span class="lineno"> 2929</span>&#160;<span class="comment">/// This recurses through the aggregate type and tries to compute a subtype</span></div><div class="line"><a name="l02930"></a><span class="lineno"> 2930</span>&#160;<span class="comment">/// based on the offset and size. When the offset and size span a sub-section</span></div><div class="line"><a name="l02931"></a><span class="lineno"> 2931</span>&#160;<span class="comment">/// of an array, it will even compute a new array type for that sub-section,</span></div><div class="line"><a name="l02932"></a><span class="lineno"> 2932</span>&#160;<span class="comment">/// and the same for structs.</span></div><div class="line"><a name="l02933"></a><span class="lineno"> 2933</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l02934"></a><span class="lineno"> 2934</span>&#160;<span class="comment">/// Note that this routine is very strict and tries to find a partition of the</span></div><div class="line"><a name="l02935"></a><span class="lineno"> 2935</span>&#160;<span class="comment">/// type which produces the *exact* right offset and size. It is not forgiving</span></div><div class="line"><a name="l02936"></a><span class="lineno"> 2936</span>&#160;<span class="comment">/// when the size or offset cause either end of type-based partition to be off.</span></div><div class="line"><a name="l02937"></a><span class="lineno"> 2937</span>&#160;<span class="comment">/// Also, this is a best-effort routine. It is reasonable to give up and not</span></div><div class="line"><a name="l02938"></a><span class="lineno"> 2938</span>&#160;<span class="comment">/// return a type if necessary.</span></div><div class="line"><a name="l02939"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#abe75ff888b6a7ee2836aa6c8f33984c1"> 2939</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="classllvm_1_1Type.html">Type</a> *<a class="code" href="SROA_8cpp.html#abe75ff888b6a7ee2836aa6c8f33984c1">getTypePartition</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="code" href="classllvm_1_1Type.html">Type</a> *Ty,</div><div class="line"><a name="l02940"></a><span class="lineno"> 2940</span>&#160;                              uint64_t Offset, uint64_t Size) {</div><div class="line"><a name="l02941"></a><span class="lineno"> 2941</span>&#160;  <span class="keywordflow">if</span> (Offset == 0 &amp;&amp; DL.<a class="code" href="classllvm_1_1DataLayout.html#a1d6fcc02e91ba24510aba42660c90e29">getTypeAllocSize</a>(Ty) == Size)</div><div class="line"><a name="l02942"></a><span class="lineno"> 2942</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SROA_8cpp.html#ac102ff32dace1cf8e8e6f9c9ec4d159c">stripAggregateTypeWrapping</a>(DL, Ty);</div><div class="line"><a name="l02943"></a><span class="lineno"> 2943</span>&#160;  <span class="keywordflow">if</span> (Offset &gt; DL.<a class="code" href="classllvm_1_1DataLayout.html#a1d6fcc02e91ba24510aba42660c90e29">getTypeAllocSize</a>(Ty) ||</div><div class="line"><a name="l02944"></a><span class="lineno"> 2944</span>&#160;      (DL.<a class="code" href="classllvm_1_1DataLayout.html#a1d6fcc02e91ba24510aba42660c90e29">getTypeAllocSize</a>(Ty) - Offset) &lt; Size)</div><div class="line"><a name="l02945"></a><span class="lineno"> 2945</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l02946"></a><span class="lineno"> 2946</span>&#160;</div><div class="line"><a name="l02947"></a><span class="lineno"> 2947</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1SequentialType.html">SequentialType</a> *SeqTy = dyn_cast&lt;SequentialType&gt;(Ty)) {</div><div class="line"><a name="l02948"></a><span class="lineno"> 2948</span>&#160;    <span class="comment">// We can&#39;t partition pointers...</span></div><div class="line"><a name="l02949"></a><span class="lineno"> 2949</span>&#160;    <span class="keywordflow">if</span> (SeqTy-&gt;isPointerTy())</div><div class="line"><a name="l02950"></a><span class="lineno"> 2950</span>&#160;      <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l02951"></a><span class="lineno"> 2951</span>&#160;</div><div class="line"><a name="l02952"></a><span class="lineno"> 2952</span>&#160;    <a class="code" href="classllvm_1_1Type.html">Type</a> *ElementTy = SeqTy-&gt;getElementType();</div><div class="line"><a name="l02953"></a><span class="lineno"> 2953</span>&#160;    uint64_t ElementSize = DL.<a class="code" href="classllvm_1_1DataLayout.html#a1d6fcc02e91ba24510aba42660c90e29">getTypeAllocSize</a>(ElementTy);</div><div class="line"><a name="l02954"></a><span class="lineno"> 2954</span>&#160;    uint64_t NumSkippedElements = Offset / ElementSize;</div><div class="line"><a name="l02955"></a><span class="lineno"> 2955</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1ArrayType.html">ArrayType</a> *ArrTy = dyn_cast&lt;ArrayType&gt;(SeqTy)) {</div><div class="line"><a name="l02956"></a><span class="lineno"> 2956</span>&#160;      <span class="keywordflow">if</span> (NumSkippedElements &gt;= ArrTy-&gt;getNumElements())</div><div class="line"><a name="l02957"></a><span class="lineno"> 2957</span>&#160;        <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l02958"></a><span class="lineno"> 2958</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1VectorType.html">VectorType</a> *VecTy = dyn_cast&lt;VectorType&gt;(SeqTy)) {</div><div class="line"><a name="l02959"></a><span class="lineno"> 2959</span>&#160;      <span class="keywordflow">if</span> (NumSkippedElements &gt;= VecTy-&gt;getNumElements())</div><div class="line"><a name="l02960"></a><span class="lineno"> 2960</span>&#160;        <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l02961"></a><span class="lineno"> 2961</span>&#160;    }</div><div class="line"><a name="l02962"></a><span class="lineno"> 2962</span>&#160;    Offset -= NumSkippedElements * ElementSize;</div><div class="line"><a name="l02963"></a><span class="lineno"> 2963</span>&#160;</div><div class="line"><a name="l02964"></a><span class="lineno"> 2964</span>&#160;    <span class="comment">// First check if we need to recurse.</span></div><div class="line"><a name="l02965"></a><span class="lineno"> 2965</span>&#160;    <span class="keywordflow">if</span> (Offset &gt; 0 || Size &lt; ElementSize) {</div><div class="line"><a name="l02966"></a><span class="lineno"> 2966</span>&#160;      <span class="comment">// Bail if the partition ends in a different array element.</span></div><div class="line"><a name="l02967"></a><span class="lineno"> 2967</span>&#160;      <span class="keywordflow">if</span> ((Offset + Size) &gt; ElementSize)</div><div class="line"><a name="l02968"></a><span class="lineno"> 2968</span>&#160;        <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l02969"></a><span class="lineno"> 2969</span>&#160;      <span class="comment">// Recurse through the element type trying to peel off offset bytes.</span></div><div class="line"><a name="l02970"></a><span class="lineno"> 2970</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="SROA_8cpp.html#abe75ff888b6a7ee2836aa6c8f33984c1">getTypePartition</a>(DL, ElementTy, Offset, Size);</div><div class="line"><a name="l02971"></a><span class="lineno"> 2971</span>&#160;    }</div><div class="line"><a name="l02972"></a><span class="lineno"> 2972</span>&#160;    assert(Offset == 0);</div><div class="line"><a name="l02973"></a><span class="lineno"> 2973</span>&#160;</div><div class="line"><a name="l02974"></a><span class="lineno"> 2974</span>&#160;    <span class="keywordflow">if</span> (Size == ElementSize)</div><div class="line"><a name="l02975"></a><span class="lineno"> 2975</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="SROA_8cpp.html#ac102ff32dace1cf8e8e6f9c9ec4d159c">stripAggregateTypeWrapping</a>(DL, ElementTy);</div><div class="line"><a name="l02976"></a><span class="lineno"> 2976</span>&#160;    assert(Size &gt; ElementSize);</div><div class="line"><a name="l02977"></a><span class="lineno"> 2977</span>&#160;    uint64_t NumElements = Size / ElementSize;</div><div class="line"><a name="l02978"></a><span class="lineno"> 2978</span>&#160;    <span class="keywordflow">if</span> (NumElements * ElementSize != Size)</div><div class="line"><a name="l02979"></a><span class="lineno"> 2979</span>&#160;      <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l02980"></a><span class="lineno"> 2980</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1ArrayType.html#adf411edc4f135b570ab218079474ce77">ArrayType::get</a>(ElementTy, NumElements);</div><div class="line"><a name="l02981"></a><span class="lineno"> 2981</span>&#160;  }</div><div class="line"><a name="l02982"></a><span class="lineno"> 2982</span>&#160;</div><div class="line"><a name="l02983"></a><span class="lineno"> 2983</span>&#160;  <a class="code" href="classllvm_1_1StructType.html">StructType</a> *STy = <a class="code" href="namespacellvm.html#a3f2f98c2a67c9e79f58aad9150a62e42">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1StructType.html">StructType</a>&gt;(Ty);</div><div class="line"><a name="l02984"></a><span class="lineno"> 2984</span>&#160;  <span class="keywordflow">if</span> (!STy)</div><div class="line"><a name="l02985"></a><span class="lineno"> 2985</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l02986"></a><span class="lineno"> 2986</span>&#160;</div><div class="line"><a name="l02987"></a><span class="lineno"> 2987</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1StructLayout.html">StructLayout</a> *SL = DL.<a class="code" href="classllvm_1_1DataLayout.html#a35c840104f32575e0d91422cf1ef3ce4">getStructLayout</a>(STy);</div><div class="line"><a name="l02988"></a><span class="lineno"> 2988</span>&#160;  <span class="keywordflow">if</span> (Offset &gt;= SL-&gt;<a class="code" href="classllvm_1_1StructLayout.html#a582a5b21a8f91d7f713fa9d57c0525de">getSizeInBytes</a>())</div><div class="line"><a name="l02989"></a><span class="lineno"> 2989</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l02990"></a><span class="lineno"> 2990</span>&#160;  uint64_t EndOffset = Offset + Size;</div><div class="line"><a name="l02991"></a><span class="lineno"> 2991</span>&#160;  <span class="keywordflow">if</span> (EndOffset &gt; SL-&gt;<a class="code" href="classllvm_1_1StructLayout.html#a582a5b21a8f91d7f713fa9d57c0525de">getSizeInBytes</a>())</div><div class="line"><a name="l02992"></a><span class="lineno"> 2992</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l02993"></a><span class="lineno"> 2993</span>&#160;</div><div class="line"><a name="l02994"></a><span class="lineno"> 2994</span>&#160;  <span class="keywordtype">unsigned</span> Index = SL-&gt;<a class="code" href="classllvm_1_1StructLayout.html#a795cfd43d30c44c33b97fe850bc0451f">getElementContainingOffset</a>(Offset);</div><div class="line"><a name="l02995"></a><span class="lineno"> 2995</span>&#160;  Offset -= SL-&gt;<a class="code" href="classllvm_1_1StructLayout.html#ae10c4483372a357a0d3411b3d64be10c">getElementOffset</a>(Index);</div><div class="line"><a name="l02996"></a><span class="lineno"> 2996</span>&#160;</div><div class="line"><a name="l02997"></a><span class="lineno"> 2997</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *ElementTy = STy-&gt;<a class="code" href="classllvm_1_1StructType.html#a2f54639fcb5162f6f51192eb1697d2ad">getElementType</a>(Index);</div><div class="line"><a name="l02998"></a><span class="lineno"> 2998</span>&#160;  uint64_t ElementSize = DL.<a class="code" href="classllvm_1_1DataLayout.html#a1d6fcc02e91ba24510aba42660c90e29">getTypeAllocSize</a>(ElementTy);</div><div class="line"><a name="l02999"></a><span class="lineno"> 2999</span>&#160;  <span class="keywordflow">if</span> (Offset &gt;= ElementSize)</div><div class="line"><a name="l03000"></a><span class="lineno"> 3000</span>&#160;    <span class="keywordflow">return</span> 0; <span class="comment">// The offset points into alignment padding.</span></div><div class="line"><a name="l03001"></a><span class="lineno"> 3001</span>&#160;</div><div class="line"><a name="l03002"></a><span class="lineno"> 3002</span>&#160;  <span class="comment">// See if any partition must be contained by the element.</span></div><div class="line"><a name="l03003"></a><span class="lineno"> 3003</span>&#160;  <span class="keywordflow">if</span> (Offset &gt; 0 || Size &lt; ElementSize) {</div><div class="line"><a name="l03004"></a><span class="lineno"> 3004</span>&#160;    <span class="keywordflow">if</span> ((Offset + Size) &gt; ElementSize)</div><div class="line"><a name="l03005"></a><span class="lineno"> 3005</span>&#160;      <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l03006"></a><span class="lineno"> 3006</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SROA_8cpp.html#abe75ff888b6a7ee2836aa6c8f33984c1">getTypePartition</a>(DL, ElementTy, Offset, Size);</div><div class="line"><a name="l03007"></a><span class="lineno"> 3007</span>&#160;  }</div><div class="line"><a name="l03008"></a><span class="lineno"> 3008</span>&#160;  assert(Offset == 0);</div><div class="line"><a name="l03009"></a><span class="lineno"> 3009</span>&#160;</div><div class="line"><a name="l03010"></a><span class="lineno"> 3010</span>&#160;  <span class="keywordflow">if</span> (Size == ElementSize)</div><div class="line"><a name="l03011"></a><span class="lineno"> 3011</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SROA_8cpp.html#ac102ff32dace1cf8e8e6f9c9ec4d159c">stripAggregateTypeWrapping</a>(DL, ElementTy);</div><div class="line"><a name="l03012"></a><span class="lineno"> 3012</span>&#160;</div><div class="line"><a name="l03013"></a><span class="lineno"> 3013</span>&#160;  <a class="code" href="classllvm_1_1StructType.html#a93ee26a67ca79e4ba796dcccb55e8c19">StructType::element_iterator</a> EI = STy-&gt;<a class="code" href="classllvm_1_1StructType.html#a8d85840dbf6b7eff52721aafae9df0f6">element_begin</a>() + Index,</div><div class="line"><a name="l03014"></a><span class="lineno"> 3014</span>&#160;                               EE = STy-&gt;<a class="code" href="classllvm_1_1StructType.html#a1a716e87e6d2a1de3fcfd0682ed3fd1f">element_end</a>();</div><div class="line"><a name="l03015"></a><span class="lineno"> 3015</span>&#160;  <span class="keywordflow">if</span> (EndOffset &lt; SL-&gt;getSizeInBytes()) {</div><div class="line"><a name="l03016"></a><span class="lineno"> 3016</span>&#160;    <span class="keywordtype">unsigned</span> EndIndex = SL-&gt;<a class="code" href="classllvm_1_1StructLayout.html#a795cfd43d30c44c33b97fe850bc0451f">getElementContainingOffset</a>(EndOffset);</div><div class="line"><a name="l03017"></a><span class="lineno"> 3017</span>&#160;    <span class="keywordflow">if</span> (Index == EndIndex)</div><div class="line"><a name="l03018"></a><span class="lineno"> 3018</span>&#160;      <span class="keywordflow">return</span> 0; <span class="comment">// Within a single element and its padding.</span></div><div class="line"><a name="l03019"></a><span class="lineno"> 3019</span>&#160;</div><div class="line"><a name="l03020"></a><span class="lineno"> 3020</span>&#160;    <span class="comment">// Don&#39;t try to form &quot;natural&quot; types if the elements don&#39;t line up with the</span></div><div class="line"><a name="l03021"></a><span class="lineno"> 3021</span>&#160;    <span class="comment">// expected size.</span></div><div class="line"><a name="l03022"></a><span class="lineno"> 3022</span>&#160;    <span class="comment">// FIXME: We could potentially recurse down through the last element in the</span></div><div class="line"><a name="l03023"></a><span class="lineno"> 3023</span>&#160;    <span class="comment">// sub-struct to find a natural end point.</span></div><div class="line"><a name="l03024"></a><span class="lineno"> 3024</span>&#160;    <span class="keywordflow">if</span> (SL-&gt;<a class="code" href="classllvm_1_1StructLayout.html#ae10c4483372a357a0d3411b3d64be10c">getElementOffset</a>(EndIndex) != EndOffset)</div><div class="line"><a name="l03025"></a><span class="lineno"> 3025</span>&#160;      <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l03026"></a><span class="lineno"> 3026</span>&#160;</div><div class="line"><a name="l03027"></a><span class="lineno"> 3027</span>&#160;    assert(Index &lt; EndIndex);</div><div class="line"><a name="l03028"></a><span class="lineno"> 3028</span>&#160;    EE = STy-&gt;<a class="code" href="classllvm_1_1StructType.html#a8d85840dbf6b7eff52721aafae9df0f6">element_begin</a>() + EndIndex;</div><div class="line"><a name="l03029"></a><span class="lineno"> 3029</span>&#160;  }</div><div class="line"><a name="l03030"></a><span class="lineno"> 3030</span>&#160;</div><div class="line"><a name="l03031"></a><span class="lineno"> 3031</span>&#160;  <span class="comment">// Try to build up a sub-structure.</span></div><div class="line"><a name="l03032"></a><span class="lineno"> 3032</span>&#160;  <a class="code" href="classllvm_1_1StructType.html">StructType</a> *SubTy = <a class="code" href="classllvm_1_1StructType.html#a18fc4545474c6ebb6f7c547f64f4fb31">StructType::get</a>(STy-&gt;<a class="code" href="classllvm_1_1Type.html#af348d5ea83429d08ba891ca3dd0e92b2">getContext</a>(), <a class="code" href="namespacellvm.html#a0448108c43f3a226744d0a4c28c989f7">makeArrayRef</a>(EI, EE),</div><div class="line"><a name="l03033"></a><span class="lineno"> 3033</span>&#160;                                      STy-&gt;<a class="code" href="classllvm_1_1StructType.html#a883dd52cca7097874337641ca44473a0">isPacked</a>());</div><div class="line"><a name="l03034"></a><span class="lineno"> 3034</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1StructLayout.html">StructLayout</a> *SubSL = DL.<a class="code" href="classllvm_1_1DataLayout.html#a35c840104f32575e0d91422cf1ef3ce4">getStructLayout</a>(SubTy);</div><div class="line"><a name="l03035"></a><span class="lineno"> 3035</span>&#160;  <span class="keywordflow">if</span> (Size != SubSL-&gt;getSizeInBytes())</div><div class="line"><a name="l03036"></a><span class="lineno"> 3036</span>&#160;    <span class="keywordflow">return</span> 0; <span class="comment">// The sub-struct doesn&#39;t have quite the size needed.</span></div><div class="line"><a name="l03037"></a><span class="lineno"> 3037</span>&#160;</div><div class="line"><a name="l03038"></a><span class="lineno"> 3038</span>&#160;  <span class="keywordflow">return</span> SubTy;</div><div class="line"><a name="l03039"></a><span class="lineno"> 3039</span>&#160;}</div><div class="line"><a name="l03040"></a><span class="lineno"> 3040</span>&#160;<span class="comment"></span></div><div class="line"><a name="l03041"></a><span class="lineno"> 3041</span>&#160;<span class="comment">/// \brief Rewrite an alloca partition&#39;s users.</span></div><div class="line"><a name="l03042"></a><span class="lineno"> 3042</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l03043"></a><span class="lineno"> 3043</span>&#160;<span class="comment">/// This routine drives both of the rewriting goals of the SROA pass. It tries</span></div><div class="line"><a name="l03044"></a><span class="lineno"> 3044</span>&#160;<span class="comment">/// to rewrite uses of an alloca partition to be conducive for SSA value</span></div><div class="line"><a name="l03045"></a><span class="lineno"> 3045</span>&#160;<span class="comment">/// promotion. If the partition needs a new, more refined alloca, this will</span></div><div class="line"><a name="l03046"></a><span class="lineno"> 3046</span>&#160;<span class="comment">/// build that new alloca, preserving as much type information as possible, and</span></div><div class="line"><a name="l03047"></a><span class="lineno"> 3047</span>&#160;<span class="comment">/// rewrite the uses of the old alloca to point at the new one and have the</span></div><div class="line"><a name="l03048"></a><span class="lineno"> 3048</span>&#160;<span class="comment">/// appropriate new offsets. It also evaluates how successful the rewrite was</span></div><div class="line"><a name="l03049"></a><span class="lineno"> 3049</span>&#160;<span class="comment">/// at enabling promotion and if it was successful queues the alloca to be</span></div><div class="line"><a name="l03050"></a><span class="lineno"> 3050</span>&#160;<span class="comment">/// promoted.</span></div><div class="line"><a name="l03051"></a><span class="lineno"> 3051</span>&#160;<span class="comment"></span><span class="keywordtype">bool</span> SROA::rewritePartition(<a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> &amp;AI, AllocaSlices &amp;<a class="code" href="Target_2ARM_2README_8txt.html#a1b45f45820a60c09244a87eb59824aec">S</a>,</div><div class="line"><a name="l03052"></a><span class="lineno"> 3052</span>&#160;                            <a class="code" href="classT.html">AllocaSlices::iterator</a> <a class="code" href="Target_2ARM_2README_8txt.html#a90cca76dd78688687e0d697679dbc799">B</a>, <a class="code" href="classT.html">AllocaSlices::iterator</a> E,</div><div class="line"><a name="l03053"></a><span class="lineno"> 3053</span>&#160;                            int64_t BeginOffset, int64_t EndOffset,</div><div class="line"><a name="l03054"></a><span class="lineno"> 3054</span>&#160;                            <a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;AllocaSlices::iterator&gt;</a> SplitUses) {</div><div class="line"><a name="l03055"></a><span class="lineno"> 3055</span>&#160;  assert(BeginOffset &lt; EndOffset);</div><div class="line"><a name="l03056"></a><span class="lineno"> 3056</span>&#160;  uint64_t SliceSize = EndOffset - BeginOffset;</div><div class="line"><a name="l03057"></a><span class="lineno"> 3057</span>&#160;</div><div class="line"><a name="l03058"></a><span class="lineno"> 3058</span>&#160;  <span class="comment">// Try to compute a friendly type for this partition of the alloca. This</span></div><div class="line"><a name="l03059"></a><span class="lineno"> 3059</span>&#160;  <span class="comment">// won&#39;t always succeed, in which case we fall back to a legal integer type</span></div><div class="line"><a name="l03060"></a><span class="lineno"> 3060</span>&#160;  <span class="comment">// or an i8 array of an appropriate size.</span></div><div class="line"><a name="l03061"></a><span class="lineno"> 3061</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *SliceTy = 0;</div><div class="line"><a name="l03062"></a><span class="lineno"> 3062</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1Type.html">Type</a> *CommonUseTy = <a class="code" href="SROA_8cpp.html#ae4bd66bcc8e0dce3d4d67880b77c6b1b">findCommonType</a>(B, E, EndOffset))</div><div class="line"><a name="l03063"></a><span class="lineno"> 3063</span>&#160;    <span class="keywordflow">if</span> (DL-&gt;getTypeAllocSize(CommonUseTy) &gt;= SliceSize)</div><div class="line"><a name="l03064"></a><span class="lineno"> 3064</span>&#160;      SliceTy = CommonUseTy;</div><div class="line"><a name="l03065"></a><span class="lineno"> 3065</span>&#160;  <span class="keywordflow">if</span> (!SliceTy)</div><div class="line"><a name="l03066"></a><span class="lineno"> 3066</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1Type.html">Type</a> *TypePartitionTy = <a class="code" href="SROA_8cpp.html#abe75ff888b6a7ee2836aa6c8f33984c1">getTypePartition</a>(*DL, AI.<a class="code" href="classllvm_1_1AllocaInst.html#a214c60dbb4f1ed467e5a3420db6eefd6">getAllocatedType</a>(),</div><div class="line"><a name="l03067"></a><span class="lineno"> 3067</span>&#160;                                                 BeginOffset, SliceSize))</div><div class="line"><a name="l03068"></a><span class="lineno"> 3068</span>&#160;      SliceTy = TypePartitionTy;</div><div class="line"><a name="l03069"></a><span class="lineno"> 3069</span>&#160;  <span class="keywordflow">if</span> ((!SliceTy || (SliceTy-&gt;<a class="code" href="classllvm_1_1Type.html#a9aae7c60b468bcf6db982dc76e6c703a">isArrayTy</a>() &amp;&amp;</div><div class="line"><a name="l03070"></a><span class="lineno"> 3070</span>&#160;                    SliceTy-&gt;<a class="code" href="classllvm_1_1Type.html#acae189c1d913af7e7f37a8b202070997">getArrayElementType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a6e328feb83afa5cf1c966d6704e43fc1">isIntegerTy</a>())) &amp;&amp;</div><div class="line"><a name="l03071"></a><span class="lineno"> 3071</span>&#160;      DL-&gt;isLegalInteger(SliceSize * 8))</div><div class="line"><a name="l03072"></a><span class="lineno"> 3072</span>&#160;    SliceTy = <a class="code" href="classllvm_1_1Type.html#acaf8e4c3e40e01e848c1fad5f05b81cd">Type::getIntNTy</a>(*<a class="code" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>, SliceSize * 8);</div><div class="line"><a name="l03073"></a><span class="lineno"> 3073</span>&#160;  <span class="keywordflow">if</span> (!SliceTy)</div><div class="line"><a name="l03074"></a><span class="lineno"> 3074</span>&#160;    SliceTy = <a class="code" href="classllvm_1_1ArrayType.html#adf411edc4f135b570ab218079474ce77">ArrayType::get</a>(<a class="code" href="classllvm_1_1Type.html#a7ba5de75f50bb4a4ba920698edf39b28">Type::getInt8Ty</a>(*<a class="code" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a>), SliceSize);</div><div class="line"><a name="l03075"></a><span class="lineno"> 3075</span>&#160;  assert(DL-&gt;getTypeAllocSize(SliceTy) &gt;= SliceSize);</div><div class="line"><a name="l03076"></a><span class="lineno"> 3076</span>&#160;</div><div class="line"><a name="l03077"></a><span class="lineno"> 3077</span>&#160;  <span class="keywordtype">bool</span> IsVectorPromotable = <a class="code" href="SROA_8cpp.html#a581dd5bca5410ba43e8cf06d949fa7f2">isVectorPromotionViable</a>(</div><div class="line"><a name="l03078"></a><span class="lineno"> 3078</span>&#160;      *DL, SliceTy, S, BeginOffset, EndOffset, B, E, SplitUses);</div><div class="line"><a name="l03079"></a><span class="lineno"> 3079</span>&#160;</div><div class="line"><a name="l03080"></a><span class="lineno"> 3080</span>&#160;  <span class="keywordtype">bool</span> IsIntegerPromotable =</div><div class="line"><a name="l03081"></a><span class="lineno"> 3081</span>&#160;      !IsVectorPromotable &amp;&amp;</div><div class="line"><a name="l03082"></a><span class="lineno"> 3082</span>&#160;      <a class="code" href="SROA_8cpp.html#a75f170d10487be0c2a7862177b2c18e7">isIntegerWideningViable</a>(*DL, SliceTy, BeginOffset, S, B, E, SplitUses);</div><div class="line"><a name="l03083"></a><span class="lineno"> 3083</span>&#160;</div><div class="line"><a name="l03084"></a><span class="lineno"> 3084</span>&#160;  <span class="comment">// Check for the case where we&#39;re going to rewrite to a new alloca of the</span></div><div class="line"><a name="l03085"></a><span class="lineno"> 3085</span>&#160;  <span class="comment">// exact same type as the original, and with the same access offsets. In that</span></div><div class="line"><a name="l03086"></a><span class="lineno"> 3086</span>&#160;  <span class="comment">// case, re-use the existing alloca, but still run through the rewriter to</span></div><div class="line"><a name="l03087"></a><span class="lineno"> 3087</span>&#160;  <span class="comment">// perform phi and select speculation.</span></div><div class="line"><a name="l03088"></a><span class="lineno"> 3088</span>&#160;  <a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> *NewAI;</div><div class="line"><a name="l03089"></a><span class="lineno"> 3089</span>&#160;  <span class="keywordflow">if</span> (SliceTy == AI.<a class="code" href="classllvm_1_1AllocaInst.html#a214c60dbb4f1ed467e5a3420db6eefd6">getAllocatedType</a>()) {</div><div class="line"><a name="l03090"></a><span class="lineno"> 3090</span>&#160;    assert(BeginOffset == 0 &amp;&amp;</div><div class="line"><a name="l03091"></a><span class="lineno"> 3091</span>&#160;           <span class="stringliteral">&quot;Non-zero begin offset but same alloca type&quot;</span>);</div><div class="line"><a name="l03092"></a><span class="lineno"> 3092</span>&#160;    NewAI = &amp;AI;</div><div class="line"><a name="l03093"></a><span class="lineno"> 3093</span>&#160;    <span class="comment">// FIXME: We should be able to bail at this point with &quot;nothing changed&quot;.</span></div><div class="line"><a name="l03094"></a><span class="lineno"> 3094</span>&#160;    <span class="comment">// FIXME: We might want to defer PHI speculation until after here.</span></div><div class="line"><a name="l03095"></a><span class="lineno"> 3095</span>&#160;  } <span class="keywordflow">else</span> {</div><div class="line"><a name="l03096"></a><span class="lineno"> 3096</span>&#160;    <span class="keywordtype">unsigned</span> Alignment = AI.<a class="code" href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">getAlignment</a>();</div><div class="line"><a name="l03097"></a><span class="lineno"> 3097</span>&#160;    <span class="keywordflow">if</span> (!Alignment) {</div><div class="line"><a name="l03098"></a><span class="lineno"> 3098</span>&#160;      <span class="comment">// The minimum alignment which users can rely on when the explicit</span></div><div class="line"><a name="l03099"></a><span class="lineno"> 3099</span>&#160;      <span class="comment">// alignment is omitted or zero is that required by the ABI for this</span></div><div class="line"><a name="l03100"></a><span class="lineno"> 3100</span>&#160;      <span class="comment">// type.</span></div><div class="line"><a name="l03101"></a><span class="lineno"> 3101</span>&#160;      Alignment = DL-&gt;getABITypeAlignment(AI.<a class="code" href="classllvm_1_1AllocaInst.html#a214c60dbb4f1ed467e5a3420db6eefd6">getAllocatedType</a>());</div><div class="line"><a name="l03102"></a><span class="lineno"> 3102</span>&#160;    }</div><div class="line"><a name="l03103"></a><span class="lineno"> 3103</span>&#160;    Alignment = <a class="code" href="namespacellvm.html#af36d7e69ab16b64b2e3a48c83aa9f0f6">MinAlign</a>(Alignment, BeginOffset);</div><div class="line"><a name="l03104"></a><span class="lineno"> 3104</span>&#160;    <span class="comment">// If we will get at least this much alignment from the type alone, leave</span></div><div class="line"><a name="l03105"></a><span class="lineno"> 3105</span>&#160;    <span class="comment">// the alloca&#39;s alignment unconstrained.</span></div><div class="line"><a name="l03106"></a><span class="lineno"> 3106</span>&#160;    <span class="keywordflow">if</span> (Alignment &lt;= DL-&gt;getABITypeAlignment(SliceTy))</div><div class="line"><a name="l03107"></a><span class="lineno"> 3107</span>&#160;      Alignment = 0;</div><div class="line"><a name="l03108"></a><span class="lineno"> 3108</span>&#160;    NewAI = <span class="keyword">new</span> <a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a>(SliceTy, 0, Alignment,</div><div class="line"><a name="l03109"></a><span class="lineno"> 3109</span>&#160;                           AI.<a class="code" href="classllvm_1_1Value.html#ad452febc1ac0b394876e640ec03ffa38">getName</a>() + <span class="stringliteral">&quot;.sroa.&quot;</span> + <a class="code" href="classllvm_1_1Twine.html">Twine</a>(B - S.begin()), &amp;AI);</div><div class="line"><a name="l03110"></a><span class="lineno"> 3110</span>&#160;    ++NumNewAllocas;</div><div class="line"><a name="l03111"></a><span class="lineno"> 3111</span>&#160;  }</div><div class="line"><a name="l03112"></a><span class="lineno"> 3112</span>&#160;</div><div class="line"><a name="l03113"></a><span class="lineno"> 3113</span>&#160;  <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;Rewriting alloca partition &quot;</span></div><div class="line"><a name="l03114"></a><span class="lineno"> 3114</span>&#160;               &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; BeginOffset &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; EndOffset &lt;&lt; <span class="stringliteral">&quot;) to: &quot;</span> &lt;&lt; *NewAI</div><div class="line"><a name="l03115"></a><span class="lineno"> 3115</span>&#160;               &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l03116"></a><span class="lineno"> 3116</span>&#160;</div><div class="line"><a name="l03117"></a><span class="lineno"> 3117</span>&#160;  <span class="comment">// Track the high watermark on several worklists that are only relevant for</span></div><div class="line"><a name="l03118"></a><span class="lineno"> 3118</span>&#160;  <span class="comment">// promoted allocas. We will reset it to this point if the alloca is not in</span></div><div class="line"><a name="l03119"></a><span class="lineno"> 3119</span>&#160;  <span class="comment">// fact scheduled for promotion.</span></div><div class="line"><a name="l03120"></a><span class="lineno"> 3120</span>&#160;  <span class="keywordtype">unsigned</span> PPWOldSize = PostPromotionWorklist.size();</div><div class="line"><a name="l03121"></a><span class="lineno"> 3121</span>&#160;  <span class="keywordtype">unsigned</span> SPOldSize = SpeculatablePHIs.size();</div><div class="line"><a name="l03122"></a><span class="lineno"> 3122</span>&#160;  <span class="keywordtype">unsigned</span> SSOldSize = SpeculatableSelects.size();</div><div class="line"><a name="l03123"></a><span class="lineno"> 3123</span>&#160;  <span class="keywordtype">unsigned</span> NumUses = 0;</div><div class="line"><a name="l03124"></a><span class="lineno"> 3124</span>&#160;</div><div class="line"><a name="l03125"></a><span class="lineno"> 3125</span>&#160;  AllocaSliceRewriter <a class="code" href="VirtRegMap_8cpp.html#a1ad52109a2ff430460c8776286b97b2e">Rewriter</a>(*DL, S, *<span class="keyword">this</span>, AI, *NewAI, BeginOffset,</div><div class="line"><a name="l03126"></a><span class="lineno"> 3126</span>&#160;                               EndOffset, IsVectorPromotable,</div><div class="line"><a name="l03127"></a><span class="lineno"> 3127</span>&#160;                               IsIntegerPromotable);</div><div class="line"><a name="l03128"></a><span class="lineno"> 3128</span>&#160;  <span class="keywordtype">bool</span> Promotable = <span class="keyword">true</span>;</div><div class="line"><a name="l03129"></a><span class="lineno"> 3129</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1SUnit.html">ArrayRef&lt;AllocaSlices::iterator&gt;::const_iterator</a> SUI = SplitUses.<a class="code" href="classllvm_1_1ArrayRef.html#a836367b39ed630bf14db99923c22740e">begin</a>(),</div><div class="line"><a name="l03130"></a><span class="lineno"> 3130</span>&#160;                                                        SUE = SplitUses.<a class="code" href="classllvm_1_1ArrayRef.html#a38ed8cc3c342ad6910e8c869d3e2b9cf">end</a>();</div><div class="line"><a name="l03131"></a><span class="lineno"> 3131</span>&#160;       SUI != SUE; ++SUI) {</div><div class="line"><a name="l03132"></a><span class="lineno"> 3132</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;  rewriting split &quot;</span>);</div><div class="line"><a name="l03133"></a><span class="lineno"> 3133</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(S.printSlice(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>(), *SUI, <span class="stringliteral">&quot;&quot;</span>));</div><div class="line"><a name="l03134"></a><span class="lineno"> 3134</span>&#160;    Promotable &amp;= Rewriter.visit(*SUI);</div><div class="line"><a name="l03135"></a><span class="lineno"> 3135</span>&#160;    ++NumUses;</div><div class="line"><a name="l03136"></a><span class="lineno"> 3136</span>&#160;  }</div><div class="line"><a name="l03137"></a><span class="lineno"> 3137</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classT.html">AllocaSlices::iterator</a> <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> = B; <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> != E; ++<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) {</div><div class="line"><a name="l03138"></a><span class="lineno"> 3138</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;  rewriting &quot;</span>);</div><div class="line"><a name="l03139"></a><span class="lineno"> 3139</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(S.printSlice(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>(), <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <span class="stringliteral">&quot;&quot;</span>));</div><div class="line"><a name="l03140"></a><span class="lineno"> 3140</span>&#160;    Promotable &amp;= Rewriter.visit(<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>);</div><div class="line"><a name="l03141"></a><span class="lineno"> 3141</span>&#160;    ++NumUses;</div><div class="line"><a name="l03142"></a><span class="lineno"> 3142</span>&#160;  }</div><div class="line"><a name="l03143"></a><span class="lineno"> 3143</span>&#160;</div><div class="line"><a name="l03144"></a><span class="lineno"> 3144</span>&#160;  NumAllocaPartitionUses += NumUses;</div><div class="line"><a name="l03145"></a><span class="lineno"> 3145</span>&#160;  MaxUsesPerAllocaPartition =</div><div class="line"><a name="l03146"></a><span class="lineno"> 3146</span>&#160;      std::max&lt;unsigned&gt;(NumUses, MaxUsesPerAllocaPartition);</div><div class="line"><a name="l03147"></a><span class="lineno"> 3147</span>&#160;</div><div class="line"><a name="l03148"></a><span class="lineno"> 3148</span>&#160;  <span class="keywordflow">if</span> (Promotable &amp;&amp; !Rewriter.isUsedByRewrittenSpeculatableInstructions()) {</div><div class="line"><a name="l03149"></a><span class="lineno"> 3149</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;  and queuing for promotion\n&quot;</span>);</div><div class="line"><a name="l03150"></a><span class="lineno"> 3150</span>&#160;    PromotableAllocas.push_back(NewAI);</div><div class="line"><a name="l03151"></a><span class="lineno"> 3151</span>&#160;  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (NewAI != &amp;AI ||</div><div class="line"><a name="l03152"></a><span class="lineno"> 3152</span>&#160;             (Promotable &amp;&amp;</div><div class="line"><a name="l03153"></a><span class="lineno"> 3153</span>&#160;              Rewriter.isUsedByRewrittenSpeculatableInstructions())) {</div><div class="line"><a name="l03154"></a><span class="lineno"> 3154</span>&#160;    <span class="comment">// If we can&#39;t promote the alloca, iterate on it to check for new</span></div><div class="line"><a name="l03155"></a><span class="lineno"> 3155</span>&#160;    <span class="comment">// refinements exposed by splitting the current alloca. Don&#39;t iterate on an</span></div><div class="line"><a name="l03156"></a><span class="lineno"> 3156</span>&#160;    <span class="comment">// alloca which didn&#39;t actually change and didn&#39;t get promoted.</span></div><div class="line"><a name="l03157"></a><span class="lineno"> 3157</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l03158"></a><span class="lineno"> 3158</span>&#160;    <span class="comment">// Alternatively, if we could promote the alloca but have speculatable</span></div><div class="line"><a name="l03159"></a><span class="lineno"> 3159</span>&#160;    <span class="comment">// instructions then we will speculate them after finishing our processing</span></div><div class="line"><a name="l03160"></a><span class="lineno"> 3160</span>&#160;    <span class="comment">// of the original alloca. Mark the new one for re-visiting in the next</span></div><div class="line"><a name="l03161"></a><span class="lineno"> 3161</span>&#160;    <span class="comment">// iteration so the speculated operations can be rewritten.</span></div><div class="line"><a name="l03162"></a><span class="lineno"> 3162</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l03163"></a><span class="lineno"> 3163</span>&#160;    <span class="comment">// FIXME: We should actually track whether the rewriter changed anything.</span></div><div class="line"><a name="l03164"></a><span class="lineno"> 3164</span>&#160;    Worklist.insert(NewAI);</div><div class="line"><a name="l03165"></a><span class="lineno"> 3165</span>&#160;  }</div><div class="line"><a name="l03166"></a><span class="lineno"> 3166</span>&#160;</div><div class="line"><a name="l03167"></a><span class="lineno"> 3167</span>&#160;  <span class="comment">// Drop any post-promotion work items if promotion didn&#39;t happen.</span></div><div class="line"><a name="l03168"></a><span class="lineno"> 3168</span>&#160;  <span class="keywordflow">if</span> (!Promotable) {</div><div class="line"><a name="l03169"></a><span class="lineno"> 3169</span>&#160;    <span class="keywordflow">while</span> (PostPromotionWorklist.size() &gt; PPWOldSize)</div><div class="line"><a name="l03170"></a><span class="lineno"> 3170</span>&#160;      PostPromotionWorklist.pop_back();</div><div class="line"><a name="l03171"></a><span class="lineno"> 3171</span>&#160;    <span class="keywordflow">while</span> (SpeculatablePHIs.size() &gt; SPOldSize)</div><div class="line"><a name="l03172"></a><span class="lineno"> 3172</span>&#160;      SpeculatablePHIs.pop_back();</div><div class="line"><a name="l03173"></a><span class="lineno"> 3173</span>&#160;    <span class="keywordflow">while</span> (SpeculatableSelects.size() &gt; SSOldSize)</div><div class="line"><a name="l03174"></a><span class="lineno"> 3174</span>&#160;      SpeculatableSelects.pop_back();</div><div class="line"><a name="l03175"></a><span class="lineno"> 3175</span>&#160;  }</div><div class="line"><a name="l03176"></a><span class="lineno"> 3176</span>&#160;</div><div class="line"><a name="l03177"></a><span class="lineno"> 3177</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l03178"></a><span class="lineno"> 3178</span>&#160;}</div><div class="line"><a name="l03179"></a><span class="lineno"> 3179</span>&#160;</div><div class="line"><a name="l03180"></a><span class="lineno"> 3180</span>&#160;<span class="keyword">namespace </span>{</div><div class="line"><a name="l03181"></a><span class="lineno"> 3181</span>&#160;<span class="keyword">struct </span>IsSliceEndLessOrEqualTo {</div><div class="line"><a name="l03182"></a><span class="lineno"> 3182</span>&#160;  uint64_t UpperBound;</div><div class="line"><a name="l03183"></a><span class="lineno"> 3183</span>&#160;</div><div class="line"><a name="l03184"></a><span class="lineno"> 3184</span>&#160;  IsSliceEndLessOrEqualTo(uint64_t UpperBound) : UpperBound(UpperBound) {}</div><div class="line"><a name="l03185"></a><span class="lineno"> 3185</span>&#160;</div><div class="line"><a name="l03186"></a><span class="lineno"> 3186</span>&#160;  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="classT.html">AllocaSlices::iterator</a> &amp;<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) {</div><div class="line"><a name="l03187"></a><span class="lineno"> 3187</span>&#160;    <span class="keywordflow">return</span> I-&gt;endOffset() &lt;= UpperBound;</div><div class="line"><a name="l03188"></a><span class="lineno"> 3188</span>&#160;  }</div><div class="line"><a name="l03189"></a><span class="lineno"> 3189</span>&#160;};</div><div class="line"><a name="l03190"></a><span class="lineno"> 3190</span>&#160;}</div><div class="line"><a name="l03191"></a><span class="lineno"> 3191</span>&#160;</div><div class="line"><a name="l03192"></a><span class="lineno"> 3192</span>&#160;<span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line"><a name="l03193"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#a1564307938a15a117873a7ab9a27e0a9"> 3193</a></span>&#160;<a class="code" href="SROA_8cpp.html#a1564307938a15a117873a7ab9a27e0a9">removeFinishedSplitUses</a>(<a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;AllocaSlices::iterator&gt;</a> &amp;SplitUses,</div><div class="line"><a name="l03194"></a><span class="lineno"> 3194</span>&#160;                        uint64_t &amp;MaxSplitUseEndOffset, uint64_t Offset) {</div><div class="line"><a name="l03195"></a><span class="lineno"> 3195</span>&#160;  <span class="keywordflow">if</span> (Offset &gt;= MaxSplitUseEndOffset) {</div><div class="line"><a name="l03196"></a><span class="lineno"> 3196</span>&#160;    SplitUses.<a class="code" href="classllvm_1_1SmallVectorImpl.html#aac0ea55010b7b1a301e65a0baea057aa">clear</a>();</div><div class="line"><a name="l03197"></a><span class="lineno"> 3197</span>&#160;    MaxSplitUseEndOffset = 0;</div><div class="line"><a name="l03198"></a><span class="lineno"> 3198</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l03199"></a><span class="lineno"> 3199</span>&#160;  }</div><div class="line"><a name="l03200"></a><span class="lineno"> 3200</span>&#160;</div><div class="line"><a name="l03201"></a><span class="lineno"> 3201</span>&#160;  <span class="keywordtype">size_t</span> SplitUsesOldSize = SplitUses.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a22a311dfe4c28a897de8a9365a4f0a84">size</a>();</div><div class="line"><a name="l03202"></a><span class="lineno"> 3202</span>&#160;  SplitUses.<a class="code" href="classllvm_1_1SmallVectorImpl.html#a18c110c35e9133222a37b28d30f8a90f">erase</a>(std::remove_if(SplitUses.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a8a045d250952c0867382a9840ee18fdf">begin</a>(), SplitUses.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a075e34e98605d0e7c289763a104869ac">end</a>(),</div><div class="line"><a name="l03203"></a><span class="lineno"> 3203</span>&#160;                                 IsSliceEndLessOrEqualTo(Offset)),</div><div class="line"><a name="l03204"></a><span class="lineno"> 3204</span>&#160;                  SplitUses.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a075e34e98605d0e7c289763a104869ac">end</a>());</div><div class="line"><a name="l03205"></a><span class="lineno"> 3205</span>&#160;  <span class="keywordflow">if</span> (SplitUsesOldSize == SplitUses.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a22a311dfe4c28a897de8a9365a4f0a84">size</a>())</div><div class="line"><a name="l03206"></a><span class="lineno"> 3206</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l03207"></a><span class="lineno"> 3207</span>&#160;</div><div class="line"><a name="l03208"></a><span class="lineno"> 3208</span>&#160;  <span class="comment">// Recompute the max. While this is linear, so is remove_if.</span></div><div class="line"><a name="l03209"></a><span class="lineno"> 3209</span>&#160;  MaxSplitUseEndOffset = 0;</div><div class="line"><a name="l03210"></a><span class="lineno"> 3210</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classT.html">SmallVectorImpl&lt;AllocaSlices::iterator&gt;::iterator</a></div><div class="line"><a name="l03211"></a><span class="lineno"> 3211</span>&#160;           SUI = SplitUses.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a8a045d250952c0867382a9840ee18fdf">begin</a>(),</div><div class="line"><a name="l03212"></a><span class="lineno"> 3212</span>&#160;           SUE = SplitUses.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a075e34e98605d0e7c289763a104869ac">end</a>();</div><div class="line"><a name="l03213"></a><span class="lineno"> 3213</span>&#160;       SUI != SUE; ++SUI)</div><div class="line"><a name="l03214"></a><span class="lineno"> 3214</span>&#160;    MaxSplitUseEndOffset = std::max((*SUI)-&gt;endOffset(), MaxSplitUseEndOffset);</div><div class="line"><a name="l03215"></a><span class="lineno"> 3215</span>&#160;}</div><div class="line"><a name="l03216"></a><span class="lineno"> 3216</span>&#160;<span class="comment"></span></div><div class="line"><a name="l03217"></a><span class="lineno"> 3217</span>&#160;<span class="comment">/// \brief Walks the slices of an alloca and form partitions based on them,</span></div><div class="line"><a name="l03218"></a><span class="lineno"> 3218</span>&#160;<span class="comment">/// rewriting each of their uses.</span></div><div class="line"><a name="l03219"></a><span class="lineno"> 3219</span>&#160;<span class="comment"></span><span class="keywordtype">bool</span> SROA::splitAlloca(<a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> &amp;AI, AllocaSlices &amp;S) {</div><div class="line"><a name="l03220"></a><span class="lineno"> 3220</span>&#160;  <span class="keywordflow">if</span> (S.begin() == S.end())</div><div class="line"><a name="l03221"></a><span class="lineno"> 3221</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l03222"></a><span class="lineno"> 3222</span>&#160;</div><div class="line"><a name="l03223"></a><span class="lineno"> 3223</span>&#160;  <span class="keywordtype">unsigned</span> NumPartitions = 0;</div><div class="line"><a name="l03224"></a><span class="lineno"> 3224</span>&#160;  <span class="keywordtype">bool</span> Changed = <span class="keyword">false</span>;</div><div class="line"><a name="l03225"></a><span class="lineno"> 3225</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;AllocaSlices::iterator, 4&gt;</a> SplitUses;</div><div class="line"><a name="l03226"></a><span class="lineno"> 3226</span>&#160;  uint64_t MaxSplitUseEndOffset = 0;</div><div class="line"><a name="l03227"></a><span class="lineno"> 3227</span>&#160;</div><div class="line"><a name="l03228"></a><span class="lineno"> 3228</span>&#160;  uint64_t BeginOffset = S.begin()-&gt;beginOffset();</div><div class="line"><a name="l03229"></a><span class="lineno"> 3229</span>&#160;</div><div class="line"><a name="l03230"></a><span class="lineno"> 3230</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classT.html">AllocaSlices::iterator</a> SI = S.begin(), SJ = <a class="code" href="namespacellvm.html#aa1704159f75e6eacd595962ea6d93ffe">llvm::next</a>(SI), SE = S.end();</div><div class="line"><a name="l03231"></a><span class="lineno"> 3231</span>&#160;       SI != SE; SI = SJ) {</div><div class="line"><a name="l03232"></a><span class="lineno"> 3232</span>&#160;    uint64_t MaxEndOffset = SI-&gt;endOffset();</div><div class="line"><a name="l03233"></a><span class="lineno"> 3233</span>&#160;</div><div class="line"><a name="l03234"></a><span class="lineno"> 3234</span>&#160;    <span class="keywordflow">if</span> (!SI-&gt;isSplittable()) {</div><div class="line"><a name="l03235"></a><span class="lineno"> 3235</span>&#160;      <span class="comment">// When we&#39;re forming an unsplittable region, it must always start at the</span></div><div class="line"><a name="l03236"></a><span class="lineno"> 3236</span>&#160;      <span class="comment">// first slice and will extend through its end.</span></div><div class="line"><a name="l03237"></a><span class="lineno"> 3237</span>&#160;      assert(BeginOffset == SI-&gt;beginOffset());</div><div class="line"><a name="l03238"></a><span class="lineno"> 3238</span>&#160;</div><div class="line"><a name="l03239"></a><span class="lineno"> 3239</span>&#160;      <span class="comment">// Form a partition including all of the overlapping slices with this</span></div><div class="line"><a name="l03240"></a><span class="lineno"> 3240</span>&#160;      <span class="comment">// unsplittable slice.</span></div><div class="line"><a name="l03241"></a><span class="lineno"> 3241</span>&#160;      <span class="keywordflow">while</span> (SJ != SE &amp;&amp; SJ-&gt;beginOffset() &lt; MaxEndOffset) {</div><div class="line"><a name="l03242"></a><span class="lineno"> 3242</span>&#160;        <span class="keywordflow">if</span> (!SJ-&gt;isSplittable())</div><div class="line"><a name="l03243"></a><span class="lineno"> 3243</span>&#160;          MaxEndOffset = std::max(MaxEndOffset, SJ-&gt;endOffset());</div><div class="line"><a name="l03244"></a><span class="lineno"> 3244</span>&#160;        ++SJ;</div><div class="line"><a name="l03245"></a><span class="lineno"> 3245</span>&#160;      }</div><div class="line"><a name="l03246"></a><span class="lineno"> 3246</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l03247"></a><span class="lineno"> 3247</span>&#160;      assert(SI-&gt;isSplittable()); <span class="comment">// Established above.</span></div><div class="line"><a name="l03248"></a><span class="lineno"> 3248</span>&#160;</div><div class="line"><a name="l03249"></a><span class="lineno"> 3249</span>&#160;      <span class="comment">// Collect all of the overlapping splittable slices.</span></div><div class="line"><a name="l03250"></a><span class="lineno"> 3250</span>&#160;      <span class="keywordflow">while</span> (SJ != SE &amp;&amp; SJ-&gt;beginOffset() &lt; MaxEndOffset &amp;&amp;</div><div class="line"><a name="l03251"></a><span class="lineno"> 3251</span>&#160;             SJ-&gt;isSplittable()) {</div><div class="line"><a name="l03252"></a><span class="lineno"> 3252</span>&#160;        MaxEndOffset = std::max(MaxEndOffset, SJ-&gt;endOffset());</div><div class="line"><a name="l03253"></a><span class="lineno"> 3253</span>&#160;        ++SJ;</div><div class="line"><a name="l03254"></a><span class="lineno"> 3254</span>&#160;      }</div><div class="line"><a name="l03255"></a><span class="lineno"> 3255</span>&#160;</div><div class="line"><a name="l03256"></a><span class="lineno"> 3256</span>&#160;      <span class="comment">// Back up MaxEndOffset and SJ if we ended the span early when</span></div><div class="line"><a name="l03257"></a><span class="lineno"> 3257</span>&#160;      <span class="comment">// encountering an unsplittable slice.</span></div><div class="line"><a name="l03258"></a><span class="lineno"> 3258</span>&#160;      <span class="keywordflow">if</span> (SJ != SE &amp;&amp; SJ-&gt;beginOffset() &lt; MaxEndOffset) {</div><div class="line"><a name="l03259"></a><span class="lineno"> 3259</span>&#160;        assert(!SJ-&gt;isSplittable());</div><div class="line"><a name="l03260"></a><span class="lineno"> 3260</span>&#160;        MaxEndOffset = SJ-&gt;beginOffset();</div><div class="line"><a name="l03261"></a><span class="lineno"> 3261</span>&#160;      }</div><div class="line"><a name="l03262"></a><span class="lineno"> 3262</span>&#160;    }</div><div class="line"><a name="l03263"></a><span class="lineno"> 3263</span>&#160;</div><div class="line"><a name="l03264"></a><span class="lineno"> 3264</span>&#160;    <span class="comment">// Check if we have managed to move the end offset forward yet. If so,</span></div><div class="line"><a name="l03265"></a><span class="lineno"> 3265</span>&#160;    <span class="comment">// we&#39;ll have to rewrite uses and erase old split uses.</span></div><div class="line"><a name="l03266"></a><span class="lineno"> 3266</span>&#160;    <span class="keywordflow">if</span> (BeginOffset &lt; MaxEndOffset) {</div><div class="line"><a name="l03267"></a><span class="lineno"> 3267</span>&#160;      <span class="comment">// Rewrite a sequence of overlapping slices.</span></div><div class="line"><a name="l03268"></a><span class="lineno"> 3268</span>&#160;      Changed |=</div><div class="line"><a name="l03269"></a><span class="lineno"> 3269</span>&#160;          rewritePartition(AI, S, SI, SJ, BeginOffset, MaxEndOffset, SplitUses);</div><div class="line"><a name="l03270"></a><span class="lineno"> 3270</span>&#160;      ++NumPartitions;</div><div class="line"><a name="l03271"></a><span class="lineno"> 3271</span>&#160;</div><div class="line"><a name="l03272"></a><span class="lineno"> 3272</span>&#160;      <a class="code" href="SROA_8cpp.html#a1564307938a15a117873a7ab9a27e0a9">removeFinishedSplitUses</a>(SplitUses, MaxSplitUseEndOffset, MaxEndOffset);</div><div class="line"><a name="l03273"></a><span class="lineno"> 3273</span>&#160;    }</div><div class="line"><a name="l03274"></a><span class="lineno"> 3274</span>&#160;</div><div class="line"><a name="l03275"></a><span class="lineno"> 3275</span>&#160;    <span class="comment">// Accumulate all the splittable slices from the [SI,SJ) region which</span></div><div class="line"><a name="l03276"></a><span class="lineno"> 3276</span>&#160;    <span class="comment">// overlap going forward.</span></div><div class="line"><a name="l03277"></a><span class="lineno"> 3277</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="classT.html">AllocaSlices::iterator</a> SK = SI; SK != SJ; ++SK)</div><div class="line"><a name="l03278"></a><span class="lineno"> 3278</span>&#160;      <span class="keywordflow">if</span> (SK-&gt;isSplittable() &amp;&amp; SK-&gt;endOffset() &gt; MaxEndOffset) {</div><div class="line"><a name="l03279"></a><span class="lineno"> 3279</span>&#160;        SplitUses.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(SK);</div><div class="line"><a name="l03280"></a><span class="lineno"> 3280</span>&#160;        MaxSplitUseEndOffset = std::max(SK-&gt;endOffset(), MaxSplitUseEndOffset);</div><div class="line"><a name="l03281"></a><span class="lineno"> 3281</span>&#160;      }</div><div class="line"><a name="l03282"></a><span class="lineno"> 3282</span>&#160;</div><div class="line"><a name="l03283"></a><span class="lineno"> 3283</span>&#160;    <span class="comment">// If we&#39;re already at the end and we have no split uses, we&#39;re done.</span></div><div class="line"><a name="l03284"></a><span class="lineno"> 3284</span>&#160;    <span class="keywordflow">if</span> (SJ == SE &amp;&amp; SplitUses.<a class="code" href="classllvm_1_1SmallVectorBase.html#a8a8df4d85555c7954a95f86080cd3b64">empty</a>())</div><div class="line"><a name="l03285"></a><span class="lineno"> 3285</span>&#160;      <span class="keywordflow">break</span>;</div><div class="line"><a name="l03286"></a><span class="lineno"> 3286</span>&#160;</div><div class="line"><a name="l03287"></a><span class="lineno"> 3287</span>&#160;    <span class="comment">// If we have no split uses or no gap in offsets, we&#39;re ready to move to</span></div><div class="line"><a name="l03288"></a><span class="lineno"> 3288</span>&#160;    <span class="comment">// the next slice.</span></div><div class="line"><a name="l03289"></a><span class="lineno"> 3289</span>&#160;    <span class="keywordflow">if</span> (SplitUses.<a class="code" href="classllvm_1_1SmallVectorBase.html#a8a8df4d85555c7954a95f86080cd3b64">empty</a>() || (SJ != SE &amp;&amp; MaxEndOffset == SJ-&gt;beginOffset())) {</div><div class="line"><a name="l03290"></a><span class="lineno"> 3290</span>&#160;      BeginOffset = SJ-&gt;beginOffset();</div><div class="line"><a name="l03291"></a><span class="lineno"> 3291</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l03292"></a><span class="lineno"> 3292</span>&#160;    }</div><div class="line"><a name="l03293"></a><span class="lineno"> 3293</span>&#160;</div><div class="line"><a name="l03294"></a><span class="lineno"> 3294</span>&#160;    <span class="comment">// Even if we have split slices, if the next slice is splittable and the</span></div><div class="line"><a name="l03295"></a><span class="lineno"> 3295</span>&#160;    <span class="comment">// split slices reach it, we can simply set up the beginning offset of the</span></div><div class="line"><a name="l03296"></a><span class="lineno"> 3296</span>&#160;    <span class="comment">// next iteration to bridge between them.</span></div><div class="line"><a name="l03297"></a><span class="lineno"> 3297</span>&#160;    <span class="keywordflow">if</span> (SJ != SE &amp;&amp; SJ-&gt;isSplittable() &amp;&amp;</div><div class="line"><a name="l03298"></a><span class="lineno"> 3298</span>&#160;        MaxSplitUseEndOffset &gt; SJ-&gt;beginOffset()) {</div><div class="line"><a name="l03299"></a><span class="lineno"> 3299</span>&#160;      BeginOffset = MaxEndOffset;</div><div class="line"><a name="l03300"></a><span class="lineno"> 3300</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l03301"></a><span class="lineno"> 3301</span>&#160;    }</div><div class="line"><a name="l03302"></a><span class="lineno"> 3302</span>&#160;</div><div class="line"><a name="l03303"></a><span class="lineno"> 3303</span>&#160;    <span class="comment">// Otherwise, we have a tail of split slices. Rewrite them with an empty</span></div><div class="line"><a name="l03304"></a><span class="lineno"> 3304</span>&#160;    <span class="comment">// range of slices.</span></div><div class="line"><a name="l03305"></a><span class="lineno"> 3305</span>&#160;    uint64_t PostSplitEndOffset =</div><div class="line"><a name="l03306"></a><span class="lineno"> 3306</span>&#160;        SJ == SE ? MaxSplitUseEndOffset : SJ-&gt;beginOffset();</div><div class="line"><a name="l03307"></a><span class="lineno"> 3307</span>&#160;</div><div class="line"><a name="l03308"></a><span class="lineno"> 3308</span>&#160;    Changed |= rewritePartition(AI, S, SJ, SJ, MaxEndOffset, PostSplitEndOffset,</div><div class="line"><a name="l03309"></a><span class="lineno"> 3309</span>&#160;                                SplitUses);</div><div class="line"><a name="l03310"></a><span class="lineno"> 3310</span>&#160;    ++NumPartitions;</div><div class="line"><a name="l03311"></a><span class="lineno"> 3311</span>&#160;</div><div class="line"><a name="l03312"></a><span class="lineno"> 3312</span>&#160;    <span class="keywordflow">if</span> (SJ == SE)</div><div class="line"><a name="l03313"></a><span class="lineno"> 3313</span>&#160;      <span class="keywordflow">break</span>; <span class="comment">// Skip the rest, we don&#39;t need to do any cleanup.</span></div><div class="line"><a name="l03314"></a><span class="lineno"> 3314</span>&#160;</div><div class="line"><a name="l03315"></a><span class="lineno"> 3315</span>&#160;    <a class="code" href="SROA_8cpp.html#a1564307938a15a117873a7ab9a27e0a9">removeFinishedSplitUses</a>(SplitUses, MaxSplitUseEndOffset,</div><div class="line"><a name="l03316"></a><span class="lineno"> 3316</span>&#160;                            PostSplitEndOffset);</div><div class="line"><a name="l03317"></a><span class="lineno"> 3317</span>&#160;</div><div class="line"><a name="l03318"></a><span class="lineno"> 3318</span>&#160;    <span class="comment">// Now just reset the begin offset for the next iteration.</span></div><div class="line"><a name="l03319"></a><span class="lineno"> 3319</span>&#160;    BeginOffset = SJ-&gt;beginOffset();</div><div class="line"><a name="l03320"></a><span class="lineno"> 3320</span>&#160;  }</div><div class="line"><a name="l03321"></a><span class="lineno"> 3321</span>&#160;</div><div class="line"><a name="l03322"></a><span class="lineno"> 3322</span>&#160;  NumAllocaPartitions += NumPartitions;</div><div class="line"><a name="l03323"></a><span class="lineno"> 3323</span>&#160;  MaxPartitionsPerAlloca =</div><div class="line"><a name="l03324"></a><span class="lineno"> 3324</span>&#160;      std::max&lt;unsigned&gt;(NumPartitions, MaxPartitionsPerAlloca);</div><div class="line"><a name="l03325"></a><span class="lineno"> 3325</span>&#160;</div><div class="line"><a name="l03326"></a><span class="lineno"> 3326</span>&#160;  <span class="keywordflow">return</span> Changed;</div><div class="line"><a name="l03327"></a><span class="lineno"> 3327</span>&#160;}</div><div class="line"><a name="l03328"></a><span class="lineno"> 3328</span>&#160;<span class="comment"></span></div><div class="line"><a name="l03329"></a><span class="lineno"> 3329</span>&#160;<span class="comment">/// \brief Analyze an alloca for SROA.</span></div><div class="line"><a name="l03330"></a><span class="lineno"> 3330</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l03331"></a><span class="lineno"> 3331</span>&#160;<span class="comment">/// This analyzes the alloca to ensure we can reason about it, builds</span></div><div class="line"><a name="l03332"></a><span class="lineno"> 3332</span>&#160;<span class="comment">/// the slices of the alloca, and then hands it off to be split and</span></div><div class="line"><a name="l03333"></a><span class="lineno"> 3333</span>&#160;<span class="comment">/// rewritten as needed.</span></div><div class="line"><a name="l03334"></a><span class="lineno"> 3334</span>&#160;<span class="comment"></span><span class="keywordtype">bool</span> SROA::runOnAlloca(<a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> &amp;AI) {</div><div class="line"><a name="l03335"></a><span class="lineno"> 3335</span>&#160;  <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;SROA alloca: &quot;</span> &lt;&lt; AI &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l03336"></a><span class="lineno"> 3336</span>&#160;  ++NumAllocasAnalyzed;</div><div class="line"><a name="l03337"></a><span class="lineno"> 3337</span>&#160;</div><div class="line"><a name="l03338"></a><span class="lineno"> 3338</span>&#160;  <span class="comment">// Special case dead allocas, as they&#39;re trivial.</span></div><div class="line"><a name="l03339"></a><span class="lineno"> 3339</span>&#160;  <span class="keywordflow">if</span> (AI.<a class="code" href="classllvm_1_1Value.html#ac38c53f76ef532f91f1666c8a87370e9">use_empty</a>()) {</div><div class="line"><a name="l03340"></a><span class="lineno"> 3340</span>&#160;    AI.<a class="code" href="classllvm_1_1Instruction.html#a6fe2f06b8a4b2c3d6308afb223a0238a">eraseFromParent</a>();</div><div class="line"><a name="l03341"></a><span class="lineno"> 3341</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l03342"></a><span class="lineno"> 3342</span>&#160;  }</div><div class="line"><a name="l03343"></a><span class="lineno"> 3343</span>&#160;</div><div class="line"><a name="l03344"></a><span class="lineno"> 3344</span>&#160;  <span class="comment">// Skip alloca forms that this analysis can&#39;t handle.</span></div><div class="line"><a name="l03345"></a><span class="lineno"> 3345</span>&#160;  <span class="keywordflow">if</span> (AI.<a class="code" href="classllvm_1_1AllocaInst.html#a066eba0d0eb9d9655c9b580a2a279b0a">isArrayAllocation</a>() || !AI.<a class="code" href="classllvm_1_1AllocaInst.html#a214c60dbb4f1ed467e5a3420db6eefd6">getAllocatedType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a9dc5111b1a9b1d5c4652d50f74fe850b">isSized</a>() ||</div><div class="line"><a name="l03346"></a><span class="lineno"> 3346</span>&#160;      DL-&gt;getTypeAllocSize(AI.<a class="code" href="classllvm_1_1AllocaInst.html#a214c60dbb4f1ed467e5a3420db6eefd6">getAllocatedType</a>()) == 0)</div><div class="line"><a name="l03347"></a><span class="lineno"> 3347</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l03348"></a><span class="lineno"> 3348</span>&#160;</div><div class="line"><a name="l03349"></a><span class="lineno"> 3349</span>&#160;  <span class="keywordtype">bool</span> Changed = <span class="keyword">false</span>;</div><div class="line"><a name="l03350"></a><span class="lineno"> 3350</span>&#160;</div><div class="line"><a name="l03351"></a><span class="lineno"> 3351</span>&#160;  <span class="comment">// First, split any FCA loads and stores touching this alloca to promote</span></div><div class="line"><a name="l03352"></a><span class="lineno"> 3352</span>&#160;  <span class="comment">// better splitting and promotion opportunities.</span></div><div class="line"><a name="l03353"></a><span class="lineno"> 3353</span>&#160;  AggLoadStoreRewriter AggRewriter(*DL);</div><div class="line"><a name="l03354"></a><span class="lineno"> 3354</span>&#160;  Changed |= AggRewriter.rewrite(AI);</div><div class="line"><a name="l03355"></a><span class="lineno"> 3355</span>&#160;</div><div class="line"><a name="l03356"></a><span class="lineno"> 3356</span>&#160;  <span class="comment">// Build the slices using a recursive instruction-visiting builder.</span></div><div class="line"><a name="l03357"></a><span class="lineno"> 3357</span>&#160;  AllocaSlices <a class="code" href="Target_2ARM_2README_8txt.html#a1b45f45820a60c09244a87eb59824aec">S</a>(*DL, AI);</div><div class="line"><a name="l03358"></a><span class="lineno"> 3358</span>&#160;  <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(S.print(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>()));</div><div class="line"><a name="l03359"></a><span class="lineno"> 3359</span>&#160;  <span class="keywordflow">if</span> (S.isEscaped())</div><div class="line"><a name="l03360"></a><span class="lineno"> 3360</span>&#160;    <span class="keywordflow">return</span> Changed;</div><div class="line"><a name="l03361"></a><span class="lineno"> 3361</span>&#160;</div><div class="line"><a name="l03362"></a><span class="lineno"> 3362</span>&#160;  <span class="comment">// Delete all the dead users of this alloca before splitting and rewriting it.</span></div><div class="line"><a name="l03363"></a><span class="lineno"> 3363</span>&#160;  <span class="keywordflow">for</span> (AllocaSlices::dead_user_iterator DI = S.dead_user_begin(),</div><div class="line"><a name="l03364"></a><span class="lineno"> 3364</span>&#160;                                        <a class="code" href="namespacellvm_1_1X86II.html#a97dc14052814702ba0e2b14fb14dd02da2c6497f6ed5314c6fcd9ab88c9528543">DE</a> = S.dead_user_end();</div><div class="line"><a name="l03365"></a><span class="lineno"> 3365</span>&#160;       DI != <a class="code" href="namespacellvm_1_1X86II.html#a97dc14052814702ba0e2b14fb14dd02da2c6497f6ed5314c6fcd9ab88c9528543">DE</a>; ++DI) {</div><div class="line"><a name="l03366"></a><span class="lineno"> 3366</span>&#160;    Changed = <span class="keyword">true</span>;</div><div class="line"><a name="l03367"></a><span class="lineno"> 3367</span>&#160;    (*DI)-&gt;replaceAllUsesWith(<a class="code" href="classllvm_1_1UndefValue.html#a4ae5ff22b700a42bcc5d889233721335">UndefValue::get</a>((*DI)-&gt;getType()));</div><div class="line"><a name="l03368"></a><span class="lineno"> 3368</span>&#160;    DeadInsts.insert(*DI);</div><div class="line"><a name="l03369"></a><span class="lineno"> 3369</span>&#160;  }</div><div class="line"><a name="l03370"></a><span class="lineno"> 3370</span>&#160;  <span class="keywordflow">for</span> (AllocaSlices::dead_op_iterator DO = S.dead_op_begin(),</div><div class="line"><a name="l03371"></a><span class="lineno"> 3371</span>&#160;                                      <a class="code" href="namespacellvm_1_1X86II.html#a97dc14052814702ba0e2b14fb14dd02da2c6497f6ed5314c6fcd9ab88c9528543">DE</a> = S.dead_op_end();</div><div class="line"><a name="l03372"></a><span class="lineno"> 3372</span>&#160;       DO != <a class="code" href="namespacellvm_1_1X86II.html#a97dc14052814702ba0e2b14fb14dd02da2c6497f6ed5314c6fcd9ab88c9528543">DE</a>; ++DO) {</div><div class="line"><a name="l03373"></a><span class="lineno"> 3373</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *OldV = **DO;</div><div class="line"><a name="l03374"></a><span class="lineno"> 3374</span>&#160;    <span class="comment">// Clobber the use with an undef value.</span></div><div class="line"><a name="l03375"></a><span class="lineno"> 3375</span>&#160;    **DO = <a class="code" href="classllvm_1_1UndefValue.html#a4ae5ff22b700a42bcc5d889233721335">UndefValue::get</a>(OldV-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>());</div><div class="line"><a name="l03376"></a><span class="lineno"> 3376</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *OldI = dyn_cast&lt;Instruction&gt;(OldV))</div><div class="line"><a name="l03377"></a><span class="lineno"> 3377</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="namespacellvm.html#abe283966f269761ee387642061c4451e">isInstructionTriviallyDead</a>(OldI)) {</div><div class="line"><a name="l03378"></a><span class="lineno"> 3378</span>&#160;        Changed = <span class="keyword">true</span>;</div><div class="line"><a name="l03379"></a><span class="lineno"> 3379</span>&#160;        DeadInsts.insert(OldI);</div><div class="line"><a name="l03380"></a><span class="lineno"> 3380</span>&#160;      }</div><div class="line"><a name="l03381"></a><span class="lineno"> 3381</span>&#160;  }</div><div class="line"><a name="l03382"></a><span class="lineno"> 3382</span>&#160;</div><div class="line"><a name="l03383"></a><span class="lineno"> 3383</span>&#160;  <span class="comment">// No slices to split. Leave the dead alloca for a later pass to clean up.</span></div><div class="line"><a name="l03384"></a><span class="lineno"> 3384</span>&#160;  <span class="keywordflow">if</span> (S.begin() == S.end())</div><div class="line"><a name="l03385"></a><span class="lineno"> 3385</span>&#160;    <span class="keywordflow">return</span> Changed;</div><div class="line"><a name="l03386"></a><span class="lineno"> 3386</span>&#160;</div><div class="line"><a name="l03387"></a><span class="lineno"> 3387</span>&#160;  Changed |= splitAlloca(AI, S);</div><div class="line"><a name="l03388"></a><span class="lineno"> 3388</span>&#160;</div><div class="line"><a name="l03389"></a><span class="lineno"> 3389</span>&#160;  <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;  Speculating PHIs\n&quot;</span>);</div><div class="line"><a name="l03390"></a><span class="lineno"> 3390</span>&#160;  <span class="keywordflow">while</span> (!SpeculatablePHIs.empty())</div><div class="line"><a name="l03391"></a><span class="lineno"> 3391</span>&#160;    <a class="code" href="SROA_8cpp.html#aab38ec9ebc3b5d96a4b7ddcb11cfcd58">speculatePHINodeLoads</a>(*SpeculatablePHIs.pop_back_val());</div><div class="line"><a name="l03392"></a><span class="lineno"> 3392</span>&#160;</div><div class="line"><a name="l03393"></a><span class="lineno"> 3393</span>&#160;  <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;  Speculating Selects\n&quot;</span>);</div><div class="line"><a name="l03394"></a><span class="lineno"> 3394</span>&#160;  <span class="keywordflow">while</span> (!SpeculatableSelects.empty())</div><div class="line"><a name="l03395"></a><span class="lineno"> 3395</span>&#160;    <a class="code" href="SROA_8cpp.html#a7493b7d3b84612687869f2c3afed924b">speculateSelectInstLoads</a>(*SpeculatableSelects.pop_back_val());</div><div class="line"><a name="l03396"></a><span class="lineno"> 3396</span>&#160;</div><div class="line"><a name="l03397"></a><span class="lineno"> 3397</span>&#160;  <span class="keywordflow">return</span> Changed;</div><div class="line"><a name="l03398"></a><span class="lineno"> 3398</span>&#160;}</div><div class="line"><a name="l03399"></a><span class="lineno"> 3399</span>&#160;<span class="comment"></span></div><div class="line"><a name="l03400"></a><span class="lineno"> 3400</span>&#160;<span class="comment">/// \brief Delete the dead instructions accumulated in this run.</span></div><div class="line"><a name="l03401"></a><span class="lineno"> 3401</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l03402"></a><span class="lineno"> 3402</span>&#160;<span class="comment">/// Recursively deletes the dead instructions we&#39;ve accumulated. This is done</span></div><div class="line"><a name="l03403"></a><span class="lineno"> 3403</span>&#160;<span class="comment">/// at the very end to maximize locality of the recursive delete and to</span></div><div class="line"><a name="l03404"></a><span class="lineno"> 3404</span>&#160;<span class="comment">/// minimize the problems of invalidated instruction pointers as such pointers</span></div><div class="line"><a name="l03405"></a><span class="lineno"> 3405</span>&#160;<span class="comment">/// are used heavily in the intermediate stages of the algorithm.</span></div><div class="line"><a name="l03406"></a><span class="lineno"> 3406</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l03407"></a><span class="lineno"> 3407</span>&#160;<span class="comment">/// We also record the alloca instructions deleted here so that they aren&#39;t</span></div><div class="line"><a name="l03408"></a><span class="lineno"> 3408</span>&#160;<span class="comment">/// subsequently handed to mem2reg to promote.</span></div><div class="line"><a name="l03409"></a><span class="lineno"> 3409</span>&#160;<span class="comment"></span><span class="keywordtype">void</span> SROA::deleteDeadInstructions(<a class="code" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet&lt;AllocaInst*, 4&gt;</a> &amp;DeletedAllocas) {</div><div class="line"><a name="l03410"></a><span class="lineno"> 3410</span>&#160;  <span class="keywordflow">while</span> (!DeadInsts.empty()) {</div><div class="line"><a name="l03411"></a><span class="lineno"> 3411</span>&#160;    <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> = DeadInsts.pop_back_val();</div><div class="line"><a name="l03412"></a><span class="lineno"> 3412</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;Deleting dead instruction: &quot;</span> &lt;&lt; *I &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l03413"></a><span class="lineno"> 3413</span>&#160;</div><div class="line"><a name="l03414"></a><span class="lineno"> 3414</span>&#160;    I-&gt;<a class="code" href="classllvm_1_1Value.html#a3ab5fc45117b450e8bb04e564cb6e5f2">replaceAllUsesWith</a>(<a class="code" href="classllvm_1_1UndefValue.html#a4ae5ff22b700a42bcc5d889233721335">UndefValue::get</a>(I-&gt;<a class="code" href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">getType</a>()));</div><div class="line"><a name="l03415"></a><span class="lineno"> 3415</span>&#160;</div><div class="line"><a name="l03416"></a><span class="lineno"> 3416</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1Use.html">User::op_iterator</a> OI = I-&gt;<a class="code" href="classllvm_1_1User.html#a2eeb1c7ed1cfe403f2ae0470e36c07e2">op_begin</a>(), E = I-&gt;<a class="code" href="classllvm_1_1User.html#af41f58e730804d10b91fcff39b035f74">op_end</a>(); OI != E; ++OI)</div><div class="line"><a name="l03417"></a><span class="lineno"> 3417</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *U = dyn_cast&lt;Instruction&gt;(*OI)) {</div><div class="line"><a name="l03418"></a><span class="lineno"> 3418</span>&#160;        <span class="comment">// Zero out the operand and see if it becomes trivially dead.</span></div><div class="line"><a name="l03419"></a><span class="lineno"> 3419</span>&#160;        *OI = 0;</div><div class="line"><a name="l03420"></a><span class="lineno"> 3420</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespacellvm.html#abe283966f269761ee387642061c4451e">isInstructionTriviallyDead</a>(U))</div><div class="line"><a name="l03421"></a><span class="lineno"> 3421</span>&#160;          DeadInsts.insert(U);</div><div class="line"><a name="l03422"></a><span class="lineno"> 3422</span>&#160;      }</div><div class="line"><a name="l03423"></a><span class="lineno"> 3423</span>&#160;</div><div class="line"><a name="l03424"></a><span class="lineno"> 3424</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> *AI = dyn_cast&lt;AllocaInst&gt;(I))</div><div class="line"><a name="l03425"></a><span class="lineno"> 3425</span>&#160;      DeletedAllocas.<a class="code" href="classllvm_1_1SmallPtrSet.html#a9b6dd0fc7a648a939e571246045b673e">insert</a>(AI);</div><div class="line"><a name="l03426"></a><span class="lineno"> 3426</span>&#160;</div><div class="line"><a name="l03427"></a><span class="lineno"> 3427</span>&#160;    ++NumDeleted;</div><div class="line"><a name="l03428"></a><span class="lineno"> 3428</span>&#160;    I-&gt;<a class="code" href="classllvm_1_1Instruction.html#a6fe2f06b8a4b2c3d6308afb223a0238a">eraseFromParent</a>();</div><div class="line"><a name="l03429"></a><span class="lineno"> 3429</span>&#160;  }</div><div class="line"><a name="l03430"></a><span class="lineno"> 3430</span>&#160;}</div><div class="line"><a name="l03431"></a><span class="lineno"> 3431</span>&#160;</div><div class="line"><a name="l03432"></a><span class="lineno"><a class="line" href="SROA_8cpp.html#a3f3e524fc962e72389c1e1eedc03229c"> 3432</a></span>&#160;<span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="SROA_8cpp.html#a3f3e524fc962e72389c1e1eedc03229c">enqueueUsersInWorklist</a>(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> &amp;<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>,</div><div class="line"><a name="l03433"></a><span class="lineno"> 3433</span>&#160;                                   <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;Instruction *&gt;</a> &amp;Worklist,</div><div class="line"><a name="l03434"></a><span class="lineno"> 3434</span>&#160;                                   <a class="code" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet&lt;Instruction *, 8&gt;</a> &amp;Visited) {</div><div class="line"><a name="l03435"></a><span class="lineno"> 3435</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1value__use__iterator.html">Value::use_iterator</a> UI = I.<a class="code" href="classllvm_1_1Value.html#a413abcab8dbc3900fc2fde96a5d8fca6">use_begin</a>(), UE = I.<a class="code" href="classllvm_1_1Value.html#ad86469939d2a8bdd4169be9403b89f5a">use_end</a>(); UI != UE;</div><div class="line"><a name="l03436"></a><span class="lineno"> 3436</span>&#160;       ++UI)</div><div class="line"><a name="l03437"></a><span class="lineno"> 3437</span>&#160;    <span class="keywordflow">if</span> (Visited.<a class="code" href="classllvm_1_1SmallPtrSet.html#a9b6dd0fc7a648a939e571246045b673e">insert</a>(cast&lt;Instruction&gt;(*UI)))</div><div class="line"><a name="l03438"></a><span class="lineno"> 3438</span>&#160;      Worklist.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(cast&lt;Instruction&gt;(*UI));</div><div class="line"><a name="l03439"></a><span class="lineno"> 3439</span>&#160;}</div><div class="line"><a name="l03440"></a><span class="lineno"> 3440</span>&#160;<span class="comment"></span></div><div class="line"><a name="l03441"></a><span class="lineno"> 3441</span>&#160;<span class="comment">/// \brief Promote the allocas, using the best available technique.</span></div><div class="line"><a name="l03442"></a><span class="lineno"> 3442</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l03443"></a><span class="lineno"> 3443</span>&#160;<span class="comment">/// This attempts to promote whatever allocas have been identified as viable in</span></div><div class="line"><a name="l03444"></a><span class="lineno"> 3444</span>&#160;<span class="comment">/// the PromotableAllocas list. If that list is empty, there is nothing to do.</span></div><div class="line"><a name="l03445"></a><span class="lineno"> 3445</span>&#160;<span class="comment">/// If there is a domtree available, we attempt to promote using the full power</span></div><div class="line"><a name="l03446"></a><span class="lineno"> 3446</span>&#160;<span class="comment">/// of mem2reg. Otherwise, we build and use the AllocaPromoter above which is</span></div><div class="line"><a name="l03447"></a><span class="lineno"> 3447</span>&#160;<span class="comment">/// based on the SSAUpdater utilities. This function returns whether any</span></div><div class="line"><a name="l03448"></a><span class="lineno"> 3448</span>&#160;<span class="comment">/// promotion occurred.</span></div><div class="line"><a name="l03449"></a><span class="lineno"> 3449</span>&#160;<span class="comment"></span><span class="keywordtype">bool</span> SROA::promoteAllocas(<a class="code" href="classllvm_1_1Function.html">Function</a> &amp;<a class="code" href="LLParser_8cpp.html#a33ece1ef8074506a15d7f86eb76dbae6">F</a>) {</div><div class="line"><a name="l03450"></a><span class="lineno"> 3450</span>&#160;  <span class="keywordflow">if</span> (PromotableAllocas.empty())</div><div class="line"><a name="l03451"></a><span class="lineno"> 3451</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l03452"></a><span class="lineno"> 3452</span>&#160;</div><div class="line"><a name="l03453"></a><span class="lineno"> 3453</span>&#160;  NumPromoted += PromotableAllocas.size();</div><div class="line"><a name="l03454"></a><span class="lineno"> 3454</span>&#160;</div><div class="line"><a name="l03455"></a><span class="lineno"> 3455</span>&#160;  <span class="keywordflow">if</span> (DT &amp;&amp; !<a class="code" href="SROA_8cpp.html#a613f24111340d4f4fc57e01da7a083b5">ForceSSAUpdater</a>) {</div><div class="line"><a name="l03456"></a><span class="lineno"> 3456</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;Promoting allocas with mem2reg...\n&quot;</span>);</div><div class="line"><a name="l03457"></a><span class="lineno"> 3457</span>&#160;    <a class="code" href="namespacellvm.html#afd92ce3a3b5db58abf81981d3fcd95c6">PromoteMemToReg</a>(PromotableAllocas, *DT);</div><div class="line"><a name="l03458"></a><span class="lineno"> 3458</span>&#160;    PromotableAllocas.clear();</div><div class="line"><a name="l03459"></a><span class="lineno"> 3459</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l03460"></a><span class="lineno"> 3460</span>&#160;  }</div><div class="line"><a name="l03461"></a><span class="lineno"> 3461</span>&#160;</div><div class="line"><a name="l03462"></a><span class="lineno"> 3462</span>&#160;  <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;Promoting allocas with SSAUpdater...\n&quot;</span>);</div><div class="line"><a name="l03463"></a><span class="lineno"> 3463</span>&#160;  <a class="code" href="classllvm_1_1SSAUpdater.html">SSAUpdater</a> SSA;</div><div class="line"><a name="l03464"></a><span class="lineno"> 3464</span>&#160;  <a class="code" href="classllvm_1_1DIBuilder.html">DIBuilder</a> DIB(*F.<a class="code" href="classllvm_1_1GlobalValue.html#a9e1fc23a17e97d2d1732e753ae9251ac">getParent</a>());</div><div class="line"><a name="l03465"></a><span class="lineno"> 3465</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Instruction *, 64&gt;</a> Insts;</div><div class="line"><a name="l03466"></a><span class="lineno"> 3466</span>&#160;</div><div class="line"><a name="l03467"></a><span class="lineno"> 3467</span>&#160;  <span class="comment">// We need a worklist to walk the uses of each alloca.</span></div><div class="line"><a name="l03468"></a><span class="lineno"> 3468</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Instruction *, 8&gt;</a> Worklist;</div><div class="line"><a name="l03469"></a><span class="lineno"> 3469</span>&#160;  <a class="code" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet&lt;Instruction *, 8&gt;</a> Visited;</div><div class="line"><a name="l03470"></a><span class="lineno"> 3470</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Instruction *, 32&gt;</a> DeadInsts;</div><div class="line"><a name="l03471"></a><span class="lineno"> 3471</span>&#160;</div><div class="line"><a name="l03472"></a><span class="lineno"> 3472</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> Idx = 0, Size = PromotableAllocas.size(); Idx != Size; ++Idx) {</div><div class="line"><a name="l03473"></a><span class="lineno"> 3473</span>&#160;    <a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> *AI = PromotableAllocas[Idx];</div><div class="line"><a name="l03474"></a><span class="lineno"> 3474</span>&#160;    Insts.clear();</div><div class="line"><a name="l03475"></a><span class="lineno"> 3475</span>&#160;    Worklist.<a class="code" href="classllvm_1_1SmallVectorImpl.html#aac0ea55010b7b1a301e65a0baea057aa">clear</a>();</div><div class="line"><a name="l03476"></a><span class="lineno"> 3476</span>&#160;    Visited.<a class="code" href="classllvm_1_1SmallPtrSetImpl.html#aa72472422d95c7052d62432ec279ff85">clear</a>();</div><div class="line"><a name="l03477"></a><span class="lineno"> 3477</span>&#160;</div><div class="line"><a name="l03478"></a><span class="lineno"> 3478</span>&#160;    <a class="code" href="SROA_8cpp.html#a3f3e524fc962e72389c1e1eedc03229c">enqueueUsersInWorklist</a>(*AI, Worklist, Visited);</div><div class="line"><a name="l03479"></a><span class="lineno"> 3479</span>&#160;</div><div class="line"><a name="l03480"></a><span class="lineno"> 3480</span>&#160;    <span class="keywordflow">while</span> (!Worklist.<a class="code" href="classllvm_1_1SmallVectorBase.html#a8a8df4d85555c7954a95f86080cd3b64">empty</a>()) {</div><div class="line"><a name="l03481"></a><span class="lineno"> 3481</span>&#160;      <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> = Worklist.<a class="code" href="classllvm_1_1SmallVectorImpl.html#a400eaca9881c8dcab97e9f42b1ab1815">pop_back_val</a>();</div><div class="line"><a name="l03482"></a><span class="lineno"> 3482</span>&#160;</div><div class="line"><a name="l03483"></a><span class="lineno"> 3483</span>&#160;      <span class="comment">// FIXME: Currently the SSAUpdater infrastructure doesn&#39;t reason about</span></div><div class="line"><a name="l03484"></a><span class="lineno"> 3484</span>&#160;      <span class="comment">// lifetime intrinsics and so we strip them (and the bitcasts+GEPs</span></div><div class="line"><a name="l03485"></a><span class="lineno"> 3485</span>&#160;      <span class="comment">// leading to them) here. Eventually it should use them to optimize the</span></div><div class="line"><a name="l03486"></a><span class="lineno"> 3486</span>&#160;      <span class="comment">// scalar values produced.</span></div><div class="line"><a name="l03487"></a><span class="lineno"> 3487</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1IntrinsicInst.html">IntrinsicInst</a> *II = dyn_cast&lt;IntrinsicInst&gt;(I)) {</div><div class="line"><a name="l03488"></a><span class="lineno"> 3488</span>&#160;        assert(II-&gt;getIntrinsicID() == <a class="code" href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90ae365354e47542c51f9bd46e329e3323e">Intrinsic::lifetime_start</a> ||</div><div class="line"><a name="l03489"></a><span class="lineno"> 3489</span>&#160;               II-&gt;getIntrinsicID() == <a class="code" href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90aa332b90dd5e4ebf4bbbcc0964220d373">Intrinsic::lifetime_end</a>);</div><div class="line"><a name="l03490"></a><span class="lineno"> 3490</span>&#160;        II-&gt;<a class="code" href="classllvm_1_1Instruction.html#a6fe2f06b8a4b2c3d6308afb223a0238a">eraseFromParent</a>();</div><div class="line"><a name="l03491"></a><span class="lineno"> 3491</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l03492"></a><span class="lineno"> 3492</span>&#160;      }</div><div class="line"><a name="l03493"></a><span class="lineno"> 3493</span>&#160;</div><div class="line"><a name="l03494"></a><span class="lineno"> 3494</span>&#160;      <span class="comment">// Push the loads and stores we find onto the list. SROA will already</span></div><div class="line"><a name="l03495"></a><span class="lineno"> 3495</span>&#160;      <span class="comment">// have validated that all loads and stores are viable candidates for</span></div><div class="line"><a name="l03496"></a><span class="lineno"> 3496</span>&#160;      <span class="comment">// promotion.</span></div><div class="line"><a name="l03497"></a><span class="lineno"> 3497</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *LI = dyn_cast&lt;LoadInst&gt;(I)) {</div><div class="line"><a name="l03498"></a><span class="lineno"> 3498</span>&#160;        assert(LI-&gt;getType() == AI-&gt;<a class="code" href="classllvm_1_1AllocaInst.html#a214c60dbb4f1ed467e5a3420db6eefd6">getAllocatedType</a>());</div><div class="line"><a name="l03499"></a><span class="lineno"> 3499</span>&#160;        Insts.push_back(LI);</div><div class="line"><a name="l03500"></a><span class="lineno"> 3500</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l03501"></a><span class="lineno"> 3501</span>&#160;      }</div><div class="line"><a name="l03502"></a><span class="lineno"> 3502</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> *SI = dyn_cast&lt;StoreInst&gt;(I)) {</div><div class="line"><a name="l03503"></a><span class="lineno"> 3503</span>&#160;        assert(SI-&gt;getValueOperand()-&gt;getType() == AI-&gt;<a class="code" href="classllvm_1_1AllocaInst.html#a214c60dbb4f1ed467e5a3420db6eefd6">getAllocatedType</a>());</div><div class="line"><a name="l03504"></a><span class="lineno"> 3504</span>&#160;        Insts.push_back(SI);</div><div class="line"><a name="l03505"></a><span class="lineno"> 3505</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l03506"></a><span class="lineno"> 3506</span>&#160;      }</div><div class="line"><a name="l03507"></a><span class="lineno"> 3507</span>&#160;</div><div class="line"><a name="l03508"></a><span class="lineno"> 3508</span>&#160;      <span class="comment">// For everything else, we know that only no-op bitcasts and GEPs will</span></div><div class="line"><a name="l03509"></a><span class="lineno"> 3509</span>&#160;      <span class="comment">// make it this far, just recurse through them and recall them for later</span></div><div class="line"><a name="l03510"></a><span class="lineno"> 3510</span>&#160;      <span class="comment">// removal.</span></div><div class="line"><a name="l03511"></a><span class="lineno"> 3511</span>&#160;      DeadInsts.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">push_back</a>(I);</div><div class="line"><a name="l03512"></a><span class="lineno"> 3512</span>&#160;      <a class="code" href="SROA_8cpp.html#a3f3e524fc962e72389c1e1eedc03229c">enqueueUsersInWorklist</a>(*I, Worklist, Visited);</div><div class="line"><a name="l03513"></a><span class="lineno"> 3513</span>&#160;    }</div><div class="line"><a name="l03514"></a><span class="lineno"> 3514</span>&#160;    AllocaPromoter(Insts, SSA, *AI, DIB).run(Insts);</div><div class="line"><a name="l03515"></a><span class="lineno"> 3515</span>&#160;    <span class="keywordflow">while</span> (!DeadInsts.<a class="code" href="classllvm_1_1SmallVectorBase.html#a8a8df4d85555c7954a95f86080cd3b64">empty</a>())</div><div class="line"><a name="l03516"></a><span class="lineno"> 3516</span>&#160;      DeadInsts.<a class="code" href="classllvm_1_1SmallVectorImpl.html#a400eaca9881c8dcab97e9f42b1ab1815">pop_back_val</a>()-&gt;<a class="code" href="classllvm_1_1Instruction.html#a6fe2f06b8a4b2c3d6308afb223a0238a">eraseFromParent</a>();</div><div class="line"><a name="l03517"></a><span class="lineno"> 3517</span>&#160;    AI-&gt;<a class="code" href="classllvm_1_1Instruction.html#a6fe2f06b8a4b2c3d6308afb223a0238a">eraseFromParent</a>();</div><div class="line"><a name="l03518"></a><span class="lineno"> 3518</span>&#160;  }</div><div class="line"><a name="l03519"></a><span class="lineno"> 3519</span>&#160;</div><div class="line"><a name="l03520"></a><span class="lineno"> 3520</span>&#160;  PromotableAllocas.clear();</div><div class="line"><a name="l03521"></a><span class="lineno"> 3521</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l03522"></a><span class="lineno"> 3522</span>&#160;}</div><div class="line"><a name="l03523"></a><span class="lineno"> 3523</span>&#160;</div><div class="line"><a name="l03524"></a><span class="lineno"> 3524</span>&#160;<span class="keyword">namespace </span>{<span class="comment"></span></div><div class="line"><a name="l03525"></a><span class="lineno"> 3525</span>&#160;<span class="comment">  /// \brief A predicate to test whether an alloca belongs to a set.</span></div><div class="line"><a name="l03526"></a><span class="lineno"> 3526</span>&#160;<span class="comment"></span>  <span class="keyword">class </span>IsAllocaInSet {</div><div class="line"><a name="l03527"></a><span class="lineno"> 3527</span>&#160;    <span class="keyword">typedef</span> <a class="code" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet&lt;AllocaInst *, 4&gt;</a> SetType;</div><div class="line"><a name="l03528"></a><span class="lineno"> 3528</span>&#160;    <span class="keyword">const</span> SetType &amp;Set;</div><div class="line"><a name="l03529"></a><span class="lineno"> 3529</span>&#160;</div><div class="line"><a name="l03530"></a><span class="lineno"> 3530</span>&#160;  <span class="keyword">public</span>:</div><div class="line"><a name="l03531"></a><span class="lineno"> 3531</span>&#160;    <span class="keyword">typedef</span> <a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> *argument_type;</div><div class="line"><a name="l03532"></a><span class="lineno"> 3532</span>&#160;</div><div class="line"><a name="l03533"></a><span class="lineno"> 3533</span>&#160;    IsAllocaInSet(<span class="keyword">const</span> SetType &amp;Set) : Set(Set) {}</div><div class="line"><a name="l03534"></a><span class="lineno"> 3534</span>&#160;    <span class="keywordtype">bool</span> operator()(<a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> *AI)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> Set.count(AI); }</div><div class="line"><a name="l03535"></a><span class="lineno"> 3535</span>&#160;  };</div><div class="line"><a name="l03536"></a><span class="lineno"> 3536</span>&#160;}</div><div class="line"><a name="l03537"></a><span class="lineno"> 3537</span>&#160;</div><div class="line"><a name="l03538"></a><span class="lineno"> 3538</span>&#160;<span class="keywordtype">bool</span> SROA::runOnFunction(<a class="code" href="classllvm_1_1Function.html">Function</a> &amp;F) {</div><div class="line"><a name="l03539"></a><span class="lineno"> 3539</span>&#160;  <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;SROA function: &quot;</span> &lt;&lt; F.<a class="code" href="classllvm_1_1Value.html#ad452febc1ac0b394876e640ec03ffa38">getName</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l03540"></a><span class="lineno"> 3540</span>&#160;  <a class="code" href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a> = &amp;F.<a class="code" href="classllvm_1_1Function.html#a2da53ac53516a3f16191f4c8a8eaa3e5">getContext</a>();</div><div class="line"><a name="l03541"></a><span class="lineno"> 3541</span>&#160;  DL = getAnalysisIfAvailable&lt;DataLayout&gt;();</div><div class="line"><a name="l03542"></a><span class="lineno"> 3542</span>&#160;  <span class="keywordflow">if</span> (!DL) {</div><div class="line"><a name="l03543"></a><span class="lineno"> 3543</span>&#160;    <a class="code" href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;  Skipping SROA -- no target data!\n&quot;</span>);</div><div class="line"><a name="l03544"></a><span class="lineno"> 3544</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l03545"></a><span class="lineno"> 3545</span>&#160;  }</div><div class="line"><a name="l03546"></a><span class="lineno"> 3546</span>&#160;  DT = getAnalysisIfAvailable&lt;DominatorTree&gt;();</div><div class="line"><a name="l03547"></a><span class="lineno"> 3547</span>&#160;</div><div class="line"><a name="l03548"></a><span class="lineno"> 3548</span>&#160;  <a class="code" href="classllvm_1_1BasicBlock.html">BasicBlock</a> &amp;EntryBB = F.<a class="code" href="classllvm_1_1Function.html#a30f2c362631e3728d2f47a8203071ade">getEntryBlock</a>();</div><div class="line"><a name="l03549"></a><span class="lineno"> 3549</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1ilist__iterator.html">BasicBlock::iterator</a> <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> = EntryBB.begin(), E = <a class="code" href="namespacellvm.html#a7923e3e207de8bc1d0d6a5091316ddde">llvm::prior</a>(EntryBB.end());</div><div class="line"><a name="l03550"></a><span class="lineno"> 3550</span>&#160;       <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> != E; ++<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</div><div class="line"><a name="l03551"></a><span class="lineno"> 3551</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1AllocaInst.html">AllocaInst</a> *AI = dyn_cast&lt;AllocaInst&gt;(<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>))</div><div class="line"><a name="l03552"></a><span class="lineno"> 3552</span>&#160;      Worklist.insert(AI);</div><div class="line"><a name="l03553"></a><span class="lineno"> 3553</span>&#160;</div><div class="line"><a name="l03554"></a><span class="lineno"> 3554</span>&#160;  <span class="keywordtype">bool</span> Changed = <span class="keyword">false</span>;</div><div class="line"><a name="l03555"></a><span class="lineno"> 3555</span>&#160;  <span class="comment">// A set of deleted alloca instruction pointers which should be removed from</span></div><div class="line"><a name="l03556"></a><span class="lineno"> 3556</span>&#160;  <span class="comment">// the list of promotable allocas.</span></div><div class="line"><a name="l03557"></a><span class="lineno"> 3557</span>&#160;  <a class="code" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet&lt;AllocaInst *, 4&gt;</a> DeletedAllocas;</div><div class="line"><a name="l03558"></a><span class="lineno"> 3558</span>&#160;</div><div class="line"><a name="l03559"></a><span class="lineno"> 3559</span>&#160;  <span class="keywordflow">do</span> {</div><div class="line"><a name="l03560"></a><span class="lineno"> 3560</span>&#160;    <span class="keywordflow">while</span> (!Worklist.empty()) {</div><div class="line"><a name="l03561"></a><span class="lineno"> 3561</span>&#160;      Changed |= runOnAlloca(*Worklist.pop_back_val());</div><div class="line"><a name="l03562"></a><span class="lineno"> 3562</span>&#160;      deleteDeadInstructions(DeletedAllocas);</div><div class="line"><a name="l03563"></a><span class="lineno"> 3563</span>&#160;</div><div class="line"><a name="l03564"></a><span class="lineno"> 3564</span>&#160;      <span class="comment">// Remove the deleted allocas from various lists so that we don&#39;t try to</span></div><div class="line"><a name="l03565"></a><span class="lineno"> 3565</span>&#160;      <span class="comment">// continue processing them.</span></div><div class="line"><a name="l03566"></a><span class="lineno"> 3566</span>&#160;      <span class="keywordflow">if</span> (!DeletedAllocas.<a class="code" href="classllvm_1_1SmallPtrSetImpl.html#a095445850ef2c64e96b4c05120cecf66">empty</a>()) {</div><div class="line"><a name="l03567"></a><span class="lineno"> 3567</span>&#160;        Worklist.remove_if(IsAllocaInSet(DeletedAllocas));</div><div class="line"><a name="l03568"></a><span class="lineno"> 3568</span>&#160;        PostPromotionWorklist.remove_if(IsAllocaInSet(DeletedAllocas));</div><div class="line"><a name="l03569"></a><span class="lineno"> 3569</span>&#160;        PromotableAllocas.erase(std::remove_if(PromotableAllocas.begin(),</div><div class="line"><a name="l03570"></a><span class="lineno"> 3570</span>&#160;                                               PromotableAllocas.end(),</div><div class="line"><a name="l03571"></a><span class="lineno"> 3571</span>&#160;                                               IsAllocaInSet(DeletedAllocas)),</div><div class="line"><a name="l03572"></a><span class="lineno"> 3572</span>&#160;                                PromotableAllocas.end());</div><div class="line"><a name="l03573"></a><span class="lineno"> 3573</span>&#160;        DeletedAllocas.<a class="code" href="classllvm_1_1SmallPtrSetImpl.html#aa72472422d95c7052d62432ec279ff85">clear</a>();</div><div class="line"><a name="l03574"></a><span class="lineno"> 3574</span>&#160;      }</div><div class="line"><a name="l03575"></a><span class="lineno"> 3575</span>&#160;    }</div><div class="line"><a name="l03576"></a><span class="lineno"> 3576</span>&#160;</div><div class="line"><a name="l03577"></a><span class="lineno"> 3577</span>&#160;    Changed |= promoteAllocas(F);</div><div class="line"><a name="l03578"></a><span class="lineno"> 3578</span>&#160;</div><div class="line"><a name="l03579"></a><span class="lineno"> 3579</span>&#160;    Worklist = PostPromotionWorklist;</div><div class="line"><a name="l03580"></a><span class="lineno"> 3580</span>&#160;    PostPromotionWorklist.clear();</div><div class="line"><a name="l03581"></a><span class="lineno"> 3581</span>&#160;  } <span class="keywordflow">while</span> (!Worklist.empty());</div><div class="line"><a name="l03582"></a><span class="lineno"> 3582</span>&#160;</div><div class="line"><a name="l03583"></a><span class="lineno"> 3583</span>&#160;  <span class="keywordflow">return</span> Changed;</div><div class="line"><a name="l03584"></a><span class="lineno"> 3584</span>&#160;}</div><div class="line"><a name="l03585"></a><span class="lineno"> 3585</span>&#160;</div><div class="line"><a name="l03586"></a><span class="lineno"> 3586</span>&#160;<span class="keywordtype">void</span> SROA::getAnalysisUsage(<a class="code" href="classllvm_1_1AnalysisUsage.html">AnalysisUsage</a> &amp;AU)<span class="keyword"> const </span>{</div><div class="line"><a name="l03587"></a><span class="lineno"> 3587</span>&#160;  <span class="keywordflow">if</span> (RequiresDomTree)</div><div class="line"><a name="l03588"></a><span class="lineno"> 3588</span>&#160;    AU.<a class="code" href="classllvm_1_1AnalysisUsage.html#ae5c60fd282ee894c87ea02c3f0fcb6d0">addRequired</a>&lt;<a class="code" href="classllvm_1_1DominatorTree.html">DominatorTree</a>&gt;();</div><div class="line"><a name="l03589"></a><span class="lineno"> 3589</span>&#160;  AU.<a class="code" href="classllvm_1_1AnalysisUsage.html#af11a6ebf7ab3c388234cb6d5378439a3">setPreservesCFG</a>();</div><div class="line"><a name="l03590"></a><span class="lineno"> 3590</span>&#160;}</div><div class="ttc" id="classllvm_1_1MemIntrinsic_html_a42dd65db3521498f10afb8c6f66e1bb5"><div class="ttname"><a href="classllvm_1_1MemIntrinsic.html#a42dd65db3521498f10afb8c6f66e1bb5">llvm::MemIntrinsic::getAlignment</a></div><div class="ttdeci">unsigned getAlignment() const </div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00127">IntrinsicInst.h:127</a></div></div>
<div class="ttc" id="SROA_8cpp_html_ae4bd66bcc8e0dce3d4d67880b77c6b1b"><div class="ttname"><a href="SROA_8cpp.html#ae4bd66bcc8e0dce3d4d67880b77c6b1b">findCommonType</a></div><div class="ttdeci">Scalar Replacement Of static false Type * findCommonType(AllocaSlices::const_iterator B, AllocaSlices::const_iterator E, uint64_t EndOffset)</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l00937">SROA.cpp:937</a></div></div>
<div class="ttc" id="classllvm_1_1InstVisitor_html_aeb67eff747cfcdb17ca1079aff8ed9ca"><div class="ttname"><a href="classllvm_1_1InstVisitor.html#aeb67eff747cfcdb17ca1079aff8ed9ca">llvm::InstVisitor::visitSelectInst</a></div><div class="ttdeci">RetTy visitSelectInst(SelectInst &amp;I)</div><div class="ttdef"><b>Definition:</b> <a href="InstVisitor_8h_source.html#l00195">InstVisitor.h:195</a></div></div>
<div class="ttc" id="classllvm_1_1Pass_html"><div class="ttname"><a href="classllvm_1_1Pass.html">llvm::Pass</a></div><div class="ttdef"><b>Definition:</b> <a href="Pass_8h_source.html#l00082">Pass.h:82</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorTemplateCommon_html_a075e34e98605d0e7c289763a104869ac"><div class="ttname"><a href="classllvm_1_1SmallVectorTemplateCommon.html#a075e34e98605d0e7c289763a104869ac">llvm::SmallVectorTemplateCommon&lt; T &gt;::end</a></div><div class="ttdeci">iterator end()</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00114">SmallVector.h:114</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorTemplateCommon_html_a22a311dfe4c28a897de8a9365a4f0a84"><div class="ttname"><a href="classllvm_1_1SmallVectorTemplateCommon.html#a22a311dfe4c28a897de8a9365a4f0a84">llvm::SmallVectorTemplateCommon&lt; T &gt;::size</a></div><div class="ttdeci">size_type size() const</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00127">SmallVector.h:127</a></div></div>
<div class="ttc" id="classllvm_1_1StoreInst_html_a14298313bdf734e2db5a921cc6e861a0"><div class="ttname"><a href="classllvm_1_1StoreInst.html#a14298313bdf734e2db5a921cc6e861a0">llvm::StoreInst::getValueOperand</a></div><div class="ttdeci">Value * getValueOperand()</div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l00343">Instructions.h:343</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorTemplateBase_html_ae1a10b90f22c0478960fb5798ff73916"><div class="ttname"><a href="classllvm_1_1SmallVectorTemplateBase.html#ae1a10b90f22c0478960fb5798ff73916">llvm::SmallVectorTemplateBase&lt; T, isPodLike&lt; T &gt;::value &gt;::push_back</a></div><div class="ttdeci">void push_back(const T &amp;Elt)</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00236">SmallVector.h:236</a></div></div>
<div class="ttc" id="classllvm_1_1Value_html_ad86469939d2a8bdd4169be9403b89f5a"><div class="ttname"><a href="classllvm_1_1Value.html#ad86469939d2a8bdd4169be9403b89f5a">llvm::Value::use_end</a></div><div class="ttdeci">use_iterator use_end()</div><div class="ttdef"><b>Definition:</b> <a href="Value_8h_source.html#l00152">Value.h:152</a></div></div>
<div class="ttc" id="namespacellvm_1_1Intrinsic_html_a73349916f7e54a6b988a3646c7a02e90aa332b90dd5e4ebf4bbbcc0964220d373"><div class="ttname"><a href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90aa332b90dd5e4ebf4bbbcc0964220d373">llvm::Intrinsic::lifetime_end</a></div><div class="ttdef"><b>Definition:</b> <a href="Intrinsics_8h_source.html#l01254">Intrinsics.h:1254</a></div></div>
<div class="ttc" id="classllvm_1_1DataLayout_html"><div class="ttname"><a href="classllvm_1_1DataLayout.html">llvm::DataLayout</a></div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8h_source.html#l00098">DataLayout.h:98</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a1564307938a15a117873a7ab9a27e0a9"><div class="ttname"><a href="SROA_8cpp.html#a1564307938a15a117873a7ab9a27e0a9">removeFinishedSplitUses</a></div><div class="ttdeci">static void removeFinishedSplitUses(SmallVectorImpl&lt; AllocaSlices::iterator &gt; &amp;SplitUses, uint64_t &amp;MaxSplitUseEndOffset, uint64_t Offset)</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l03193">SROA.cpp:3193</a></div></div>
<div class="ttc" id="namespacellvm_1_1sys_1_1path_html_a214ec2f04ffd92636ed4bd2717607a1d"><div class="ttname"><a href="namespacellvm_1_1sys_1_1path.html#a214ec2f04ffd92636ed4bd2717607a1d">llvm::sys::path::end</a></div><div class="ttdeci">const_iterator end(StringRef path)</div><div class="ttdoc">Get end iterator over path. </div><div class="ttdef"><b>Definition:</b> <a href="Path_8cpp_source.html#l00181">Path.cpp:181</a></div></div>
<div class="ttc" id="classllvm_1_1ConstantInt_html_a240475f85dea79ec272c578fdf89acf1"><div class="ttname"><a href="classllvm_1_1ConstantInt.html#a240475f85dea79ec272c578fdf89acf1">llvm::ConstantInt::getType</a></div><div class="ttdeci">IntegerType * getType() const </div><div class="ttdef"><b>Definition:</b> <a href="Constants_8h_source.html#l00139">Constants.h:139</a></div></div>
<div class="ttc" id="classllvm_1_1detail_1_1PtrUseVisitorBase_1_1PtrInfo_html_a0d01c5defbda1273d906583864bf1e2d"><div class="ttname"><a href="classllvm_1_1detail_1_1PtrUseVisitorBase_1_1PtrInfo.html#a0d01c5defbda1273d906583864bf1e2d">llvm::detail::PtrUseVisitorBase::PtrInfo::isEscaped</a></div><div class="ttdeci">bool isEscaped() const </div><div class="ttdoc">Is the pointer escaped at some point? </div><div class="ttdef"><b>Definition:</b> <a href="PtrUseVisitor_8h_source.html#l00065">PtrUseVisitor.h:65</a></div></div>
<div class="ttc" id="classllvm_1_1SmallDenseMap_html"><div class="ttname"><a href="classllvm_1_1SmallDenseMap.html">llvm::SmallDenseMap&lt; Instruction *, unsigned &gt;</a></div></div>
<div class="ttc" id="Loads_8h_html"><div class="ttname"><a href="Loads_8h.html">Loads.h</a></div></div>
<div class="ttc" id="classllvm_1_1InstVisitor_html_ad401dce38c15719e37382c854618dd15"><div class="ttname"><a href="classllvm_1_1InstVisitor.html#ad401dce38c15719e37382c854618dd15">llvm::InstVisitor::visitMemSetInst</a></div><div class="ttdeci">RetTy visitMemSetInst(MemSetInst &amp;I)</div><div class="ttdef"><b>Definition:</b> <a href="InstVisitor_8h_source.html#l00208">InstVisitor.h:208</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorImpl_html_a4786e64977a3af38f29adee46b70a863"><div class="ttname"><a href="classllvm_1_1SmallVectorImpl.html#a4786e64977a3af38f29adee46b70a863">llvm::SmallVectorImpl::reserve</a></div><div class="ttdeci">void reserve(unsigned N)</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00425">SmallVector.h:425</a></div></div>
<div class="ttc" id="classllvm_1_1SSAUpdater_html"><div class="ttname"><a href="classllvm_1_1SSAUpdater.html">llvm::SSAUpdater</a></div><div class="ttdoc">Helper class for SSA formation on a set of values defined in multiple blocks. </div><div class="ttdef"><b>Definition:</b> <a href="SSAUpdater_8h_source.html#l00037">SSAUpdater.h:37</a></div></div>
<div class="ttc" id="classllvm_1_1PHINode_html_a089cccb6f231efee72abc76d0f9c695f"><div class="ttname"><a href="classllvm_1_1PHINode.html#a089cccb6f231efee72abc76d0f9c695f">llvm::PHINode::addIncoming</a></div><div class="ttdeci">void addIncoming(Value *V, BasicBlock *BB)</div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l02100">Instructions.h:2100</a></div></div>
<div class="ttc" id="classllvm_1_1PassRegistry_html_a05a729900b76c89e808c6c3094921b2f"><div class="ttname"><a href="classllvm_1_1PassRegistry.html#a05a729900b76c89e808c6c3094921b2f">llvm::PassRegistry::getPassRegistry</a></div><div class="ttdeci">static PassRegistry * getPassRegistry()</div><div class="ttdef"><b>Definition:</b> <a href="PassRegistry_8cpp_source.html#l00035">PassRegistry.cpp:35</a></div></div>
<div class="ttc" id="classllvm_1_1Function_html_a2da53ac53516a3f16191f4c8a8eaa3e5"><div class="ttname"><a href="classllvm_1_1Function.html#a2da53ac53516a3f16191f4c8a8eaa3e5">llvm::Function::getContext</a></div><div class="ttdeci">LLVMContext &amp; getContext() const </div><div class="ttdef"><b>Definition:</b> <a href="Function_8cpp_source.html#l00167">Function.cpp:167</a></div></div>
<div class="ttc" id="namespacellvm_1_1SPII_html_a11e9b8fca4a074643a6a21f444e51406a5069619ca8fdce305534f3fe85091a0f"><div class="ttname"><a href="namespacellvm_1_1SPII.html#a11e9b8fca4a074643a6a21f444e51406a5069619ca8fdce305534f3fe85091a0f">llvm::SPII::Load</a></div><div class="ttdef"><b>Definition:</b> <a href="SparcInstrInfo_8h_source.html#l00031">SparcInstrInfo.h:31</a></div></div>
<div class="ttc" id="classllvm_1_1Instruction_html_a6fe2f06b8a4b2c3d6308afb223a0238a"><div class="ttname"><a href="classllvm_1_1Instruction.html#a6fe2f06b8a4b2c3d6308afb223a0238a">llvm::Instruction::eraseFromParent</a></div><div class="ttdeci">void eraseFromParent()</div><div class="ttdef"><b>Definition:</b> <a href="Instruction_8cpp_source.html#l00072">Instruction.cpp:72</a></div></div>
<div class="ttc" id="classllvm_1_1Argument_html"><div class="ttname"><a href="classllvm_1_1Argument.html">llvm::Argument</a></div><div class="ttdoc">LLVM Argument representation. </div><div class="ttdef"><b>Definition:</b> <a href="Argument_8h_source.html#l00035">Argument.h:35</a></div></div>
<div class="ttc" id="classllvm_1_1InstVisitor_html"><div class="ttname"><a href="classllvm_1_1InstVisitor.html">llvm::InstVisitor</a></div><div class="ttdoc">Base class for instruction visitors. </div><div class="ttdef"><b>Definition:</b> <a href="InstVisitor_8h_source.html#l00081">InstVisitor.h:81</a></div></div>
<div class="ttc" id="classllvm_1_1APInt_html_a7dc983ebf0eb2d255fa90a67063c72e2"><div class="ttname"><a href="classllvm_1_1APInt.html#a7dc983ebf0eb2d255fa90a67063c72e2">llvm::APInt::getZExtValue</a></div><div class="ttdeci">uint64_t getZExtValue() const </div><div class="ttdoc">Get zero extended value. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l01306">APInt.h:1306</a></div></div>
<div class="ttc" id="Instructions_8h_html"><div class="ttname"><a href="Instructions_8h.html">Instructions.h</a></div></div>
<div class="ttc" id="classllvm_1_1LoadAndStorePromoter_html_a0e97a303d712494969b8800d3b6d712d"><div class="ttname"><a href="classllvm_1_1LoadAndStorePromoter.html#a0e97a303d712494969b8800d3b6d712d">llvm::LoadAndStorePromoter::run</a></div><div class="ttdeci">void run(const SmallVectorImpl&lt; Instruction * &gt; &amp;Insts) const </div><div class="ttdoc">This does the promotion. </div><div class="ttdef"><b>Definition:</b> <a href="SSAUpdater_8cpp_source.html#l00342">SSAUpdater.cpp:342</a></div></div>
<div class="ttc" id="namespacellvm_html"><div class="ttname"><a href="namespacellvm.html">llvm</a></div><div class="ttdoc">List of target independent CodeGen pass IDs. </div><div class="ttdef"><b>Definition:</b> <a href="APFloat_8h_source.html#l00022">APFloat.h:22</a></div></div>
<div class="ttc" id="classllvm_1_1StoreInst_html_a89471513a05fad4bbef69ec411b2586d"><div class="ttname"><a href="classllvm_1_1StoreInst.html#a89471513a05fad4bbef69ec411b2586d">llvm::StoreInst::isVolatile</a></div><div class="ttdeci">bool isVolatile() const </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l00287">Instructions.h:287</a></div></div>
<div class="ttc" id="classllvm_1_1MemIntrinsic_html_a9558faebdbb62c072aed98e33604889d"><div class="ttname"><a href="classllvm_1_1MemIntrinsic.html#a9558faebdbb62c072aed98e33604889d">llvm::MemIntrinsic::isVolatile</a></div><div class="ttdeci">bool isVolatile() const </div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00134">IntrinsicInst.h:134</a></div></div>
<div class="ttc" id="DerivedTypes_8h_html"><div class="ttname"><a href="DerivedTypes_8h.html">DerivedTypes.h</a></div></div>
<div class="ttc" id="classllvm_1_1GlobalAlias_html"><div class="ttname"><a href="classllvm_1_1GlobalAlias.html">llvm::GlobalAlias</a></div><div class="ttdef"><b>Definition:</b> <a href="GlobalAlias_8h_source.html#l00029">GlobalAlias.h:29</a></div></div>
<div class="ttc" id="classllvm_1_1IntrinsicInst_html_a6cbb4809b81f3994ee0c79b38556bd66"><div class="ttname"><a href="classllvm_1_1IntrinsicInst.html#a6cbb4809b81f3994ee0c79b38556bd66">llvm::IntrinsicInst::getIntrinsicID</a></div><div class="ttdeci">Intrinsic::ID getIntrinsicID() const </div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00043">IntrinsicInst.h:43</a></div></div>
<div class="ttc" id="classllvm_1_1MemIntrinsic_html_a5938120897cc6e41505886618fe2748d"><div class="ttname"><a href="classllvm_1_1MemIntrinsic.html#a5938120897cc6e41505886618fe2748d">llvm::MemIntrinsic::getAlignmentCst</a></div><div class="ttdeci">ConstantInt * getAlignmentCst() const </div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00123">IntrinsicInst.h:123</a></div></div>
<div class="ttc" id="IntrinsicInst_8h_html"><div class="ttname"><a href="IntrinsicInst_8h.html">IntrinsicInst.h</a></div></div>
<div class="ttc" id="classllvm_1_1MemSetInst_html_a357f35c4ac1c01e84d73a4a9e26f6aac"><div class="ttname"><a href="classllvm_1_1MemSetInst.html#a357f35c4ac1c01e84d73a4a9e26f6aac">llvm::MemSetInst::getValue</a></div><div class="ttdeci">Value * getValue() const </div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00194">IntrinsicInst.h:194</a></div></div>
<div class="ttc" id="namespacellvm_html_a3f2f98c2a67c9e79f58aad9150a62e42"><div class="ttname"><a href="namespacellvm.html#a3f2f98c2a67c9e79f58aad9150a62e42">llvm::dyn_cast</a></div><div class="ttdeci">enable_if_c&lt;!is_simple_type&lt; Y &gt;::value, typename cast_retty&lt; X, const Y &gt;::ret_type &gt;::type dyn_cast(const Y &amp;Val)</div><div class="ttdef"><b>Definition:</b> <a href="Casting_8h_source.html#l00266">Casting.h:266</a></div></div>
<div class="ttc" id="classllvm_1_1ZExtInst_html"><div class="ttname"><a href="classllvm_1_1ZExtInst.html">llvm::ZExtInst</a></div><div class="ttdoc">This class represents zero extension of integer types. </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l03211">Instructions.h:3211</a></div></div>
<div class="ttc" id="DataLayout_8h_html"><div class="ttname"><a href="DataLayout_8h.html">DataLayout.h</a></div></div>
<div class="ttc" id="classllvm_1_1ArrayRef_html_a38ed8cc3c342ad6910e8c869d3e2b9cf"><div class="ttname"><a href="classllvm_1_1ArrayRef.html#a38ed8cc3c342ad6910e8c869d3e2b9cf">llvm::ArrayRef::end</a></div><div class="ttdeci">iterator end() const </div><div class="ttdef"><b>Definition:</b> <a href="ArrayRef_8h_source.html#l00098">ArrayRef.h:98</a></div></div>
<div class="ttc" id="classllvm_1_1StoreInst_html_a1149c7eeefca671ac2685bca13843568"><div class="ttname"><a href="classllvm_1_1StoreInst.html#a1149c7eeefca671ac2685bca13843568">llvm::StoreInst::isSimple</a></div><div class="ttdeci">bool isSimple() const </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l00338">Instructions.h:338</a></div></div>
<div class="ttc" id="classllvm_1_1detail_1_1PtrUseVisitorBase_1_1PtrInfo_html_a1312e1c22248e53e2e0c9c374a1352f6"><div class="ttname"><a href="classllvm_1_1detail_1_1PtrUseVisitorBase_1_1PtrInfo.html#a1312e1c22248e53e2e0c9c374a1352f6">llvm::detail::PtrUseVisitorBase::PtrInfo::getAbortingInst</a></div><div class="ttdeci">Instruction * getAbortingInst() const </div><div class="ttdoc">Get the instruction causing the visit to abort. </div><div class="ttdef"><b>Definition:</b> <a href="PtrUseVisitor_8h_source.html#l00070">PtrUseVisitor.h:70</a></div></div>
<div class="ttc" id="README-SSE_8txt_html_a63d206a063eefcdf8c318ded97b65020"><div class="ttname"><a href="README-SSE_8txt.html#a63d206a063eefcdf8c318ded97b65020">P</a></div><div class="ttdeci">This currently compiles esp xmm0 movsd esp eax eax esp ret We should use not the dag combiner This is because dagcombine2 needs to be able to see through the X86ISD::Wrapper which DAGCombine can t really do The code for turning x load into a single vector load is target independent and should be moved to the dag combiner The code for turning x load into a vector load can only handle a direct load from a global or a direct load from the stack It should be generalized to handle any load from P</div><div class="ttdef"><b>Definition:</b> <a href="README-SSE_8txt_source.html#l00427">README-SSE.txt:427</a></div></div>
<div class="ttc" id="classllvm_1_1PHINode_html"><div class="ttname"><a href="classllvm_1_1PHINode.html">llvm::PHINode</a></div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l01978">Instructions.h:1978</a></div></div>
<div class="ttc" id="classllvm_1_1detail_1_1PtrUseVisitorBase_1_1PtrInfo_html"><div class="ttname"><a href="classllvm_1_1detail_1_1PtrUseVisitorBase_1_1PtrInfo.html">llvm::detail::PtrUseVisitorBase::PtrInfo</a></div><div class="ttdoc">This class provides information about the result of a visit. </div><div class="ttdef"><b>Definition:</b> <a href="PtrUseVisitor_8h_source.html#l00049">PtrUseVisitor.h:49</a></div></div>
<div class="ttc" id="Debug_8h_html"><div class="ttname"><a href="Debug_8h.html">Debug.h</a></div></div>
<div class="ttc" id="classllvm_1_1CallInst_html"><div class="ttname"><a href="classllvm_1_1CallInst.html">llvm::CallInst</a></div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l01161">Instructions.h:1161</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a94e7aca18fb08798727209385f164f7c"><div class="ttname"><a href="SROA_8cpp.html#a94e7aca18fb08798727209385f164f7c">extractInteger</a></div><div class="ttdeci">static Value * extractInteger(const DataLayout &amp;DL, IRBuilderTy &amp;IRB, Value *V, IntegerType *Ty, uint64_t Offset, const Twine &amp;Name)</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01766">SROA.cpp:1766</a></div></div>
<div class="ttc" id="namespacellvm_1_1cl_html_afcbd4ecc474e2d218391d6d3027b086aa7861ef1db44eac8ea7a373cd7c53a7c5"><div class="ttname"><a href="namespacellvm_1_1cl.html#afcbd4ecc474e2d218391d6d3027b086aa7861ef1db44eac8ea7a373cd7c53a7c5">llvm::cl::Prefix</a></div><div class="ttdef"><b>Definition:</b> <a href="CommandLine_8h_source.html#l00131">CommandLine.h:131</a></div></div>
<div class="ttc" id="classllvm_1_1SmallPtrSet_html_a9b6dd0fc7a648a939e571246045b673e"><div class="ttname"><a href="classllvm_1_1SmallPtrSet.html#a9b6dd0fc7a648a939e571246045b673e">llvm::SmallPtrSet::insert</a></div><div class="ttdeci">bool insert(PtrType Ptr)</div><div class="ttdef"><b>Definition:</b> <a href="SmallPtrSet_8h_source.html#l00253">SmallPtrSet.h:253</a></div></div>
<div class="ttc" id="classllvm_1_1Instruction_html_a573063aad4c101462893d0490d867524"><div class="ttname"><a href="classllvm_1_1Instruction.html#a573063aad4c101462893d0490d867524">llvm::Instruction::mayHaveSideEffects</a></div><div class="ttdeci">bool mayHaveSideEffects() const </div><div class="ttdef"><b>Definition:</b> <a href="Instruction_8h_source.html#l00324">Instruction.h:324</a></div></div>
<div class="ttc" id="namespacellvm_html_a7c469a194119a14e5a018ebb9b847cf0"><div class="ttname"><a href="namespacellvm.html#a7c469a194119a14e5a018ebb9b847cf0">llvm::operator&lt;</a></div><div class="ttdeci">void operator&lt;(const Optional&lt; T &gt; &amp;X, const Optional&lt; U &gt; &amp;Y)</div><div class="ttdoc">Poison comparison between two Optional objects. Clients needs to explicitly compare the underlying va...</div></div>
<div class="ttc" id="SROA_8cpp_html_a613f24111340d4f4fc57e01da7a083b5"><div class="ttname"><a href="SROA_8cpp.html#a613f24111340d4f4fc57e01da7a083b5">ForceSSAUpdater</a></div><div class="ttdeci">static cl::opt&lt; bool &gt; ForceSSAUpdater(&quot;force-ssa-updater&quot;, cl::init(false), cl::Hidden)</div></div>
<div class="ttc" id="classllvm_1_1APInt_html_ae0c5e70885cf005feb6707932774f99c"><div class="ttname"><a href="classllvm_1_1APInt.html#ae0c5e70885cf005feb6707932774f99c">llvm::APInt::getLimitedValue</a></div><div class="ttdeci">uint64_t getLimitedValue(uint64_t Limit=~0ULL) const </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l00408">APInt.h:408</a></div></div>
<div class="ttc" id="namespacellvm_1_1NVPTX_1_1PTXLdStInstCode_html_a91119cbee2be000c528a690252aee07ca09c68d67f7dbfa6cc77eaf73aa535217"><div class="ttname"><a href="namespacellvm_1_1NVPTX_1_1PTXLdStInstCode.html#a91119cbee2be000c528a690252aee07ca09c68d67f7dbfa6cc77eaf73aa535217">llvm::NVPTX::PTXLdStInstCode::Scalar</a></div><div class="ttdef"><b>Definition:</b> <a href="NVPTX_8h_source.html#l00126">NVPTX.h:126</a></div></div>
<div class="ttc" id="namespacellvm_1_1sys_1_1path_html_a33706aab89e700b8f79e1fa6f4f0e3ee"><div class="ttname"><a href="namespacellvm_1_1sys_1_1path.html#a33706aab89e700b8f79e1fa6f4f0e3ee">llvm::sys::path::begin</a></div><div class="ttdeci">const_iterator begin(StringRef path)</div><div class="ttdoc">Get begin iterator over path. </div><div class="ttdef"><b>Definition:</b> <a href="Path_8cpp_source.html#l00173">Path.cpp:173</a></div></div>
<div class="ttc" id="classllvm_1_1MemSetInst_html"><div class="ttname"><a href="classllvm_1_1MemSetInst.html">llvm::MemSetInst</a></div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00190">IntrinsicInst.h:190</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a5b3f8e5f6c512fe6a5059dd0c51aec95"><div class="ttname"><a href="SROA_8cpp.html#a5b3f8e5f6c512fe6a5059dd0c51aec95">Aggregates</a></div><div class="ttdeci">Scalar Replacement Of Aggregates</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l00932">SROA.cpp:932</a></div></div>
<div class="ttc" id="SSAUpdater_8h_html"><div class="ttname"><a href="SSAUpdater_8h.html">SSAUpdater.h</a></div></div>
<div class="ttc" id="classllvm_1_1MDNode_html"><div class="ttname"><a href="classllvm_1_1MDNode.html">llvm::MDNode</a></div><div class="ttdoc">MDNode - a tuple of other values. </div><div class="ttdef"><b>Definition:</b> <a href="Metadata_8h_source.html#l00073">Metadata.h:73</a></div></div>
<div class="ttc" id="namespacellvm_html_afd92ce3a3b5db58abf81981d3fcd95c6"><div class="ttname"><a href="namespacellvm.html#afd92ce3a3b5db58abf81981d3fcd95c6">llvm::PromoteMemToReg</a></div><div class="ttdeci">void PromoteMemToReg(ArrayRef&lt; AllocaInst * &gt; Allocas, DominatorTree &amp;DT, AliasSetTracker *AST=0)</div><div class="ttdoc">Promote the specified list of alloca instructions into scalar registers, inserting PHI nodes as appro...</div><div class="ttdef"><b>Definition:</b> <a href="PromoteMemoryToRegister_8cpp_source.html#l01072">PromoteMemoryToRegister.cpp:1072</a></div></div>
<div class="ttc" id="LLParser_8cpp_html_a33ece1ef8074506a15d7f86eb76dbae6"><div class="ttname"><a href="LLParser_8cpp.html#a33ece1ef8074506a15d7f86eb76dbae6">F</a></div><div class="ttdeci">F(f)</div></div>
<div class="ttc" id="namespacellvm_html_a2bb15e529c55b5356aabfb006d1e98aa"><div class="ttname"><a href="namespacellvm.html#a2bb15e529c55b5356aabfb006d1e98aa">llvm::isSafeToLoadUnconditionally</a></div><div class="ttdeci">bool isSafeToLoadUnconditionally(Value *V, Instruction *ScanFrom, unsigned Align, const DataLayout *TD=0)</div><div class="ttdef"><b>Definition:</b> <a href="Loads_8cpp_source.html#l00056">Loads.cpp:56</a></div></div>
<div class="ttc" id="classllvm_1_1SExtInst_html"><div class="ttname"><a href="classllvm_1_1SExtInst.html">llvm::SExtInst</a></div><div class="ttdoc">This class represents a sign extension of integer types. </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l03247">Instructions.h:3247</a></div></div>
<div class="ttc" id="classllvm_1_1Function_html"><div class="ttname"><a href="classllvm_1_1Function.html">llvm::Function</a></div><div class="ttdef"><b>Definition:</b> <a href="Function_8h_source.html#l00070">Function.h:70</a></div></div>
<div class="ttc" id="classllvm_1_1LoadInst_html"><div class="ttname"><a href="classllvm_1_1LoadInst.html">llvm::LoadInst</a></div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l00136">Instructions.h:136</a></div></div>
<div class="ttc" id="classllvm_1_1IntegerType_html_a6f603ab84f6f7c79985036f58cca9d48"><div class="ttname"><a href="classllvm_1_1IntegerType.html#a6f603ab84f6f7c79985036f58cca9d48">llvm::IntegerType::getBitWidth</a></div><div class="ttdeci">unsigned getBitWidth() const </div><div class="ttdoc">Get the number of bits in this IntegerType. </div><div class="ttdef"><b>Definition:</b> <a href="DerivedTypes_8h_source.html#l00061">DerivedTypes.h:61</a></div></div>
<div class="ttc" id="classllvm_1_1InstVisitor_html_a6b5f364cdf10081c74343b149fbc325f"><div class="ttname"><a href="classllvm_1_1InstVisitor.html#a6b5f364cdf10081c74343b149fbc325f">llvm::InstVisitor::visitPHINode</a></div><div class="ttdeci">RetTy visitPHINode(PHINode &amp;I)</div><div class="ttdef"><b>Definition:</b> <a href="InstVisitor_8h_source.html#l00181">InstVisitor.h:181</a></div></div>
<div class="ttc" id="classllvm_1_1MemIntrinsic_html_a3bca2c8dcf6ef46eff601e8738b2d3b0"><div class="ttname"><a href="classllvm_1_1MemIntrinsic.html#a3bca2c8dcf6ef46eff601e8738b2d3b0">llvm::MemIntrinsic::setDest</a></div><div class="ttdeci">void setDest(Value *Ptr)</div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00149">IntrinsicInst.h:149</a></div></div>
<div class="ttc" id="Statistic_8h_html"><div class="ttname"><a href="Statistic_8h.html">Statistic.h</a></div></div>
<div class="ttc" id="classllvm_1_1LoadInst_html_a156c478ee8e7d1602143cdbad4bd5385"><div class="ttname"><a href="classllvm_1_1LoadInst.html#a156c478ee8e7d1602143cdbad4bd5385">llvm::LoadInst::isSimple</a></div><div class="ttdeci">bool isSimple() const </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l00218">Instructions.h:218</a></div></div>
<div class="ttc" id="classllvm_1_1MemIntrinsic_html_a2dc2a7867d2c559ae17261d3f595f0d9"><div class="ttname"><a href="classllvm_1_1MemIntrinsic.html#a2dc2a7867d2c559ae17261d3f595f0d9">llvm::MemIntrinsic::setAlignment</a></div><div class="ttdeci">void setAlignment(Constant *A)</div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00161">IntrinsicInst.h:161</a></div></div>
<div class="ttc" id="classllvm_1_1APInt_html_a7fe47410bb825eccb20f010dab13c72f"><div class="ttname"><a href="classllvm_1_1APInt.html#a7fe47410bb825eccb20f010dab13c72f">llvm::APInt::zextOrTrunc</a></div><div class="ttdeci">APInt LLVM_ATTRIBUTE_UNUSED_RESULT zextOrTrunc(unsigned width) const </div><div class="ttdoc">Zero extend or truncate to width. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8cpp_source.html#l01002">APInt.cpp:1002</a></div></div>
<div class="ttc" id="classllvm_1_1Instruction_html_a7bd545769621a0a9d2cfb074f86f4295"><div class="ttname"><a href="classllvm_1_1Instruction.html#a7bd545769621a0a9d2cfb074f86f4295">llvm::Instruction::setDebugLoc</a></div><div class="ttdeci">void setDebugLoc(const DebugLoc &amp;Loc)</div><div class="ttdoc">setDebugLoc - Set the debug location information for this instruction. </div><div class="ttdef"><b>Definition:</b> <a href="Instruction_8h_source.html#l00175">Instruction.h:175</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a3f3e524fc962e72389c1e1eedc03229c"><div class="ttname"><a href="SROA_8cpp.html#a3f3e524fc962e72389c1e1eedc03229c">enqueueUsersInWorklist</a></div><div class="ttdeci">static void enqueueUsersInWorklist(Instruction &amp;I, SmallVectorImpl&lt; Instruction * &gt; &amp;Worklist, SmallPtrSet&lt; Instruction *, 8 &gt; &amp;Visited)</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l03432">SROA.cpp:3432</a></div></div>
<div class="ttc" id="classllvm_1_1User_html_a2eeb1c7ed1cfe403f2ae0470e36c07e2"><div class="ttname"><a href="classllvm_1_1User.html#a2eeb1c7ed1cfe403f2ae0470e36c07e2">llvm::User::op_begin</a></div><div class="ttdeci">op_iterator op_begin()</div><div class="ttdef"><b>Definition:</b> <a href="User_8h_source.html#l00116">User.h:116</a></div></div>
<div class="ttc" id="namespacellvm_1_1cl_html_a68075925a54790e71ca790e1d4f21a40a263ac008d8d31f13ce460395fc4cf7e6"><div class="ttname"><a href="namespacellvm_1_1cl.html#a68075925a54790e71ca790e1d4f21a40a263ac008d8d31f13ce460395fc4cf7e6">llvm::cl::Hidden</a></div><div class="ttdef"><b>Definition:</b> <a href="CommandLine_8h_source.html#l00109">CommandLine.h:109</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a40145cc8bb126bba70637669bbb6dad8"><div class="ttname"><a href="SROA_8cpp.html#a40145cc8bb126bba70637669bbb6dad8">isSafePHIToSpeculate</a></div><div class="ttdeci">static bool isSafePHIToSpeculate(PHINode &amp;PN, const DataLayout *DL=0)</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01005">SROA.cpp:1005</a></div></div>
<div class="ttc" id="classAllocaSlices_1_1SliceBuilder_html"><div class="ttname"><a href="classAllocaSlices_1_1SliceBuilder.html">AllocaSlices::SliceBuilder</a></div><div class="ttdoc">Builder for the alloca slices. </div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l00313">SROA.cpp:313</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_a5c09d927a0079ad16e8367271efe9bc2"><div class="ttname"><a href="classllvm_1_1Type.html#a5c09d927a0079ad16e8367271efe9bc2">llvm::Type::getPointerElementType</a></div><div class="ttdeci">Type * getPointerElementType() const </div><div class="ttdef"><b>Definition:</b> <a href="Type_8h_source.html#l00373">Type.h:373</a></div></div>
<div class="ttc" id="classllvm_1_1Value_html_ad452febc1ac0b394876e640ec03ffa38"><div class="ttname"><a href="classllvm_1_1Value.html#ad452febc1ac0b394876e640ec03ffa38">llvm::Value::getName</a></div><div class="ttdeci">StringRef getName() const </div><div class="ttdef"><b>Definition:</b> <a href="Value_8cpp_source.html#l00167">Value.cpp:167</a></div></div>
<div class="ttc" id="classllvm_1_1DIBuilder_html"><div class="ttname"><a href="classllvm_1_1DIBuilder.html">llvm::DIBuilder</a></div><div class="ttdef"><b>Definition:</b> <a href="DIBuilder_8h_source.html#l00055">DIBuilder.h:55</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_a36e21267fe14e69d3251eab1cd3a0076"><div class="ttname"><a href="classllvm_1_1Type.html#a36e21267fe14e69d3251eab1cd3a0076">llvm::Type::isSingleValueType</a></div><div class="ttdeci">bool isSingleValueType() const </div><div class="ttdef"><b>Definition:</b> <a href="Type_8h_source.html#l00259">Type.h:259</a></div></div>
<div class="ttc" id="classllvm_1_1StructType_html_a1a716e87e6d2a1de3fcfd0682ed3fd1f"><div class="ttname"><a href="classllvm_1_1StructType.html#a1a716e87e6d2a1de3fcfd0682ed3fd1f">llvm::StructType::element_end</a></div><div class="ttdeci">element_iterator element_end() const </div><div class="ttdef"><b>Definition:</b> <a href="DerivedTypes_8h_source.html#l00279">DerivedTypes.h:279</a></div></div>
<div class="ttc" id="classllvm_1_1APInt_html_a0e9a2d7ec903d191ef029589ec647cb6"><div class="ttname"><a href="classllvm_1_1APInt.html#a0e9a2d7ec903d191ef029589ec647cb6">llvm::APInt::isNegative</a></div><div class="ttdeci">bool isNegative() const </div><div class="ttdoc">Determine sign of this APInt. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l00322">APInt.h:322</a></div></div>
<div class="ttc" id="classllvm_1_1AllocaInst_html_a066eba0d0eb9d9655c9b580a2a279b0a"><div class="ttname"><a href="classllvm_1_1AllocaInst.html#a066eba0d0eb9d9655c9b580a2a279b0a">llvm::AllocaInst::isArrayAllocation</a></div><div class="ttdeci">bool isArrayAllocation() const </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8cpp_source.html#l00900">Instructions.cpp:900</a></div></div>
<div class="ttc" id="PromoteMemToReg_8h_html"><div class="ttname"><a href="PromoteMemToReg_8h.html">PromoteMemToReg.h</a></div></div>
<div class="ttc" id="classllvm_1_1AnalysisUsage_html_ae5c60fd282ee894c87ea02c3f0fcb6d0"><div class="ttname"><a href="classllvm_1_1AnalysisUsage.html#ae5c60fd282ee894c87ea02c3f0fcb6d0">llvm::AnalysisUsage::addRequired</a></div><div class="ttdeci">AnalysisUsage &amp; addRequired()</div><div class="ttdef"><b>Definition:</b> <a href="PassAnalysisSupport_8h_source.html#l00055">PassAnalysisSupport.h:55</a></div></div>
<div class="ttc" id="namespacellvm_1_1GraphProgram_html_a0ad4685976f8c4d4a697a53fbe05d10b"><div class="ttname"><a href="namespacellvm_1_1GraphProgram.html#a0ad4685976f8c4d4a697a53fbe05d10b">llvm::GraphProgram::Name</a></div><div class="ttdeci">Name</div><div class="ttdef"><b>Definition:</b> <a href="GraphWriter_8h_source.html#l00044">GraphWriter.h:44</a></div></div>
<div class="ttc" id="classllvm_1_1StructLayout_html"><div class="ttname"><a href="classllvm_1_1StructLayout.html">llvm::StructLayout</a></div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8h_source.html#l00418">DataLayout.h:418</a></div></div>
<div class="ttc" id="SROA_8cpp_html_ae70113602d2d74907fc766c32cc4ae7d"><div class="ttname"><a href="SROA_8cpp.html#ae70113602d2d74907fc766c32cc4ae7d">STATISTIC</a></div><div class="ttdeci">STATISTIC(NumAllocasAnalyzed,&quot;Number of allocas analyzed for replacement&quot;)</div></div>
<div class="ttc" id="PassSupport_8h_html_a14724f1ccf528e73bb29bc9230737967"><div class="ttname"><a href="PassSupport_8h.html#a14724f1ccf528e73bb29bc9230737967">INITIALIZE_PASS_DEPENDENCY</a></div><div class="ttdeci">#define INITIALIZE_PASS_DEPENDENCY(depName)</div><div class="ttdef"><b>Definition:</b> <a href="PassSupport_8h_source.html#l00167">PassSupport.h:167</a></div></div>
<div class="ttc" id="classllvm_1_1StructType_html_a883dd52cca7097874337641ca44473a0"><div class="ttname"><a href="classllvm_1_1StructType.html#a883dd52cca7097874337641ca44473a0">llvm::StructType::isPacked</a></div><div class="ttdeci">bool isPacked() const </div><div class="ttdef"><b>Definition:</b> <a href="DerivedTypes_8h_source.html#l00241">DerivedTypes.h:241</a></div></div>
<div class="ttc" id="classllvm_1_1Twine_html_aaabc8308782f695c3a2cc9dee510ab53"><div class="ttname"><a href="classllvm_1_1Twine.html#aaabc8308782f695c3a2cc9dee510ab53">llvm::Twine::str</a></div><div class="ttdeci">std::string str() const </div><div class="ttdoc">str - Return the twine contents as a std::string. </div><div class="ttdef"><b>Definition:</b> <a href="Twine_8cpp_source.html#l00016">Twine.cpp:16</a></div></div>
<div class="ttc" id="Delinearization_8cpp_html_a67193aea0752a127930d6f762e685eef"><div class="ttname"><a href="Delinearization_8cpp.html#a67193aea0752a127930d6f762e685eef">getPointerOperand</a></div><div class="ttdeci">static Value * getPointerOperand(Instruction &amp;Inst)</div><div class="ttdef"><b>Definition:</b> <a href="Delinearization_8cpp_source.html#l00072">Delinearization.cpp:72</a></div></div>
<div class="ttc" id="classllvm_1_1value__use__iterator_html"><div class="ttname"><a href="classllvm_1_1value__use__iterator.html">llvm::value_use_iterator</a></div><div class="ttdef"><b>Definition:</b> <a href="Use_8h_source.html#l00168">Use.h:168</a></div></div>
<div class="ttc" id="classllvm_1_1SelectInst_html"><div class="ttname"><a href="classllvm_1_1SelectInst.html">llvm::SelectInst</a></div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l01430">Instructions.h:1430</a></div></div>
<div class="ttc" id="classllvm_1_1Twine_html"><div class="ttname"><a href="classllvm_1_1Twine.html">llvm::Twine</a></div><div class="ttdef"><b>Definition:</b> <a href="Twine_8h_source.html#l00081">Twine.h:81</a></div></div>
<div class="ttc" id="classllvm_1_1StructType_html_a93ee26a67ca79e4ba796dcccb55e8c19"><div class="ttname"><a href="classllvm_1_1StructType.html#a93ee26a67ca79e4ba796dcccb55e8c19">llvm::StructType::element_iterator</a></div><div class="ttdeci">Type::subtype_iterator element_iterator</div><div class="ttdef"><b>Definition:</b> <a href="DerivedTypes_8h_source.html#l00277">DerivedTypes.h:277</a></div></div>
<div class="ttc" id="classllvm_1_1DataLayout_html_a35c840104f32575e0d91422cf1ef3ce4"><div class="ttname"><a href="classllvm_1_1DataLayout.html#a35c840104f32575e0d91422cf1ef3ce4">llvm::DataLayout::getStructLayout</a></div><div class="ttdeci">const StructLayout * getStructLayout(StructType *Ty) const </div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8cpp_source.html#l00445">DataLayout.cpp:445</a></div></div>
<div class="ttc" id="classllvm_1_1InstVisitor_html_a432d533de0923ad3b0fd6dfc22c7ebd6"><div class="ttname"><a href="classllvm_1_1InstVisitor.html#a432d533de0923ad3b0fd6dfc22c7ebd6">llvm::InstVisitor::visitIntrinsicInst</a></div><div class="ttdeci">RetTy visitIntrinsicInst(IntrinsicInst &amp;I)</div><div class="ttdef"><b>Definition:</b> <a href="InstVisitor_8h_source.html#l00216">InstVisitor.h:216</a></div></div>
<div class="ttc" id="classllvm_1_1ConstantInt_html_af8dde13a97efce293a7b04daf1e208fb"><div class="ttname"><a href="classllvm_1_1ConstantInt.html#af8dde13a97efce293a7b04daf1e208fb">llvm::ConstantInt::getValue</a></div><div class="ttdeci">const APInt &amp; getValue() const </div><div class="ttdoc">Return the constant&amp;#39;s value. </div><div class="ttdef"><b>Definition:</b> <a href="Constants_8h_source.html#l00105">Constants.h:105</a></div></div>
<div class="ttc" id="namespacellvm_html_a0448108c43f3a226744d0a4c28c989f7"><div class="ttname"><a href="namespacellvm.html#a0448108c43f3a226744d0a4c28c989f7">llvm::makeArrayRef</a></div><div class="ttdeci">ArrayRef&lt; T &gt; makeArrayRef(const T &amp;OneElt)</div><div class="ttdoc">Construct an ArrayRef from a single element. </div><div class="ttdef"><b>Definition:</b> <a href="ArrayRef_8h_source.html#l00266">ArrayRef.h:266</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorImpl_html_a400eaca9881c8dcab97e9f42b1ab1815"><div class="ttname"><a href="classllvm_1_1SmallVectorImpl.html#a400eaca9881c8dcab97e9f42b1ab1815">llvm::SmallVectorImpl::pop_back_val</a></div><div class="ttdeci">T LLVM_ATTRIBUTE_UNUSED_RESULT pop_back_val()</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00430">SmallVector.h:430</a></div></div>
<div class="ttc" id="classllvm_1_1StructType_html"><div class="ttname"><a href="classllvm_1_1StructType.html">llvm::StructType</a></div><div class="ttdef"><b>Definition:</b> <a href="DerivedTypes_8h_source.html#l00187">DerivedTypes.h:187</a></div></div>
<div class="ttc" id="ErrorHandling_8h_html_ace243f5c25697a1107cce46626b3dc94"><div class="ttname"><a href="ErrorHandling_8h.html#ace243f5c25697a1107cce46626b3dc94">llvm_unreachable</a></div><div class="ttdeci">#define llvm_unreachable(msg)</div><div class="ttdef"><b>Definition:</b> <a href="ErrorHandling_8h_source.html#l00103">ErrorHandling.h:103</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_acae189c1d913af7e7f37a8b202070997"><div class="ttname"><a href="classllvm_1_1Type.html#acae189c1d913af7e7f37a8b202070997">llvm::Type::getArrayElementType</a></div><div class="ttdeci">Type * getArrayElementType() const </div><div class="ttdef"><b>Definition:</b> <a href="Type_8h_source.html#l00368">Type.h:368</a></div></div>
<div class="ttc" id="classllvm_1_1Use_html"><div class="ttname"><a href="classllvm_1_1Use.html">llvm::Use</a></div><div class="ttdef"><b>Definition:</b> <a href="Use_8h_source.html#l00060">Use.h:60</a></div></div>
<div class="ttc" id="SROA_8cpp_html_abe75ff888b6a7ee2836aa6c8f33984c1"><div class="ttname"><a href="SROA_8cpp.html#abe75ff888b6a7ee2836aa6c8f33984c1">getTypePartition</a></div><div class="ttdeci">static Type * getTypePartition(const DataLayout &amp;DL, Type *Ty, uint64_t Offset, uint64_t Size)</div><div class="ttdoc">Try to find a partition of the aggregate type passed in for a given offset and size. </div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l02939">SROA.cpp:2939</a></div></div>
<div class="ttc" id="SROA_8cpp_html_ab706500bd4aee346f53362dd30531f7f"><div class="ttname"><a href="SROA_8cpp.html#ab706500bd4aee346f53362dd30531f7f">getAdjustedPtr</a></div><div class="ttdeci">static Value * getAdjustedPtr(IRBuilderTy &amp;IRB, const DataLayout &amp;DL, Value *Ptr, APInt Offset, Type *PointerTy)</div><div class="ttdoc">Compute an adjusted pointer from Ptr by Offset bytes where the resulting pointer has PointerTy...</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01359">SROA.cpp:1359</a></div></div>
<div class="ttc" id="namespacellvm_html_a2f229bc5f942c04056686242fd6e8988"><div class="ttname"><a href="namespacellvm.html#a2f229bc5f942c04056686242fd6e8988">llvm::createSROAPass</a></div><div class="ttdeci">FunctionPass * createSROAPass(bool RequiresDomTree=true)</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l00925">SROA.cpp:925</a></div></div>
<div class="ttc" id="PassSupport_8h_html_a74ce8276b89067e806f67c45a6d92575"><div class="ttname"><a href="PassSupport_8h.html#a74ce8276b89067e806f67c45a6d92575">INITIALIZE_PASS_END</a></div><div class="ttdeci">#define INITIALIZE_PASS_END(passName, arg, name, cfg, analysis)</div><div class="ttdef"><b>Definition:</b> <a href="PassSupport_8h_source.html#l00172">PassSupport.h:172</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorImpl_html"><div class="ttname"><a href="classllvm_1_1SmallVectorImpl.html">llvm::SmallVectorImpl</a></div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l00035">APInt.h:35</a></div></div>
<div class="ttc" id="classllvm_1_1ConstantVector_html_ade9fa017ca3aa82f7694a47090547bc1"><div class="ttname"><a href="classllvm_1_1ConstantVector.html#ade9fa017ca3aa82f7694a47090547bc1">llvm::ConstantVector::get</a></div><div class="ttdeci">static Constant * get(ArrayRef&lt; Constant * &gt; V)</div><div class="ttdef"><b>Definition:</b> <a href="Constants_8cpp_source.html#l00923">Constants.cpp:923</a></div></div>
<div class="ttc" id="classllvm_1_1IRBuilder_html"><div class="ttname"><a href="classllvm_1_1IRBuilder.html">llvm::IRBuilder</a></div><div class="ttdoc">This provides a uniform API for creating instructions and inserting them into a basic block: either a...</div><div class="ttdef"><b>Definition:</b> <a href="IRBuilder_8h_source.html#l00421">IRBuilder.h:421</a></div></div>
<div class="ttc" id="STLExtras_8h_html"><div class="ttname"><a href="STLExtras_8h.html">STLExtras.h</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a7d6146d9a22768498097b2c53cd2234f"><div class="ttname"><a href="SROA_8cpp.html#a7d6146d9a22768498097b2c53cd2234f">convertValue</a></div><div class="ttdeci">static Value * convertValue(const DataLayout &amp;DL, IRBuilderTy &amp;IRB, Value *V, Type *NewTy)</div><div class="ttdoc">Generic routine to convert an SSA value to a value of a different type. </div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01485">SROA.cpp:1485</a></div></div>
<div class="ttc" id="classllvm_1_1PointerIntPair_html_aca7e197fbcd4f17cae48e6f55969ab94"><div class="ttname"><a href="classllvm_1_1PointerIntPair.html#aca7e197fbcd4f17cae48e6f55969ab94">llvm::PointerIntPair::setPointer</a></div><div class="ttdeci">void setPointer(PointerTy PtrVal)</div><div class="ttdef"><b>Definition:</b> <a href="PointerIntPair_8h_source.html#l00079">PointerIntPair.h:79</a></div></div>
<div class="ttc" id="SROA_8cpp_html_af058653d4cef0ff14f04d7c612b1d1c9"><div class="ttname"><a href="SROA_8cpp.html#af058653d4cef0ff14f04d7c612b1d1c9">getNaturalGEPRecursively</a></div><div class="ttdeci">static Value * getNaturalGEPRecursively(IRBuilderTy &amp;IRB, const DataLayout &amp;DL, Value *Ptr, Type *Ty, APInt &amp;Offset, Type *TargetTy, SmallVectorImpl&lt; Value * &gt; &amp;Indices)</div><div class="ttdoc">Recursively compute indices for a natural GEP. </div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01250">SROA.cpp:1250</a></div></div>
<div class="ttc" id="ErrorHandling_8h_html"><div class="ttname"><a href="ErrorHandling_8h.html">ErrorHandling.h</a></div></div>
<div class="ttc" id="classllvm_1_1StructType_html_a8d85840dbf6b7eff52721aafae9df0f6"><div class="ttname"><a href="classllvm_1_1StructType.html#a8d85840dbf6b7eff52721aafae9df0f6">llvm::StructType::element_begin</a></div><div class="ttdeci">element_iterator element_begin() const </div><div class="ttdef"><b>Definition:</b> <a href="DerivedTypes_8h_source.html#l00278">DerivedTypes.h:278</a></div></div>
<div class="ttc" id="namespacefalse_html"><div class="ttname"><a href="namespacefalse.html">false</a></div><div class="ttdef"><b>Definition:</b> <a href="StackSlotColoring_8cpp_source.html#l00126">StackSlotColoring.cpp:126</a></div></div>
<div class="ttc" id="classllvm_1_1AllocaInst_html_a214c60dbb4f1ed467e5a3420db6eefd6"><div class="ttname"><a href="classllvm_1_1AllocaInst.html#a214c60dbb4f1ed467e5a3420db6eefd6">llvm::AllocaInst::getAllocatedType</a></div><div class="ttdeci">Type * getAllocatedType() const </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8cpp_source.html#l00906">Instructions.cpp:906</a></div></div>
<div class="ttc" id="namespacellvm_1_1CallingConv_html_a4f861731fc6dbfdccc05af5968d98974"><div class="ttname"><a href="namespacellvm_1_1CallingConv.html#a4f861731fc6dbfdccc05af5968d98974">llvm::CallingConv::ID</a></div><div class="ttdeci">ID</div><div class="ttdoc">LLVM Calling Convention Representation. </div><div class="ttdef"><b>Definition:</b> <a href="CallingConv_8h_source.html#l00026">CallingConv.h:26</a></div></div>
<div class="ttc" id="classllvm_1_1Instruction_html"><div class="ttname"><a href="classllvm_1_1Instruction.html">llvm::Instruction</a></div><div class="ttdef"><b>Definition:</b> <a href="Instruction_8h_source.html#l00031">Instruction.h:31</a></div></div>
<div class="ttc" id="PtrUseVisitor_8h_html"><div class="ttname"><a href="PtrUseVisitor_8h.html">PtrUseVisitor.h</a></div></div>
<div class="ttc" id="Dominators_8h_html"><div class="ttname"><a href="Dominators_8h.html">Dominators.h</a></div></div>
<div class="ttc" id="classllvm_1_1InstVisitor_html_a6352e72d11377a9c62f24434ae869bf0"><div class="ttname"><a href="classllvm_1_1InstVisitor.html#a6352e72d11377a9c62f24434ae869bf0">llvm::InstVisitor::visit</a></div><div class="ttdeci">void visit(Iterator Start, Iterator End)</div><div class="ttdef"><b>Definition:</b> <a href="InstVisitor_8h_source.html#l00090">InstVisitor.h:90</a></div></div>
<div class="ttc" id="classllvm_1_1PtrUseVisitor_html"><div class="ttname"><a href="classllvm_1_1PtrUseVisitor.html">llvm::PtrUseVisitor</a></div><div class="ttdoc">A base class for visitors over the uses of a pointer value. </div><div class="ttdef"><b>Definition:</b> <a href="PtrUseVisitor_8h_source.html#l00193">PtrUseVisitor.h:193</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_af348d5ea83429d08ba891ca3dd0e92b2"><div class="ttname"><a href="classllvm_1_1Type.html#af348d5ea83429d08ba891ca3dd0e92b2">llvm::Type::getContext</a></div><div class="ttdeci">LLVMContext &amp; getContext() const </div><div class="ttdoc">getContext - Return the LLVMContext in which this type was uniqued. </div><div class="ttdef"><b>Definition:</b> <a href="Type_8h_source.html#l00128">Type.h:128</a></div></div>
<div class="ttc" id="Operator_8h_html"><div class="ttname"><a href="Operator_8h.html">Operator.h</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorBase_html_a8a8df4d85555c7954a95f86080cd3b64"><div class="ttname"><a href="classllvm_1_1SmallVectorBase.html#a8a8df4d85555c7954a95f86080cd3b64">llvm::SmallVectorBase::empty</a></div><div class="ttdeci">bool LLVM_ATTRIBUTE_UNUSED_RESULT empty() const </div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00056">SmallVector.h:56</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a908c20a486274e383f5261012a7c36da"><div class="ttname"><a href="SROA_8cpp.html#a908c20a486274e383f5261012a7c36da">isSafeSelectToSpeculate</a></div><div class="ttdeci">static bool isSafeSelectToSpeculate(SelectInst &amp;SI, const DataLayout *DL=0)</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01124">SROA.cpp:1124</a></div></div>
<div class="ttc" id="DebugInfo_8h_html"><div class="ttname"><a href="DebugInfo_8h.html">DebugInfo.h</a></div></div>
<div class="ttc" id="classllvm_1_1ArrayType_html"><div class="ttname"><a href="classllvm_1_1ArrayType.html">llvm::ArrayType</a></div><div class="ttdef"><b>Definition:</b> <a href="DerivedTypes_8h_source.html#l00332">DerivedTypes.h:332</a></div></div>
<div class="ttc" id="classllvm_1_1ConstantInt_html_a024bb83a7f01e7661ea72ff7dcc460f5"><div class="ttname"><a href="classllvm_1_1ConstantInt.html#a024bb83a7f01e7661ea72ff7dcc460f5">llvm::ConstantInt::getLimitedValue</a></div><div class="ttdeci">uint64_t getLimitedValue(uint64_t Limit=~0ULL) const </div><div class="ttdoc">Get the constant&amp;#39;s value with a saturation limit. </div><div class="ttdef"><b>Definition:</b> <a href="Constants_8h_source.html#l00218">Constants.h:218</a></div></div>
<div class="ttc" id="classllvm_1_1BitCastInst_html"><div class="ttname"><a href="classllvm_1_1BitCastInst.html">llvm::BitCastInst</a></div><div class="ttdoc">This class represents a no-op cast from one type to another. </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l03587">Instructions.h:3587</a></div></div>
<div class="ttc" id="classllvm_1_1ArrayRef_html"><div class="ttname"><a href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a></div><div class="ttdef"><b>Definition:</b> <a href="ArrayRef_8h_source.html#l00031">ArrayRef.h:31</a></div></div>
<div class="ttc" id="classllvm_1_1ConstantFolder_html"><div class="ttname"><a href="classllvm_1_1ConstantFolder.html">llvm::ConstantFolder</a></div><div class="ttdoc">ConstantFolder - Create constants with minimum, target independent, folding. </div><div class="ttdef"><b>Definition:</b> <a href="ConstantFolder_8h_source.html#l00026">ConstantFolder.h:26</a></div></div>
<div class="ttc" id="classllvm_1_1IntegerType_html_ab24bc943998d904e8406af9fa07ca645a1ccefdf8a7414a6829f888e5071e0379"><div class="ttname"><a href="classllvm_1_1IntegerType.html#ab24bc943998d904e8406af9fa07ca645a1ccefdf8a7414a6829f888e5071e0379">llvm::IntegerType::MAX_INT_BITS</a></div><div class="ttdef"><b>Definition:</b> <a href="DerivedTypes_8h_source.html#l00048">DerivedTypes.h:48</a></div></div>
<div class="ttc" id="classllvm_1_1StoreInst_html"><div class="ttname"><a href="classllvm_1_1StoreInst.html">llvm::StoreInst</a></div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l00255">Instructions.h:255</a></div></div>
<div class="ttc" id="classllvm_1_1Value_html_a3ab5fc45117b450e8bb04e564cb6e5f2"><div class="ttname"><a href="classllvm_1_1Value.html#a3ab5fc45117b450e8bb04e564cb6e5f2">llvm::Value::replaceAllUsesWith</a></div><div class="ttdeci">void replaceAllUsesWith(Value *V)</div><div class="ttdef"><b>Definition:</b> <a href="Value_8cpp_source.html#l00303">Value.cpp:303</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_a9aae7c60b468bcf6db982dc76e6c703a"><div class="ttname"><a href="classllvm_1_1Type.html#a9aae7c60b468bcf6db982dc76e6c703a">llvm::Type::isArrayTy</a></div><div class="ttdeci">bool isArrayTy() const </div><div class="ttdef"><b>Definition:</b> <a href="Type_8h_source.html#l00216">Type.h:216</a></div></div>
<div class="ttc" id="classllvm_1_1ConstantExpr_html_ab2767c28bc3ded2d683a93f0ce1ed502"><div class="ttname"><a href="classllvm_1_1ConstantExpr.html#ab2767c28bc3ded2d683a93f0ce1ed502">llvm::ConstantExpr::getUDiv</a></div><div class="ttdeci">static Constant * getUDiv(Constant *C1, Constant *C2, bool isExact=false)</div><div class="ttdef"><b>Definition:</b> <a href="Constants_8cpp_source.html#l02073">Constants.cpp:2073</a></div></div>
<div class="ttc" id="classllvm_1_1VectorType_html_a580510fa692dccfb26d0e967d8f164e7"><div class="ttname"><a href="classllvm_1_1VectorType.html#a580510fa692dccfb26d0e967d8f164e7">llvm::VectorType::getNumElements</a></div><div class="ttdeci">unsigned getNumElements() const </div><div class="ttdoc">Return the number of elements in the Vector type. </div><div class="ttdef"><b>Definition:</b> <a href="DerivedTypes_8h_source.html#l00408">DerivedTypes.h:408</a></div></div>
<div class="ttc" id="MathExtras_8h_html"><div class="ttname"><a href="MathExtras_8h.html">MathExtras.h</a></div></div>
<div class="ttc" id="classllvm_1_1InstVisitor_html_acaad755824bda1ce0066749c8655d3df"><div class="ttname"><a href="classllvm_1_1InstVisitor.html#acaad755824bda1ce0066749c8655d3df">llvm::InstVisitor::visitMemTransferInst</a></div><div class="ttdeci">RetTy visitMemTransferInst(MemTransferInst &amp;I)</div><div class="ttdef"><b>Definition:</b> <a href="InstVisitor_8h_source.html#l00211">InstVisitor.h:211</a></div></div>
<div class="ttc" id="SROA_8cpp_html_ab168540e52abb7850fa69ad422a55a31"><div class="ttname"><a href="SROA_8cpp.html#ab168540e52abb7850fa69ad422a55a31">buildGEP</a></div><div class="ttdeci">static Value * buildGEP(IRBuilderTy &amp;IRB, Value *BasePtr, SmallVectorImpl&lt; Value * &gt; &amp;Indices)</div><div class="ttdoc">Build a GEP out of a base pointer and indices. </div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01190">SROA.cpp:1190</a></div></div>
<div class="ttc" id="classllvm_1_1DominatorTree_html"><div class="ttname"><a href="classllvm_1_1DominatorTree.html">llvm::DominatorTree</a></div><div class="ttdef"><b>Definition:</b> <a href="Dominators_8h_source.html#l00740">Dominators.h:740</a></div></div>
<div class="ttc" id="classllvm_1_1SequentialType_html_a39f2c3a62f293faf11ac28b15bc53359"><div class="ttname"><a href="classllvm_1_1SequentialType.html#a39f2c3a62f293faf11ac28b15bc53359">llvm::SequentialType::getElementType</a></div><div class="ttdeci">Type * getElementType() const </div><div class="ttdef"><b>Definition:</b> <a href="DerivedTypes_8h_source.html#l00319">DerivedTypes.h:319</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a2fb1c078833c17e4c9529b0cf924385c"><div class="ttname"><a href="SROA_8cpp.html#a2fb1c078833c17e4c9529b0cf924385c">canConvertValue</a></div><div class="ttdeci">static bool canConvertValue(const DataLayout &amp;DL, Type *OldTy, Type *NewTy)</div><div class="ttdoc">Test whether we can convert a value from the old to the new type. </div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01452">SROA.cpp:1452</a></div></div>
<div class="ttc" id="classllvm_1_1PointerIntPair_html_a725b89e7964f33d7dfeb38dfe00a45f8"><div class="ttname"><a href="classllvm_1_1PointerIntPair.html#a725b89e7964f33d7dfeb38dfe00a45f8">llvm::PointerIntPair::setInt</a></div><div class="ttdeci">void setInt(IntType IntVal)</div><div class="ttdef"><b>Definition:</b> <a href="PointerIntPair_8h_source.html#l00088">PointerIntPair.h:88</a></div></div>
<div class="ttc" id="classllvm_1_1PointerType_html"><div class="ttname"><a href="classllvm_1_1PointerType.html">llvm::PointerType</a></div><div class="ttdef"><b>Definition:</b> <a href="DerivedTypes_8h_source.html#l00425">DerivedTypes.h:425</a></div></div>
<div class="ttc" id="classllvm_1_1PHINode_html_aa45f6c0433576e3858a6209a43750ad4"><div class="ttname"><a href="classllvm_1_1PHINode.html#aa45f6c0433576e3858a6209a43750ad4">llvm::PHINode::getNumIncomingValues</a></div><div class="ttdeci">unsigned getNumIncomingValues() const </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l02055">Instructions.h:2055</a></div></div>
<div class="ttc" id="classllvm_1_1StructLayout_html_ae10c4483372a357a0d3411b3d64be10c"><div class="ttname"><a href="classllvm_1_1StructLayout.html#ae10c4483372a357a0d3411b3d64be10c">llvm::StructLayout::getElementOffset</a></div><div class="ttdeci">uint64_t getElementOffset(unsigned Idx) const </div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8h_source.html#l00442">DataLayout.h:442</a></div></div>
<div class="ttc" id="classllvm_1_1TerminatorInst_html_a4c26d3b92af99a6c8defd89a2d39ca32"><div class="ttname"><a href="classllvm_1_1TerminatorInst.html#a4c26d3b92af99a6c8defd89a2d39ca32">llvm::TerminatorInst::getNumSuccessors</a></div><div class="ttdeci">unsigned getNumSuccessors() const </div><div class="ttdef"><b>Definition:</b> <a href="InstrTypes_8h_source.html#l00059">InstrTypes.h:59</a></div></div>
<div class="ttc" id="classllvm_1_1GetElementPtrInst_html"><div class="ttname"><a href="classllvm_1_1GetElementPtrInst.html">llvm::GetElementPtrInst</a></div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l00709">Instructions.h:709</a></div></div>
<div class="ttc" id="README__ALTIVEC_8txt_html_a9aacd9146afe44bf656cd664e2a88c8c"><div class="ttname"><a href="README__ALTIVEC_8txt.html#a9aacd9146afe44bf656cd664e2a88c8c">C</a></div><div class="ttdeci">(vector float) vec_cmpeq(*A,*B) C</div><div class="ttdef"><b>Definition:</b> <a href="README__ALTIVEC_8txt_source.html#l00091">README_ALTIVEC.txt:91</a></div></div>
<div class="ttc" id="CommandLine_8h_html"><div class="ttname"><a href="CommandLine_8h.html">CommandLine.h</a></div></div>
<div class="ttc" id="namespacellvm_1_1cl_html_a10a041239ae1870cfcc064bfaa79fb65"><div class="ttname"><a href="namespacellvm_1_1cl.html#a10a041239ae1870cfcc064bfaa79fb65">llvm::cl::init</a></div><div class="ttdeci">initializer&lt; Ty &gt; init(const Ty &amp;Val)</div><div class="ttdef"><b>Definition:</b> <a href="CommandLine_8h_source.html#l00314">CommandLine.h:314</a></div></div>
<div class="ttc" id="classllvm_1_1sys_1_1path_1_1const__iterator_html_a8a503d1cbee10d1b8c8f5ac2a03b90df"><div class="ttname"><a href="classllvm_1_1sys_1_1path_1_1const__iterator.html#a8a503d1cbee10d1b8c8f5ac2a03b90df">llvm::sys::path::const_iterator::end</a></div><div class="ttdeci">friend const_iterator end(StringRef path)</div><div class="ttdoc">Get end iterator over path. </div><div class="ttdef"><b>Definition:</b> <a href="Path_8cpp_source.html#l00181">Path.cpp:181</a></div></div>
<div class="ttc" id="namespacellvm_html_a03503773241005f01b090b9862aad304"><div class="ttname"><a href="namespacellvm.html#a03503773241005f01b090b9862aad304">llvm::dump</a></div><div class="ttdeci">void dump(const SparseBitVector&lt; ElementSize &gt; &amp;LHS, raw_ostream &amp;out)</div><div class="ttdef"><b>Definition:</b> <a href="SparseBitVector_8h_source.html#l00882">SparseBitVector.h:882</a></div></div>
<div class="ttc" id="classllvm_1_1TerminatorInst_html"><div class="ttname"><a href="classllvm_1_1TerminatorInst.html">llvm::TerminatorInst</a></div><div class="ttdef"><b>Definition:</b> <a href="InstrTypes_8h_source.html#l00035">InstrTypes.h:35</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorTemplateCommon_html_acd9e771a3296c6b24146955754620557"><div class="ttname"><a href="classllvm_1_1SmallVectorTemplateCommon.html#acd9e771a3296c6b24146955754620557">llvm::SmallVectorTemplateCommon&lt; T &gt;::back</a></div><div class="ttdeci">reference back()</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00157">SmallVector.h:157</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorImpl_html_aac0ea55010b7b1a301e65a0baea057aa"><div class="ttname"><a href="classllvm_1_1SmallVectorImpl.html#aac0ea55010b7b1a301e65a0baea057aa">llvm::SmallVectorImpl::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00396">SmallVector.h:396</a></div></div>
<div class="ttc" id="classllvm_1_1BasicBlock_html"><div class="ttname"><a href="classllvm_1_1BasicBlock.html">llvm::BasicBlock</a></div><div class="ttdoc">LLVM Basic Block Representation. </div><div class="ttdef"><b>Definition:</b> <a href="BasicBlock_8h_source.html#l00072">BasicBlock.h:72</a></div></div>
<div class="ttc" id="classllvm_1_1PointerIntPair_html"><div class="ttname"><a href="classllvm_1_1PointerIntPair.html">llvm::PointerIntPair&lt; Use *, 1, bool &gt;</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html"><div class="ttname"><a href="classllvm_1_1Type.html">llvm::Type</a></div><div class="ttdef"><b>Definition:</b> <a href="Type_8h_source.html#l00044">Type.h:44</a></div></div>
<div class="ttc" id="classllvm_1_1LLVMContext_html"><div class="ttname"><a href="classllvm_1_1LLVMContext.html">llvm::LLVMContext</a></div><div class="ttdef"><b>Definition:</b> <a href="LLVMContext_8h_source.html#l00037">LLVMContext.h:37</a></div></div>
<div class="ttc" id="classllvm_1_1DataLayout_html_a328b37dd0e404674678018ac2f2e38af"><div class="ttname"><a href="classllvm_1_1DataLayout.html#a328b37dd0e404674678018ac2f2e38af">llvm::DataLayout::getTypeStoreSizeInBits</a></div><div class="ttdeci">uint64_t getTypeStoreSizeInBits(Type *Ty) const </div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8h_source.html#l00318">DataLayout.h:318</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_a6f725580f7834e2ca90762965866dad4"><div class="ttname"><a href="classllvm_1_1Type.html#a6f725580f7834e2ca90762965866dad4">llvm::Type::isVectorTy</a></div><div class="ttdeci">bool isVectorTy() const </div><div class="ttdef"><b>Definition:</b> <a href="Type_8h_source.html#l00229">Type.h:229</a></div></div>
<div class="ttc" id="classllvm_1_1StructType_html_a2f54639fcb5162f6f51192eb1697d2ad"><div class="ttname"><a href="classllvm_1_1StructType.html#a2f54639fcb5162f6f51192eb1697d2ad">llvm::StructType::getElementType</a></div><div class="ttdeci">Type * getElementType(unsigned N) const </div><div class="ttdef"><b>Definition:</b> <a href="DerivedTypes_8h_source.html#l00287">DerivedTypes.h:287</a></div></div>
<div class="ttc" id="Compiler_8h_html"><div class="ttname"><a href="Compiler_8h.html">Compiler.h</a></div></div>
<div class="ttc" id="classllvm_1_1Constant_html"><div class="ttname"><a href="classllvm_1_1Constant.html">llvm::Constant</a></div><div class="ttdoc">LLVM Constant Representation. </div><div class="ttdef"><b>Definition:</b> <a href="Constant_8h_source.html#l00041">Constant.h:41</a></div></div>
<div class="ttc" id="classllvm_1_1AllocaInst_html_a597c918a615f26a0cea7adb84f06fc3f"><div class="ttname"><a href="classllvm_1_1AllocaInst.html#a597c918a615f26a0cea7adb84f06fc3f">llvm::AllocaInst::getType</a></div><div class="ttdeci">PointerType * getType() const </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l00091">Instructions.h:91</a></div></div>
<div class="ttc" id="classllvm_1_1SelectInst_html_ad285a69e32ddeee367fed93b5f392801"><div class="ttname"><a href="classllvm_1_1SelectInst.html#ad285a69e32ddeee367fed93b5f392801">llvm::SelectInst::getCondition</a></div><div class="ttdeci">const Value * getCondition() const </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l01466">Instructions.h:1466</a></div></div>
<div class="ttc" id="Constants_8h_html"><div class="ttname"><a href="Constants_8h.html">Constants.h</a></div></div>
<div class="ttc" id="namespacellvm_html_abe283966f269761ee387642061c4451e"><div class="ttname"><a href="namespacellvm.html#abe283966f269761ee387642061c4451e">llvm::isInstructionTriviallyDead</a></div><div class="ttdeci">bool isInstructionTriviallyDead(Instruction *I, const TargetLibraryInfo *TLI=0)</div><div class="ttdef"><b>Definition:</b> <a href="Local_8cpp_source.html#l00266">Local.cpp:266</a></div></div>
<div class="ttc" id="classllvm_1_1AllocaInst_html_ad441932c20e5b9ba36c8c72a6c7f5ec3"><div class="ttname"><a href="classllvm_1_1AllocaInst.html#ad441932c20e5b9ba36c8c72a6c7f5ec3">llvm::AllocaInst::getAlignment</a></div><div class="ttdeci">unsigned getAlignment() const </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l00103">Instructions.h:103</a></div></div>
<div class="ttc" id="classllvm_1_1MemIntrinsic_html_a3ec0c47a5532e568d54c8d452dfb58df"><div class="ttname"><a href="classllvm_1_1MemIntrinsic.html#a3ec0c47a5532e568d54c8d452dfb58df">llvm::MemIntrinsic::getRawDest</a></div><div class="ttdeci">Value * getRawDest() const </div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00120">IntrinsicInst.h:120</a></div></div>
<div class="ttc" id="classllvm_1_1Value_html_a30fec2a6a53ed66b12318765c8feac13"><div class="ttname"><a href="classllvm_1_1Value.html#a30fec2a6a53ed66b12318765c8feac13">llvm::Value::stripInBoundsOffsets</a></div><div class="ttdeci">Value * stripInBoundsOffsets()</div><div class="ttdoc">Strips off unneeded pointer casts and any in-bounds offsets from the specified value, returning the original pointer value. </div><div class="ttdef"><b>Definition:</b> <a href="Value_8cpp_source.html#l00433">Value.cpp:433</a></div></div>
<div class="ttc" id="InstVisitor_8h_html"><div class="ttname"><a href="InstVisitor_8h.html">InstVisitor.h</a></div></div>
<div class="ttc" id="classllvm_1_1DIBuilder_html_a827de4664f26cd97746786b159fa997f"><div class="ttname"><a href="classllvm_1_1DIBuilder.html#a827de4664f26cd97746786b159fa997f">llvm::DIBuilder::insertDbgValueIntrinsic</a></div><div class="ttdeci">Instruction * insertDbgValueIntrinsic(llvm::Value *Val, uint64_t Offset, DIVariable VarInfo, BasicBlock *InsertAtEnd)</div><div class="ttdoc">insertDbgValueIntrinsic - Insert a new llvm.dbg.value intrinsic call. </div><div class="ttdef"><b>Definition:</b> <a href="DIBuilder_8cpp_source.html#l01251">DIBuilder.cpp:1251</a></div></div>
<div class="ttc" id="classllvm_1_1Instruction_html_aab8e16a35183ce39aad394714087bcff"><div class="ttname"><a href="classllvm_1_1Instruction.html#aab8e16a35183ce39aad394714087bcff">llvm::Instruction::getDebugLoc</a></div><div class="ttdeci">const DebugLoc &amp; getDebugLoc() const </div><div class="ttdoc">getDebugLoc - Return the debug location for this node as a DebugLoc. </div><div class="ttdef"><b>Definition:</b> <a href="Instruction_8h_source.html#l00178">Instruction.h:178</a></div></div>
<div class="ttc" id="classllvm_1_1AnalysisUsage_html"><div class="ttname"><a href="classllvm_1_1AnalysisUsage.html">llvm::AnalysisUsage</a></div><div class="ttdef"><b>Definition:</b> <a href="PassAnalysisSupport_8h_source.html#l00037">PassAnalysisSupport.h:37</a></div></div>
<div class="ttc" id="classllvm_1_1User_html_af41f58e730804d10b91fcff39b035f74"><div class="ttname"><a href="classllvm_1_1User.html#af41f58e730804d10b91fcff39b035f74">llvm::User::op_end</a></div><div class="ttdeci">op_iterator op_end()</div><div class="ttdef"><b>Definition:</b> <a href="User_8h_source.html#l00118">User.h:118</a></div></div>
<div class="ttc" id="classllvm_1_1PHINode_html_a4c25b6c00c4867281779c81ab64d2081"><div class="ttname"><a href="classllvm_1_1PHINode.html#a4c25b6c00c4867281779c81ab64d2081">llvm::PHINode::getIncomingBlock</a></div><div class="ttdeci">BasicBlock * getIncomingBlock(unsigned i) const </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l02074">Instructions.h:2074</a></div></div>
<div class="ttc" id="namespacellvm_html_aa1704159f75e6eacd595962ea6d93ffe"><div class="ttname"><a href="namespacellvm.html#aa1704159f75e6eacd595962ea6d93ffe">llvm::next</a></div><div class="ttdeci">ItTy next(ItTy it, Dist n)</div><div class="ttdef"><b>Definition:</b> <a href="STLExtras_8h_source.html#l00154">STLExtras.h:154</a></div></div>
<div class="ttc" id="Compiler_8h_html_acc1c483f4b4ee2f17bb6643a3b353609"><div class="ttname"><a href="Compiler_8h.html#acc1c483f4b4ee2f17bb6643a3b353609">LLVM_ATTRIBUTE_UNUSED</a></div><div class="ttdeci">#define LLVM_ATTRIBUTE_UNUSED</div><div class="ttdef"><b>Definition:</b> <a href="Compiler_8h_source.html#l00199">Compiler.h:199</a></div></div>
<div class="ttc" id="classllvm_1_1APInt_html_ad081689e23a8f5dea78dedd623d6a8f8"><div class="ttname"><a href="classllvm_1_1APInt.html#ad081689e23a8f5dea78dedd623d6a8f8">llvm::APInt::getBitWidth</a></div><div class="ttdeci">unsigned getBitWidth() const </div><div class="ttdoc">Return the number of bits in the APInt. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l01252">APInt.h:1252</a></div></div>
<div class="ttc" id="classllvm_1_1ArrayRef_html_a836367b39ed630bf14db99923c22740e"><div class="ttname"><a href="classllvm_1_1ArrayRef.html#a836367b39ed630bf14db99923c22740e">llvm::ArrayRef::begin</a></div><div class="ttdeci">iterator begin() const </div><div class="ttdef"><b>Definition:</b> <a href="ArrayRef_8h_source.html#l00097">ArrayRef.h:97</a></div></div>
<div class="ttc" id="classllvm_1_1APInt_html_a0229ff3a1d7432810a86c8efab115c33"><div class="ttname"><a href="classllvm_1_1APInt.html#a0229ff3a1d7432810a86c8efab115c33">llvm::APInt::uge</a></div><div class="ttdeci">bool uge(const APInt &amp;RHS) const </div><div class="ttdoc">Unsigned greater or equal comparison. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l01116">APInt.h:1116</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a6990f15b9f29df6e8497b3e53875ccab"><div class="ttname"><a href="SROA_8cpp.html#a6990f15b9f29df6e8497b3e53875ccab">sroa</a></div><div class="ttdeci">sroa</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l00932">SROA.cpp:932</a></div></div>
<div class="ttc" id="classllvm_1_1FunctionPass_html"><div class="ttname"><a href="classllvm_1_1FunctionPass.html">llvm::FunctionPass</a></div><div class="ttdef"><b>Definition:</b> <a href="Pass_8h_source.html#l00293">Pass.h:293</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a158e8bdebd7e27fc1fd86613b56f8b9b"><div class="ttname"><a href="SROA_8cpp.html#a158e8bdebd7e27fc1fd86613b56f8b9b">getNaturalGEPWithType</a></div><div class="ttdeci">static Value * getNaturalGEPWithType(IRBuilderTy &amp;IRB, const DataLayout &amp;DL, Value *BasePtr, Type *Ty, Type *TargetTy, SmallVectorImpl&lt; Value * &gt; &amp;Indices)</div><div class="ttdoc">Get a natural GEP off of the BasePtr walking through Ty toward TargetTy without changing the offset o...</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01212">SROA.cpp:1212</a></div></div>
<div class="ttc" id="classllvm_1_1APInt_html_a482ad0f63ec145fdba2497e2298a5aa1"><div class="ttname"><a href="classllvm_1_1APInt.html#a482ad0f63ec145fdba2497e2298a5aa1">llvm::APInt::sdiv</a></div><div class="ttdeci">APInt LLVM_ATTRIBUTE_UNUSED_RESULT sdiv(const APInt &amp;RHS) const </div><div class="ttdoc">Signed division function for APInt. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8cpp_source.html#l01879">APInt.cpp:1879</a></div></div>
<div class="ttc" id="classllvm_1_1User_html_a997ff6a1758bf732b9b263fc61011644"><div class="ttname"><a href="classllvm_1_1User.html#a997ff6a1758bf732b9b263fc61011644">llvm::User::getOperand</a></div><div class="ttdeci">Value * getOperand(unsigned i) const </div><div class="ttdef"><b>Definition:</b> <a href="User_8h_source.html#l00088">User.h:88</a></div></div>
<div class="ttc" id="classllvm_1_1LoadInst_html_ad47eefa1d094f60494b6b927061ca001"><div class="ttname"><a href="classllvm_1_1LoadInst.html#ad47eefa1d094f60494b6b927061ca001">llvm::LoadInst::getPointerOperand</a></div><div class="ttdeci">Value * getPointerOperand()</div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l00223">Instructions.h:223</a></div></div>
<div class="ttc" id="classllvm_1_1DIVariable_html"><div class="ttname"><a href="classllvm_1_1DIVariable.html">llvm::DIVariable</a></div><div class="ttdef"><b>Definition:</b> <a href="DebugInfo_8h_source.html#l00605">DebugInfo.h:605</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a581dd5bca5410ba43e8cf06d949fa7f2"><div class="ttname"><a href="SROA_8cpp.html#a581dd5bca5410ba43e8cf06d949fa7f2">isVectorPromotionViable</a></div><div class="ttdeci">static bool isVectorPromotionViable(const DataLayout &amp;DL, Type *AllocaTy, AllocaSlices &amp;S, uint64_t SliceBeginOffset, uint64_t SliceEndOffset, AllocaSlices::const_iterator I, AllocaSlices::const_iterator E, ArrayRef&lt; AllocaSlices::iterator &gt; SplitUses)</div><div class="ttdoc">Test whether the given alloca partitioning and range of slices can be promoted to a vector...</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01614">SROA.cpp:1614</a></div></div>
<div class="ttc" id="classllvm_1_1LLVMContext_html_a0869c4dfee48696ce863fcd367eba52da66682b7e33233c8e51196bbf274726a2"><div class="ttname"><a href="classllvm_1_1LLVMContext.html#a0869c4dfee48696ce863fcd367eba52da66682b7e33233c8e51196bbf274726a2">llvm::LLVMContext::MD_tbaa</a></div><div class="ttdef"><b>Definition:</b> <a href="LLVMContext_8h_source.html#l00047">LLVMContext.h:47</a></div></div>
<div class="ttc" id="classllvm_1_1IntegerType_html"><div class="ttname"><a href="classllvm_1_1IntegerType.html">llvm::IntegerType</a></div><div class="ttdoc">Integer representation type. </div><div class="ttdef"><b>Definition:</b> <a href="DerivedTypes_8h_source.html#l00037">DerivedTypes.h:37</a></div></div>
<div class="ttc" id="classllvm_1_1InstVisitor_html_af8829e5fbad4f9606b5b6c0b100493c5"><div class="ttname"><a href="classllvm_1_1InstVisitor.html#af8829e5fbad4f9606b5b6c0b100493c5">llvm::InstVisitor::visitLoadInst</a></div><div class="ttdeci">RetTy visitLoadInst(LoadInst &amp;I)</div><div class="ttdef"><b>Definition:</b> <a href="InstVisitor_8h_source.html#l00175">InstVisitor.h:175</a></div></div>
<div class="ttc" id="classllvm_1_1SmallPtrSetImpl_html_a095445850ef2c64e96b4c05120cecf66"><div class="ttname"><a href="classllvm_1_1SmallPtrSetImpl.html#a095445850ef2c64e96b4c05120cecf66">llvm::SmallPtrSetImpl::empty</a></div><div class="ttdeci">bool LLVM_ATTRIBUTE_UNUSED_RESULT empty() const </div><div class="ttdef"><b>Definition:</b> <a href="SmallPtrSet_8h_source.html#l00074">SmallPtrSet.h:74</a></div></div>
<div class="ttc" id="classllvm_1_1LoadInst_html_a218ef27c964707a907f12db0f9b002ba"><div class="ttname"><a href="classllvm_1_1LoadInst.html#a218ef27c964707a907f12db0f9b002ba">llvm::LoadInst::setAlignment</a></div><div class="ttdeci">void setAlignment(unsigned Align)</div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8cpp_source.html#l01065">Instructions.cpp:1065</a></div></div>
<div class="ttc" id="SROA_8cpp_html_afe50201d4e405f7bb74806c62e850140"><div class="ttname"><a href="SROA_8cpp.html#afe50201d4e405f7bb74806c62e850140">isVectorPromotionViableForSlice</a></div><div class="ttdeci">static bool isVectorPromotionViableForSlice(const DataLayout &amp;DL, AllocaSlices &amp;S, uint64_t SliceBeginOffset, uint64_t SliceEndOffset, VectorType *Ty, uint64_t ElementSize, AllocaSlices::const_iterator I)</div><div class="ttdoc">Test whether the given slice use can be promoted to a vector. </div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01539">SROA.cpp:1539</a></div></div>
<div class="ttc" id="classllvm_1_1Constant_html_a4d51384de6e1798bb6aa875aebeea9f0"><div class="ttname"><a href="classllvm_1_1Constant.html#a4d51384de6e1798bb6aa875aebeea9f0">llvm::Constant::getAllOnesValue</a></div><div class="ttdeci">static Constant * getAllOnesValue(Type *Ty)</div><div class="ttdoc">Get the all ones value. </div><div class="ttdef"><b>Definition:</b> <a href="Constants_8cpp_source.html#l00163">Constants.cpp:163</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_a2eba483f5cc876e824aa6c085736086b"><div class="ttname"><a href="classllvm_1_1Type.html#a2eba483f5cc876e824aa6c085736086b">llvm::Type::isPointerTy</a></div><div class="ttdeci">bool isPointerTy() const </div><div class="ttdef"><b>Definition:</b> <a href="Type_8h_source.html#l00220">Type.h:220</a></div></div>
<div class="ttc" id="classllvm_1_1UndefValue_html_a4ae5ff22b700a42bcc5d889233721335"><div class="ttname"><a href="classllvm_1_1UndefValue.html#a4ae5ff22b700a42bcc5d889233721335">llvm::UndefValue::get</a></div><div class="ttdeci">static UndefValue * get(Type *T)</div><div class="ttdef"><b>Definition:</b> <a href="Constants_8cpp_source.html#l01334">Constants.cpp:1334</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorImpl_html_a18c110c35e9133222a37b28d30f8a90f"><div class="ttname"><a href="classllvm_1_1SmallVectorImpl.html#a18c110c35e9133222a37b28d30f8a90f">llvm::SmallVectorImpl::erase</a></div><div class="ttdeci">iterator erase(iterator I)</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00478">SmallVector.h:478</a></div></div>
<div class="ttc" id="classllvm_1_1PointerIntPair_html_ae8f9fce2cb409f89c47535165f214a23"><div class="ttname"><a href="classllvm_1_1PointerIntPair.html#ae8f9fce2cb409f89c47535165f214a23">llvm::PointerIntPair::getInt</a></div><div class="ttdeci">IntType getInt() const </div><div class="ttdef"><b>Definition:</b> <a href="PointerIntPair_8h_source.html#l00075">PointerIntPair.h:75</a></div></div>
<div class="ttc" id="classllvm_1_1Value_html_af85a4828b6b5a8de7fc0a55cc0e5b52f"><div class="ttname"><a href="classllvm_1_1Value.html#af85a4828b6b5a8de7fc0a55cc0e5b52f">llvm::Value::getContext</a></div><div class="ttdeci">LLVMContext &amp; getContext() const </div><div class="ttdoc">All values hold a context through their type. </div><div class="ttdef"><b>Definition:</b> <a href="Value_8cpp_source.html#l00517">Value.cpp:517</a></div></div>
<div class="ttc" id="classT_html"><div class="ttname"><a href="classT.html">T</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a65e014ae237cfe6ed7bc2e25f91ecbe0"><div class="ttname"><a href="SROA_8cpp.html#a65e014ae237cfe6ed7bc2e25f91ecbe0">isIntegerWideningViableForSlice</a></div><div class="ttdeci">static bool isIntegerWideningViableForSlice(const DataLayout &amp;DL, Type *AllocaTy, uint64_t AllocBeginOffset, uint64_t Size, AllocaSlices &amp;S, AllocaSlices::const_iterator I, bool &amp;WholeAllocaOp)</div><div class="ttdoc">Test whether a slice of an alloca is valid for integer widening. </div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01652">SROA.cpp:1652</a></div></div>
<div class="ttc" id="classllvm_1_1DbgValueInst_html_adae1fa6a78df1a034751ba599b71ed68"><div class="ttname"><a href="classllvm_1_1DbgValueInst.html#adae1fa6a78df1a034751ba599b71ed68">llvm::DbgValueInst::getVariable</a></div><div class="ttdeci">MDNode * getVariable() const </div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00105">IntrinsicInst.h:105</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_ab6cc070c37c59589af100aab6f48ef4f"><div class="ttname"><a href="classllvm_1_1Type.html#ab6cc070c37c59589af100aab6f48ef4f">llvm::Type::getPointerTo</a></div><div class="ttdeci">PointerType * getPointerTo(unsigned AddrSpace=0)</div><div class="ttdef"><b>Definition:</b> <a href="Type_8cpp_source.html#l00756">Type.cpp:756</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_a7fe9ccd4893f4e2caa826126c09545ea"><div class="ttname"><a href="classllvm_1_1Type.html#a7fe9ccd4893f4e2caa826126c09545ea">llvm::Type::getInt8PtrTy</a></div><div class="ttdeci">static PointerType * getInt8PtrTy(LLVMContext &amp;C, unsigned AS=0)</div><div class="ttdef"><b>Definition:</b> <a href="Type_8cpp_source.html#l00284">Type.cpp:284</a></div></div>
<div class="ttc" id="classllvm_1_1SelectInst_html_a67bf091383cd61e1225445e78b61d9f9"><div class="ttname"><a href="classllvm_1_1SelectInst.html#a67bf091383cd61e1225445e78b61d9f9">llvm::SelectInst::getTrueValue</a></div><div class="ttdeci">const Value * getTrueValue() const </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l01467">Instructions.h:1467</a></div></div>
<div class="ttc" id="classllvm_1_1Instruction_html_a9247a212ea89acc9573fa7e7f557eaba"><div class="ttname"><a href="classllvm_1_1Instruction.html#a9247a212ea89acc9573fa7e7f557eaba">llvm::Instruction::setMetadata</a></div><div class="ttdeci">void setMetadata(unsigned KindID, MDNode *Node)</div><div class="ttdef"><b>Definition:</b> <a href="Metadata_8cpp_source.html#l00589">Metadata.cpp:589</a></div></div>
<div class="ttc" id="SROA_8cpp_html_ac102ff32dace1cf8e8e6f9c9ec4d159c"><div class="ttname"><a href="SROA_8cpp.html#ac102ff32dace1cf8e8e6f9c9ec4d159c">stripAggregateTypeWrapping</a></div><div class="ttdeci">static Type * stripAggregateTypeWrapping(const DataLayout &amp;DL, Type *Ty)</div><div class="ttdoc">Strip aggregate type wrapping. </div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l02901">SROA.cpp:2901</a></div></div>
<div class="ttc" id="classllvm_1_1APInt_html_ad3d358e03c6228af2d19b2e67028886e"><div class="ttname"><a href="classllvm_1_1APInt.html#ad3d358e03c6228af2d19b2e67028886e">llvm::APInt::ugt</a></div><div class="ttdeci">bool ugt(const APInt &amp;RHS) const </div><div class="ttdoc">Unsigned greather than comparison. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l01084">APInt.h:1084</a></div></div>
<div class="ttc" id="classllvm_1_1IRBuilderDefaultInserter_html"><div class="ttname"><a href="classllvm_1_1IRBuilderDefaultInserter.html">llvm::IRBuilderDefaultInserter</a></div><div class="ttdoc">This provides the default implementation of the IRBuilder &amp;#39;InsertHelper&amp;#39; method that is called whenev...</div><div class="ttdef"><b>Definition:</b> <a href="IRBuilder_8h_source.html#l00039">IRBuilder.h:39</a></div></div>
<div class="ttc" id="Lint_8cpp_html_a6cd8c36c54045fd5897b54d4c30e0044"><div class="ttname"><a href="Lint_8cpp.html#a6cd8c36c54045fd5897b54d4c30e0044">isZero</a></div><div class="ttdeci">static bool isZero(Value *V, DataLayout *DL)</div><div class="ttdef"><b>Definition:</b> <a href="Lint_8cpp_source.html#l00507">Lint.cpp:507</a></div></div>
<div class="ttc" id="classllvm_1_1DataLayout_html_ae84bb2408dfffa4e8b5fe2ce0714a3bd"><div class="ttname"><a href="classllvm_1_1DataLayout.html#ae84bb2408dfffa4e8b5fe2ce0714a3bd">llvm::DataLayout::getIntPtrType</a></div><div class="ttdeci">IntegerType * getIntPtrType(LLVMContext &amp;C, unsigned AddressSpace=0) const </div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8cpp_source.html#l00610">DataLayout.cpp:610</a></div></div>
<div class="ttc" id="classllvm_1_1SequentialType_html"><div class="ttname"><a href="classllvm_1_1SequentialType.html">llvm::SequentialType</a></div><div class="ttdef"><b>Definition:</b> <a href="DerivedTypes_8h_source.html#l00306">DerivedTypes.h:306</a></div></div>
<div class="ttc" id="classllvm_1_1SmallPtrSetImpl_html_aa72472422d95c7052d62432ec279ff85"><div class="ttname"><a href="classllvm_1_1SmallPtrSetImpl.html#aa72472422d95c7052d62432ec279ff85">llvm::SmallPtrSetImpl::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdef"><b>Definition:</b> <a href="SmallPtrSet_8h_source.html#l00077">SmallPtrSet.h:77</a></div></div>
<div class="ttc" id="classllvm_1_1DenseMapBase_html_a699a66e504b48fdeff124e82f6c61917"><div class="ttname"><a href="classllvm_1_1DenseMapBase.html#a699a66e504b48fdeff124e82f6c61917">llvm::DenseMapBase::insert</a></div><div class="ttdeci">std::pair&lt; iterator, bool &gt; insert(const std::pair&lt; KeyT, ValueT &gt; &amp;KV)</div><div class="ttdef"><b>Definition:</b> <a href="DenseMap_8h_source.html#l00153">DenseMap.h:153</a></div></div>
<div class="ttc" id="classllvm_1_1DataLayout_html_abb381519d34dcb9ccf673bf7689d0721"><div class="ttname"><a href="classllvm_1_1DataLayout.html#abb381519d34dcb9ccf673bf7689d0721">llvm::DataLayout::getABITypeAlignment</a></div><div class="ttdeci">unsigned getABITypeAlignment(Type *Ty) const </div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8cpp_source.html#l00582">DataLayout.cpp:582</a></div></div>
<div class="ttc" id="classllvm_1_1PointerIntPair_html_a2aafa035d16eddeaadc40efbf8c721e5"><div class="ttname"><a href="classllvm_1_1PointerIntPair.html#a2aafa035d16eddeaadc40efbf8c721e5">llvm::PointerIntPair::getPointer</a></div><div class="ttdeci">PointerTy getPointer() const </div><div class="ttdef"><b>Definition:</b> <a href="PointerIntPair_8h_source.html#l00070">PointerIntPair.h:70</a></div></div>
<div class="ttc" id="structllvm_1_1isPodLike_html"><div class="ttname"><a href="structllvm_1_1isPodLike.html">llvm::isPodLike</a></div><div class="ttdef"><b>Definition:</b> <a href="ArrayRef_8h_source.html#l00323">ArrayRef.h:323</a></div></div>
<div class="ttc" id="classllvm_1_1MemIntrinsic_html"><div class="ttname"><a href="classllvm_1_1MemIntrinsic.html">llvm::MemIntrinsic</a></div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00118">IntrinsicInst.h:118</a></div></div>
<div class="ttc" id="classllvm_1_1ilist__iterator_html"><div class="ttname"><a href="classllvm_1_1ilist__iterator.html">llvm::ilist_iterator</a></div><div class="ttdef"><b>Definition:</b> <a href="ilist_8h_source.html#l00050">ilist.h:50</a></div></div>
<div class="ttc" id="Target_2ARM_2README_8txt_html_a1b45f45820a60c09244a87eb59824aec"><div class="ttname"><a href="Target_2ARM_2README_8txt.html#a1b45f45820a60c09244a87eb59824aec">S</a></div><div class="ttdeci">add sub stmia L5 ldr r0 bl L_printf $stub Instead of a and a wouldn t it be better to do three moves *Return an aggregate type is even return S</div><div class="ttdef"><b>Definition:</b> <a href="Target_2ARM_2README_8txt_source.html#l00197">Target/ARM/README.txt:197</a></div></div>
<div class="ttc" id="classllvm_1_1SmallPtrSet_html"><div class="ttname"><a href="classllvm_1_1SmallPtrSet.html">llvm::SmallPtrSet&lt; Instruction *, 4 &gt;</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_a0519dc6e2f153aaed61eed17d965a9f0"><div class="ttname"><a href="classllvm_1_1Type.html#a0519dc6e2f153aaed61eed17d965a9f0">llvm::Type::getIntegerBitWidth</a></div><div class="ttdeci">unsigned getIntegerBitWidth() const </div><div class="ttdef"><b>Definition:</b> <a href="Type_8cpp_source.html#l00178">Type.cpp:178</a></div></div>
<div class="ttc" id="classllvm_1_1ConstantInt_html"><div class="ttname"><a href="classllvm_1_1ConstantInt.html">llvm::ConstantInt</a></div><div class="ttdoc">Class for constant integers. </div><div class="ttdef"><b>Definition:</b> <a href="Constants_8h_source.html#l00051">Constants.h:51</a></div></div>
<div class="ttc" id="classllvm_1_1PHINode_html_aba6a4cc4ed6d6fef3664b8d65ef04820"><div class="ttname"><a href="classllvm_1_1PHINode.html#aba6a4cc4ed6d6fef3664b8d65ef04820">llvm::PHINode::getIncomingValue</a></div><div class="ttdeci">Value * getIncomingValue(unsigned i) const </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l02059">Instructions.h:2059</a></div></div>
<div class="ttc" id="classllvm_1_1DataLayout_html_a1d6fcc02e91ba24510aba42660c90e29"><div class="ttname"><a href="classllvm_1_1DataLayout.html#a1d6fcc02e91ba24510aba42660c90e29">llvm::DataLayout::getTypeAllocSize</a></div><div class="ttdeci">uint64_t getTypeAllocSize(Type *Ty) const </div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8h_source.html#l00326">DataLayout.h:326</a></div></div>
<div class="ttc" id="classllvm_1_1StructType_html_a18fc4545474c6ebb6f7c547f64f4fb31"><div class="ttname"><a href="classllvm_1_1StructType.html#a18fc4545474c6ebb6f7c547f64f4fb31">llvm::StructType::get</a></div><div class="ttdeci">static StructType * get(LLVMContext &amp;Context, ArrayRef&lt; Type * &gt; Elements, bool isPacked=false)</div><div class="ttdef"><b>Definition:</b> <a href="Type_8cpp_source.html#l00405">Type.cpp:405</a></div></div>
<div class="ttc" id="Target_2README_8txt_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="Target_2README_8txt.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">i</div><div class="ttdef"><b>Definition:</b> <a href="Target_2README_8txt_source.html#l00029">Target/README.txt:29</a></div></div>
<div class="ttc" id="classllvm_1_1sys_1_1path_1_1const__iterator_html_a79fe46db1f88832bc90447c6ec541cf2"><div class="ttname"><a href="classllvm_1_1sys_1_1path_1_1const__iterator.html#a79fe46db1f88832bc90447c6ec541cf2">llvm::sys::path::const_iterator::begin</a></div><div class="ttdeci">friend const_iterator begin(StringRef path)</div><div class="ttdoc">Get begin iterator over path. </div><div class="ttdef"><b>Definition:</b> <a href="Path_8cpp_source.html#l00173">Path.cpp:173</a></div></div>
<div class="ttc" id="classllvm_1_1LoadAndStorePromoter_html"><div class="ttname"><a href="classllvm_1_1LoadAndStorePromoter.html">llvm::LoadAndStorePromoter</a></div><div class="ttdoc">Helper class for promoting a collection of loads and stores into SSA Form using the SSAUpdater...</div><div class="ttdef"><b>Definition:</b> <a href="SSAUpdater_8h_source.html#l00133">SSAUpdater.h:133</a></div></div>
<div class="ttc" id="namespacellvm_html_ab3d313ef442aae5b5bebf03c923506d0"><div class="ttname"><a href="namespacellvm.html#ab3d313ef442aae5b5bebf03c923506d0">llvm::ConvertDebugDeclareToDebugValue</a></div><div class="ttdeci">bool ConvertDebugDeclareToDebugValue(DbgDeclareInst *DDI, StoreInst *SI, DIBuilder &amp;Builder)</div><div class="ttdef"><b>Definition:</b> <a href="Local_8cpp_source.html#l00971">Local.cpp:971</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVector_html"><div class="ttname"><a href="classllvm_1_1SmallVector.html">llvm::SmallVector</a></div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00880">SmallVector.h:880</a></div></div>
<div class="ttc" id="classllvm_1_1MDNode_html_a05433bf2c7b926ea34946266b6a222e3"><div class="ttname"><a href="classllvm_1_1MDNode.html#a05433bf2c7b926ea34946266b6a222e3">llvm::MDNode::getIfExists</a></div><div class="ttdeci">static MDNode * getIfExists(LLVMContext &amp;Context, ArrayRef&lt; Value * &gt; Vals)</div><div class="ttdef"><b>Definition:</b> <a href="Metadata_8cpp_source.html#l00278">Metadata.cpp:278</a></div></div>
<div class="ttc" id="classllvm_1_1Value_html_a0cf3748dba54f931bb1241ae4adc76bc"><div class="ttname"><a href="classllvm_1_1Value.html#a0cf3748dba54f931bb1241ae4adc76bc">llvm::Value::getType</a></div><div class="ttdeci">Type * getType() const </div><div class="ttdef"><b>Definition:</b> <a href="Value_8h_source.html#l00111">Value.h:111</a></div></div>
<div class="ttc" id="classllvm_1_1Instruction_html_aafa29112cbe02e4adc9b36752c771991"><div class="ttname"><a href="classllvm_1_1Instruction.html#aafa29112cbe02e4adc9b36752c771991">llvm::Instruction::getMetadata</a></div><div class="ttdeci">MDNode * getMetadata(unsigned KindID) const </div><div class="ttdef"><b>Definition:</b> <a href="Instruction_8h_source.html#l00140">Instruction.h:140</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a42c6a2faff923f431932c6d33cf4092b"><div class="ttname"><a href="SROA_8cpp.html#a42c6a2faff923f431932c6d33cf4092b">insertVector</a></div><div class="ttdeci">static Value * insertVector(IRBuilderTy &amp;IRB, Value *Old, Value *V, unsigned BeginIndex, const Twine &amp;Name)</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01848">SROA.cpp:1848</a></div></div>
<div class="ttc" id="classllvm_1_1LoadInst_html_aeb96f1a88b4e58c34a988eebd843f688"><div class="ttname"><a href="classllvm_1_1LoadInst.html#aeb96f1a88b4e58c34a988eebd843f688">llvm::LoadInst::isVolatile</a></div><div class="ttdeci">bool isVolatile() const </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l00170">Instructions.h:170</a></div></div>
<div class="ttc" id="Compiler_8h_html_ac6a5e0eb6a9944baf6ba14b640eab6e1"><div class="ttname"><a href="Compiler_8h.html#ac6a5e0eb6a9944baf6ba14b640eab6e1">LLVM_ATTRIBUTE_NOINLINE</a></div><div class="ttdeci">#define LLVM_ATTRIBUTE_NOINLINE</div><div class="ttdef"><b>Definition:</b> <a href="Compiler_8h_source.html#l00254">Compiler.h:254</a></div></div>
<div class="ttc" id="classllvm_1_1MemIntrinsic_html_abad10f74789466601c7a025540c1c072"><div class="ttname"><a href="classllvm_1_1MemIntrinsic.html#abad10f74789466601c7a025540c1c072">llvm::MemIntrinsic::getLength</a></div><div class="ttdeci">Value * getLength() const </div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00122">IntrinsicInst.h:122</a></div></div>
<div class="ttc" id="classllvm_1_1StructLayout_html_a582a5b21a8f91d7f713fa9d57c0525de"><div class="ttname"><a href="classllvm_1_1StructLayout.html#a582a5b21a8f91d7f713fa9d57c0525de">llvm::StructLayout::getSizeInBytes</a></div><div class="ttdeci">uint64_t getSizeInBytes() const </div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8h_source.html#l00425">DataLayout.h:425</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_acaf8e4c3e40e01e848c1fad5f05b81cd"><div class="ttname"><a href="classllvm_1_1Type.html#acaf8e4c3e40e01e848c1fad5f05b81cd">llvm::Type::getIntNTy</a></div><div class="ttdeci">static IntegerType * getIntNTy(LLVMContext &amp;C, unsigned N)</div><div class="ttdef"><b>Definition:</b> <a href="Type_8cpp_source.html#l00244">Type.cpp:244</a></div></div>
<div class="ttc" id="classllvm_1_1StructLayout_html_a795cfd43d30c44c33b97fe850bc0451f"><div class="ttname"><a href="classllvm_1_1StructLayout.html#a795cfd43d30c44c33b97fe850bc0451f">llvm::StructLayout::getElementContainingOffset</a></div><div class="ttdeci">unsigned getElementContainingOffset(uint64_t Offset) const </div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8cpp_source.html#l00078">DataLayout.cpp:78</a></div></div>
<div class="ttc" id="classllvm_1_1ConstantInt_html_a9105541412dab869e18b3cceebfff07d"><div class="ttname"><a href="classllvm_1_1ConstantInt.html#a9105541412dab869e18b3cceebfff07d">llvm::ConstantInt::get</a></div><div class="ttdeci">static Constant * get(Type *Ty, uint64_t V, bool isSigned=false)</div><div class="ttdef"><b>Definition:</b> <a href="Constants_8cpp_source.html#l00492">Constants.cpp:492</a></div></div>
<div class="ttc" id="classllvm_1_1AnalysisUsage_html_af11a6ebf7ab3c388234cb6d5378439a3"><div class="ttname"><a href="classllvm_1_1AnalysisUsage.html#af11a6ebf7ab3c388234cb6d5378439a3">llvm::AnalysisUsage::setPreservesCFG</a></div><div class="ttdeci">void setPreservesCFG()</div><div class="ttdef"><b>Definition:</b> <a href="Pass_8cpp_source.html#l00249">Pass.cpp:249</a></div></div>
<div class="ttc" id="classllvm_1_1Function_html_a30f2c362631e3728d2f47a8203071ade"><div class="ttname"><a href="classllvm_1_1Function.html#a30f2c362631e3728d2f47a8203071ade">llvm::Function::getEntryBlock</a></div><div class="ttdeci">const BasicBlock &amp; getEntryBlock() const </div><div class="ttdef"><b>Definition:</b> <a href="Function_8h_source.html#l00380">Function.h:380</a></div></div>
<div class="ttc" id="classllvm_1_1User_html_a5fa9b8e1842b354f64c1ba6be0a4a17f"><div class="ttname"><a href="classllvm_1_1User.html#a5fa9b8e1842b354f64c1ba6be0a4a17f">llvm::User::setOperand</a></div><div class="ttdeci">void setOperand(unsigned i, Value *Val)</div><div class="ttdef"><b>Definition:</b> <a href="User_8h_source.html#l00092">User.h:92</a></div></div>
<div class="ttc" id="namespacellvm_html_a7c46c742c31be54870e2038048e6b391"><div class="ttname"><a href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">llvm::dbgs</a></div><div class="ttdeci">raw_ostream &amp; dbgs()</div><div class="ttdoc">dbgs - Return a circular-buffered debug stream. </div><div class="ttdef"><b>Definition:</b> <a href="Debug_8cpp_source.html#l00101">Debug.cpp:101</a></div></div>
<div class="ttc" id="classllvm_1_1GEPOperator_html"><div class="ttname"><a href="classllvm_1_1GEPOperator.html">llvm::GEPOperator</a></div><div class="ttdef"><b>Definition:</b> <a href="Operator_8h_source.html#l00357">Operator.h:357</a></div></div>
<div class="ttc" id="namespacestd_html_ab8424022895aee3e366fb9a32f2883cb"><div class="ttname"><a href="namespacestd.html#ab8424022895aee3e366fb9a32f2883cb">std::swap</a></div><div class="ttdeci">void swap(llvm::BitVector &amp;LHS, llvm::BitVector &amp;RHS)</div><div class="ttdoc">Implement std::swap in terms of BitVector swap. </div><div class="ttdef"><b>Definition:</b> <a href="BitVector_8h_source.html#l00591">BitVector.h:591</a></div></div>
<div class="ttc" id="classllvm_1_1CallInst_html_a150b33ecedbc8c7803c2db8040fbe3f8"><div class="ttname"><a href="classllvm_1_1CallInst.html#a150b33ecedbc8c7803c2db8040fbe3f8">llvm::CallInst::getArgOperand</a></div><div class="ttdeci">Value * getArgOperand(unsigned i) const </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l01245">Instructions.h:1245</a></div></div>
<div class="ttc" id="classllvm_1_1detail_1_1PtrUseVisitorBase_1_1PtrInfo_html_ad14328f51a170ef45854cc15a4b3564f"><div class="ttname"><a href="classllvm_1_1detail_1_1PtrUseVisitorBase_1_1PtrInfo.html#ad14328f51a170ef45854cc15a4b3564f">llvm::detail::PtrUseVisitorBase::PtrInfo::getEscapingInst</a></div><div class="ttdeci">Instruction * getEscapingInst() const </div><div class="ttdoc">Get the instruction causing the pointer to escape. </div><div class="ttdef"><b>Definition:</b> <a href="PtrUseVisitor_8h_source.html#l00075">PtrUseVisitor.h:75</a></div></div>
<div class="ttc" id="classllvm_1_1VectorType_html"><div class="ttname"><a href="classllvm_1_1VectorType.html">llvm::VectorType</a></div><div class="ttdef"><b>Definition:</b> <a href="DerivedTypes_8h_source.html#l00358">DerivedTypes.h:358</a></div></div>
<div class="ttc" id="classllvm_1_1APInt_html"><div class="ttname"><a href="classllvm_1_1APInt.html">llvm::APInt</a></div><div class="ttdoc">Class for arbitrary precision integers. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l00075">APInt.h:75</a></div></div>
<div class="ttc" id="CodeGen_2README_8txt_html_a09776db24cf586ec9f1e18f3bae14099"><div class="ttname"><a href="CodeGen_2README_8txt.html#a09776db24cf586ec9f1e18f3bae14099">BB</a></div><div class="ttdeci">Common register allocation spilling lr str ldr sxth r3 ldr mla r4 can lr mov lr str ldr sxth r3 mla r4 and then merge mul and lr str ldr sxth r3 mla r4 It also increase the likelihood the store may become dead bb27 Successors according to LLVM BB</div><div class="ttdef"><b>Definition:</b> <a href="CodeGen_2README_8txt_source.html#l00036">CodeGen/README.txt:36</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_a6e328feb83afa5cf1c966d6704e43fc1"><div class="ttname"><a href="classllvm_1_1Type.html#a6e328feb83afa5cf1c966d6704e43fc1">llvm::Type::isIntegerTy</a></div><div class="ttdeci">bool isIntegerTy() const </div><div class="ttdef"><b>Definition:</b> <a href="Type_8h_source.html#l00196">Type.h:196</a></div></div>
<div class="ttc" id="Pass_8h_html"><div class="ttname"><a href="Pass_8h.html">Pass.h</a></div></div>
<div class="ttc" id="namespacellvm_html_a288536b492d939bd6b8b67554f29ed21"><div class="ttname"><a href="namespacellvm.html#a288536b492d939bd6b8b67554f29ed21">llvm::initializeSROAPass</a></div><div class="ttdeci">void initializeSROAPass(PassRegistry &amp;)</div></div>
<div class="ttc" id="classllvm_1_1InstVisitor_html_a8f006d606ec21cb0e454912ce36d17d8"><div class="ttname"><a href="classllvm_1_1InstVisitor.html#a8f006d606ec21cb0e454912ce36d17d8">llvm::InstVisitor::visitStoreInst</a></div><div class="ttdeci">RetTy visitStoreInst(StoreInst &amp;I)</div><div class="ttdef"><b>Definition:</b> <a href="InstVisitor_8h_source.html#l00176">InstVisitor.h:176</a></div></div>
<div class="ttc" id="classllvm_1_1IRBuilderDefaultInserter_html_ad590e4afac186c7dbe3e72ece537d8cd"><div class="ttname"><a href="classllvm_1_1IRBuilderDefaultInserter.html#ad590e4afac186c7dbe3e72ece537d8cd">llvm::IRBuilderDefaultInserter::InsertHelper</a></div><div class="ttdeci">void InsertHelper(Instruction *I, const Twine &amp;Name, BasicBlock *BB, BasicBlock::iterator InsertPt) const </div><div class="ttdef"><b>Definition:</b> <a href="IRBuilder_8h_source.html#l00041">IRBuilder.h:41</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a7febebe786555d6e0d07ca0f86e294c1"><div class="ttname"><a href="SROA_8cpp.html#a7febebe786555d6e0d07ca0f86e294c1">insertInteger</a></div><div class="ttdeci">static Value * insertInteger(const DataLayout &amp;DL, IRBuilderTy &amp;IRB, Value *Old, Value *V, uint64_t Offset, const Twine &amp;Name)</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01789">SROA.cpp:1789</a></div></div>
<div class="ttc" id="Function_8h_html"><div class="ttname"><a href="Function_8h.html">Function.h</a></div></div>
<div class="ttc" id="classllvm_1_1MemIntrinsic_html_a898aa65c5d00f6073df71f3dd709a84d"><div class="ttname"><a href="classllvm_1_1MemIntrinsic.html#a898aa65c5d00f6073df71f3dd709a84d">llvm::MemIntrinsic::setLength</a></div><div class="ttdeci">void setLength(Value *L)</div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00155">IntrinsicInst.h:155</a></div></div>
<div class="ttc" id="classllvm_1_1Operator_html_a2f14b03fb8025d2bfa20a34da2b20ccf"><div class="ttname"><a href="classllvm_1_1Operator.html#a2f14b03fb8025d2bfa20a34da2b20ccf">llvm::Operator::getOpcode</a></div><div class="ttdeci">unsigned getOpcode() const </div><div class="ttdef"><b>Definition:</b> <a href="Operator_8h_source.html#l00051">Operator.h:51</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorTemplateCommon_html_a8a045d250952c0867382a9840ee18fdf"><div class="ttname"><a href="classllvm_1_1SmallVectorTemplateCommon.html#a8a045d250952c0867382a9840ee18fdf">llvm::SmallVectorTemplateCommon&lt; T &gt;::begin</a></div><div class="ttdeci">iterator begin()</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00112">SmallVector.h:112</a></div></div>
<div class="ttc" id="VirtRegMap_8cpp_html_a1ad52109a2ff430460c8776286b97b2e"><div class="ttname"><a href="VirtRegMap_8cpp.html#a1ad52109a2ff430460c8776286b97b2e">Rewriter</a></div><div class="ttdeci">Virtual Register Rewriter</div><div class="ttdef"><b>Definition:</b> <a href="VirtRegMap_8cpp_source.html#l00185">VirtRegMap.cpp:185</a></div></div>
<div class="ttc" id="classllvm_1_1Value_html_ae6a2729f1446acc2ae3e5a05bc2a5a4b"><div class="ttname"><a href="classllvm_1_1Value.html#ae6a2729f1446acc2ae3e5a05bc2a5a4b">llvm::Value::isDereferenceablePointer</a></div><div class="ttdeci">bool isDereferenceablePointer() const </div><div class="ttdef"><b>Definition:</b> <a href="Value_8cpp_source.html#l00500">Value.cpp:500</a></div></div>
<div class="ttc" id="classllvm_1_1Value_html_a413abcab8dbc3900fc2fde96a5d8fca6"><div class="ttname"><a href="classllvm_1_1Value.html#a413abcab8dbc3900fc2fde96a5d8fca6">llvm::Value::use_begin</a></div><div class="ttdeci">use_iterator use_begin()</div><div class="ttdef"><b>Definition:</b> <a href="Value_8h_source.html#l00150">Value.h:150</a></div></div>
<div class="ttc" id="namespacellvm_html_a2f883c895f4d244f4ed56ed8a8c160c1"><div class="ttname"><a href="namespacellvm.html#a2f883c895f4d244f4ed56ed8a8c160c1">llvm::operator!=</a></div><div class="ttdeci">bool operator!=(uint64_t V1, const APInt &amp;V2)</div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l01686">APInt.h:1686</a></div></div>
<div class="ttc" id="namespacellvm_html_af36d7e69ab16b64b2e3a48c83aa9f0f6"><div class="ttname"><a href="namespacellvm.html#af36d7e69ab16b64b2e3a48c83aa9f0f6">llvm::MinAlign</a></div><div class="ttdeci">uint64_t MinAlign(uint64_t A, uint64_t B)</div><div class="ttdef"><b>Definition:</b> <a href="MathExtras_8h_source.html#l00535">MathExtras.h:535</a></div></div>
<div class="ttc" id="classllvm_1_1MemTransferInst_html"><div class="ttname"><a href="classllvm_1_1MemTransferInst.html">llvm::MemTransferInst</a></div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00213">IntrinsicInst.h:213</a></div></div>
<div class="ttc" id="Transforms_2Scalar_8h_html"><div class="ttname"><a href="Transforms_2Scalar_8h.html">Scalar.h</a></div></div>
<div class="ttc" id="classllvm_1_1cl_1_1opt_html"><div class="ttname"><a href="classllvm_1_1cl_1_1opt.html">llvm::cl::opt</a></div><div class="ttdef"><b>Definition:</b> <a href="CommandLine_8h_source.html#l01149">CommandLine.h:1149</a></div></div>
<div class="ttc" id="classllvm_1_1ConstantExpr_html_a80e82791d4d7f4d1d23d68ca0a2b1f64"><div class="ttname"><a href="classllvm_1_1ConstantExpr.html#a80e82791d4d7f4d1d23d68ca0a2b1f64">llvm::ConstantExpr::getZExt</a></div><div class="ttdeci">static Constant * getZExt(Constant *C, Type *Ty)</div><div class="ttdef"><b>Definition:</b> <a href="Constants_8cpp_source.html#l01566">Constants.cpp:1566</a></div></div>
<div class="ttc" id="classllvm_1_1DataLayout_html_a96f1e9abd65fef355bd8f15f9360c871"><div class="ttname"><a href="classllvm_1_1DataLayout.html#a96f1e9abd65fef355bd8f15f9360c871">llvm::DataLayout::isLegalInteger</a></div><div class="ttdeci">bool isLegalInteger(unsigned Width) const </div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8h_source.html#l00210">DataLayout.h:210</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a0cddfff8553e3f05397def533fb5190e"><div class="ttname"><a href="SROA_8cpp.html#a0cddfff8553e3f05397def533fb5190e">INITIALIZE_PASS_BEGIN</a></div><div class="ttdeci">INITIALIZE_PASS_BEGIN(SROA,&quot;sroa&quot;,&quot;Scalar Replacement Of Aggregates&quot;, false, false) INITIALIZE_PASS_END(SROA</div></div>
<div class="ttc" id="classllvm_1_1DbgValueInst_html"><div class="ttname"><a href="classllvm_1_1DbgValueInst.html">llvm::DbgValueInst</a></div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00097">IntrinsicInst.h:97</a></div></div>
<div class="ttc" id="classllvm_1_1LoadInst_html_ad1168fc42bcba1b71217a4969483671a"><div class="ttname"><a href="classllvm_1_1LoadInst.html#ad1168fc42bcba1b71217a4969483671a">llvm::LoadInst::getAlignment</a></div><div class="ttdeci">unsigned getAlignment() const </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l00181">Instructions.h:181</a></div></div>
<div class="ttc" id="namespacellvm_html_a7aa6722f52f5d4d2cb36ae41cd5044d3"><div class="ttname"><a href="namespacellvm.html#a7aa6722f52f5d4d2cb36ae41cd5044d3">llvm::PointerTy</a></div><div class="ttdeci">void * PointerTy</div><div class="ttdef"><b>Definition:</b> <a href="GenericValue_8h_source.html#l00023">GenericValue.h:23</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a7493b7d3b84612687869f2c3afed924b"><div class="ttname"><a href="SROA_8cpp.html#a7493b7d3b84612687869f2c3afed924b">speculateSelectInstLoads</a></div><div class="ttdeci">static void speculateSelectInstLoads(SelectInst &amp;SI)</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01150">SROA.cpp:1150</a></div></div>
<div class="ttc" id="namespacellvm_1_1X86II_html_a97dc14052814702ba0e2b14fb14dd02da2c6497f6ed5314c6fcd9ab88c9528543"><div class="ttname"><a href="namespacellvm_1_1X86II.html#a97dc14052814702ba0e2b14fb14dd02da2c6497f6ed5314c6fcd9ab88c9528543">llvm::X86II::DE</a></div><div class="ttdef"><b>Definition:</b> <a href="X86BaseInfo_8h_source.html#l00332">X86BaseInfo.h:332</a></div></div>
<div class="ttc" id="MD5_8cpp_html_ac0eafdc9ee161b71e7af98af736952fd"><div class="ttname"><a href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a></div><div class="ttdeci">#define I(x, y, z)</div><div class="ttdef"><b>Definition:</b> <a href="MD5_8cpp_source.html#l00054">MD5.cpp:54</a></div></div>
<div class="ttc" id="classllvm_1_1BasicBlock_html_a5cb76a65b6524dba1493dd2b9dc3abbe"><div class="ttname"><a href="classllvm_1_1BasicBlock.html#a5cb76a65b6524dba1493dd2b9dc3abbe">llvm::BasicBlock::getTerminator</a></div><div class="ttdeci">TerminatorInst * getTerminator()</div><div class="ttdoc">Returns the terminator instruction if the block is well formed or null if the block is not well forme...</div><div class="ttdef"><b>Definition:</b> <a href="BasicBlock_8cpp_source.html#l00120">BasicBlock.cpp:120</a></div></div>
<div class="ttc" id="classllvm_1_1DataLayout_html_a9cb015699ac01dfa6ebb3cc4ce5a6a93"><div class="ttname"><a href="classllvm_1_1DataLayout.html#a9cb015699ac01dfa6ebb3cc4ce5a6a93">llvm::DataLayout::getPointerSizeInBits</a></div><div class="ttdeci">unsigned getPointerSizeInBits(unsigned AS=0) const </div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8h_source.html#l00271">DataLayout.h:271</a></div></div>
<div class="ttc" id="classllvm_1_1MemTransferInst_html_a94436025d48b34387528b438374c547b"><div class="ttname"><a href="classllvm_1_1MemTransferInst.html#a94436025d48b34387528b438374c547b">llvm::MemTransferInst::setSource</a></div><div class="ttdeci">void setSource(Value *Ptr)</div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00228">IntrinsicInst.h:228</a></div></div>
<div class="ttc" id="classllvm_1_1ArrayType_html_adf411edc4f135b570ab218079474ce77"><div class="ttname"><a href="classllvm_1_1ArrayType.html#adf411edc4f135b570ab218079474ce77">llvm::ArrayType::get</a></div><div class="ttdeci">static ArrayType * get(Type *ElementType, uint64_t NumElements)</div><div class="ttdef"><b>Definition:</b> <a href="Type_8cpp_source.html#l00679">Type.cpp:679</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorTemplateBase_html_a1f2303df9bbee2233c11d61c2f6f7930"><div class="ttname"><a href="classllvm_1_1SmallVectorTemplateBase.html#a1f2303df9bbee2233c11d61c2f6f7930">llvm::SmallVectorTemplateBase&lt; T, isPodLike&lt; T &gt;::value &gt;::pop_back</a></div><div class="ttdeci">void pop_back()</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00260">SmallVector.h:260</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_a8eafa71cf399da8f21b2af5549f3f9e7"><div class="ttname"><a href="classllvm_1_1Type.html#a8eafa71cf399da8f21b2af5549f3f9e7">llvm::Type::getScalarType</a></div><div class="ttdeci">const Type * getScalarType() const </div><div class="ttdef"><b>Definition:</b> <a href="Type_8cpp_source.html#l00051">Type.cpp:51</a></div></div>
<div class="ttc" id="DIBuilder_8h_html"><div class="ttname"><a href="DIBuilder_8h.html">DIBuilder.h</a></div></div>
<div class="ttc" id="ValueTracking_8h_html"><div class="ttname"><a href="ValueTracking_8h.html">ValueTracking.h</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a75f170d10487be0c2a7862177b2c18e7"><div class="ttname"><a href="SROA_8cpp.html#a75f170d10487be0c2a7862177b2c18e7">isIntegerWideningViable</a></div><div class="ttdeci">static bool isIntegerWideningViable(const DataLayout &amp;DL, Type *AllocaTy, uint64_t AllocBeginOffset, AllocaSlices &amp;S, AllocaSlices::const_iterator I, AllocaSlices::const_iterator E, ArrayRef&lt; AllocaSlices::iterator &gt; SplitUses)</div><div class="ttdoc">Test whether the given alloca partition&amp;#39;s integer operations can be widened to promotable ones...</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01720">SROA.cpp:1720</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a06a9071efa992145e210f0b41a52e501"><div class="ttname"><a href="SROA_8cpp.html#a06a9071efa992145e210f0b41a52e501">extractVector</a></div><div class="ttdeci">static Value * extractVector(IRBuilderTy &amp;IRB, Value *V, unsigned BeginIndex, unsigned EndIndex, const Twine &amp;Name)</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01820">SROA.cpp:1820</a></div></div>
<div class="ttc" id="classllvm_1_1DataLayout_html_a4b979cd93852fd44c48851c94ee00758"><div class="ttname"><a href="classllvm_1_1DataLayout.html#a4b979cd93852fd44c48851c94ee00758">llvm::DataLayout::getTypeStoreSize</a></div><div class="ttdeci">uint64_t getTypeStoreSize(Type *Ty) const </div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8h_source.html#l00311">DataLayout.h:311</a></div></div>
<div class="ttc" id="IRBuilder_8h_html"><div class="ttname"><a href="IRBuilder_8h.html">IRBuilder.h</a></div></div>
<div class="ttc" id="classllvm_1_1MemTransferInst_html_a26bfca1607622229a625f2db73aed2ba"><div class="ttname"><a href="classllvm_1_1MemTransferInst.html#a26bfca1607622229a625f2db73aed2ba">llvm::MemTransferInst::getRawSource</a></div><div class="ttdeci">Value * getRawSource() const </div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00217">IntrinsicInst.h:217</a></div></div>
<div class="ttc" id="LLVMContext_8h_html"><div class="ttname"><a href="LLVMContext_8h.html">LLVMContext.h</a></div></div>
<div class="ttc" id="SetVector_8h_html"><div class="ttname"><a href="SetVector_8h.html">SetVector.h</a></div></div>
<div class="ttc" id="classllvm_1_1Value_html_ac38c53f76ef532f91f1666c8a87370e9"><div class="ttname"><a href="classllvm_1_1Value.html#ac38c53f76ef532f91f1666c8a87370e9">llvm::Value::use_empty</a></div><div class="ttdeci">bool use_empty() const </div><div class="ttdef"><b>Definition:</b> <a href="Value_8h_source.html#l00149">Value.h:149</a></div></div>
<div class="ttc" id="ARMSubtarget_8cpp_html_a4bd80d4e433d9f72af26b364036900dc"><div class="ttname"><a href="ARMSubtarget_8cpp.html#a4bd80d4e433d9f72af26b364036900dc">Align</a></div><div class="ttdeci">static cl::opt&lt; AlignMode &gt; Align(cl::desc(&quot;Load/store alignment support&quot;), cl::Hidden, cl::init(DefaultAlign), cl::values(clEnumValN(DefaultAlign,&quot;arm-default-align&quot;,&quot;Generate unaligned accesses only on hardware/OS &quot;&quot;combinations that are known to support them&quot;), clEnumValN(StrictAlign,&quot;arm-strict-align&quot;,&quot;Disallow all unaligned memory accesses&quot;), clEnumValN(NoStrictAlign,&quot;arm-no-strict-align&quot;,&quot;Allow unaligned memory accesses&quot;), clEnumValEnd))</div></div>
<div class="ttc" id="Local_8h_html"><div class="ttname"><a href="Local_8h.html">Local.h</a></div></div>
<div class="ttc" id="classllvm_1_1GlobalValue_html_a9e1fc23a17e97d2d1732e753ae9251ac"><div class="ttname"><a href="classllvm_1_1GlobalValue.html#a9e1fc23a17e97d2d1732e753ae9251ac">llvm::GlobalValue::getParent</a></div><div class="ttdeci">Module * getParent()</div><div class="ttdef"><b>Definition:</b> <a href="GlobalValue_8h_source.html#l00286">GlobalValue.h:286</a></div></div>
<div class="ttc" id="classllvm_1_1Value_html"><div class="ttname"><a href="classllvm_1_1Value.html">llvm::Value</a></div><div class="ttdoc">LLVM Value Representation. </div><div class="ttdef"><b>Definition:</b> <a href="Value_8h_source.html#l00066">Value.h:66</a></div></div>
<div class="ttc" id="classllvm_1_1SetVector_html"><div class="ttname"><a href="classllvm_1_1SetVector.html">llvm::SetVector</a></div><div class="ttdoc">A vector that has set insertion semantics. </div><div class="ttdef"><b>Definition:</b> <a href="SetVector_8h_source.html#l00037">SetVector.h:37</a></div></div>
<div class="ttc" id="classllvm_1_1VectorType_html_ab43657ed1abe2e2ed3a6a394f233ebd0"><div class="ttname"><a href="classllvm_1_1VectorType.html#ab43657ed1abe2e2ed3a6a394f233ebd0">llvm::VectorType::get</a></div><div class="ttdeci">static VectorType * get(Type *ElementType, unsigned NumElements)</div><div class="ttdef"><b>Definition:</b> <a href="Type_8cpp_source.html#l00706">Type.cpp:706</a></div></div>
<div class="ttc" id="namespacellvm_1_1APIntOps_html_a57f47540fddb72feab9e8afd08f21611"><div class="ttname"><a href="namespacellvm_1_1APIntOps.html#a57f47540fddb72feab9e8afd08f21611">llvm::APIntOps::shl</a></div><div class="ttdeci">APInt shl(const APInt &amp;LHS, unsigned shiftAmt)</div><div class="ttdoc">Left-shift function. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l01797">APInt.h:1797</a></div></div>
<div class="ttc" id="SmallVector_8h_html"><div class="ttname"><a href="SmallVector_8h.html">SmallVector.h</a></div></div>
<div class="ttc" id="namespacellvm_1_1A64CC_html_af5804bc0518be9568f73db566e4d6f46a2db5e7546f960277ff98f96cd5624442"><div class="ttname"><a href="namespacellvm_1_1A64CC.html#af5804bc0518be9568f73db566e4d6f46a2db5e7546f960277ff98f96cd5624442">llvm::A64CC::MI</a></div><div class="ttdef"><b>Definition:</b> <a href="AArch64BaseInfo_8h_source.html#l00035">AArch64BaseInfo.h:35</a></div></div>
<div class="ttc" id="classllvm_1_1Twine_html_ac05f9009bd52e63b62e642bfdd24869b"><div class="ttname"><a href="classllvm_1_1Twine.html#ac05f9009bd52e63b62e642bfdd24869b">llvm::Twine::isTriviallyEmpty</a></div><div class="ttdeci">bool isTriviallyEmpty() const </div><div class="ttdef"><b>Definition:</b> <a href="Twine_8h_source.html#l00387">Twine.h:387</a></div></div>
<div class="ttc" id="SROA_8cpp_html_aab38ec9ebc3b5d96a4b7ddcb11cfcd58"><div class="ttname"><a href="SROA_8cpp.html#aab38ec9ebc3b5d96a4b7ddcb11cfcd58">speculatePHINodeLoads</a></div><div class="ttdeci">static void speculatePHINodeLoads(PHINode &amp;PN)</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01070">SROA.cpp:1070</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_a9dc5111b1a9b1d5c4652d50f74fe850b"><div class="ttname"><a href="classllvm_1_1Type.html#a9dc5111b1a9b1d5c4652d50f74fe850b">llvm::Type::isSized</a></div><div class="ttdeci">bool isSized() const </div><div class="ttdef"><b>Definition:</b> <a href="Type_8h_source.html#l00278">Type.h:278</a></div></div>
<div class="ttc" id="classllvm_1_1DataLayout_html_add914112e0b2935dda06ad5dfd3a31db"><div class="ttname"><a href="classllvm_1_1DataLayout.html#add914112e0b2935dda06ad5dfd3a31db">llvm::DataLayout::getTypeSizeInBits</a></div><div class="ttdeci">uint64_t getTypeSizeInBits(Type *Ty) const </div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8h_source.html#l00459">DataLayout.h:459</a></div></div>
<div class="ttc" id="namespacellvm_html_a7923e3e207de8bc1d0d6a5091316ddde"><div class="ttname"><a href="namespacellvm.html#a7923e3e207de8bc1d0d6a5091316ddde">llvm::prior</a></div><div class="ttdeci">ItTy prior(ItTy it, Dist n)</div><div class="ttdef"><b>Definition:</b> <a href="STLExtras_8h_source.html#l00167">STLExtras.h:167</a></div></div>
<div class="ttc" id="classllvm_1_1raw__ostream_html"><div class="ttname"><a href="classllvm_1_1raw__ostream.html">llvm::raw_ostream</a></div><div class="ttdef"><b>Definition:</b> <a href="raw__ostream_8h_source.html#l00031">raw_ostream.h:31</a></div></div>
<div class="ttc" id="Debug_8h_html_aef41e8aaf4c60819b30faf396cdf4978"><div class="ttname"><a href="Debug_8h.html#aef41e8aaf4c60819b30faf396cdf4978">DEBUG</a></div><div class="ttdeci">#define DEBUG(X)</div><div class="ttdef"><b>Definition:</b> <a href="Debug_8h_source.html#l00097">Debug.h:97</a></div></div>
<div class="ttc" id="classllvm_1_1PtrUseVisitor_html_a511b9034e923ca17006a820514470dd4"><div class="ttname"><a href="classllvm_1_1PtrUseVisitor.html#a511b9034e923ca17006a820514470dd4">llvm::PtrUseVisitor::visitPtr</a></div><div class="ttdeci">PtrInfo visitPtr(Instruction &amp;I)</div><div class="ttdoc">Recursively visit the uses of the given pointer. </div><div class="ttdef"><b>Definition:</b> <a href="PtrUseVisitor_8h_source.html#l00203">PtrUseVisitor.h:203</a></div></div>
<div class="ttc" id="classAllocaSlices_1_1SliceBuilder_html_ad113f431e82837ba1618b47f6ae6f5c8"><div class="ttname"><a href="classAllocaSlices_1_1SliceBuilder.html#ad113f431e82837ba1618b47f6ae6f5c8">AllocaSlices::SliceBuilder::SliceBuilder</a></div><div class="ttdeci">SliceBuilder(const DataLayout &amp;DL, AllocaInst &amp;AI, AllocaSlices &amp;S)</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l00328">SROA.cpp:328</a></div></div>
<div class="ttc" id="classllvm_1_1SelectInst_html_a29a16f32075ee4f23cd769701463952c"><div class="ttname"><a href="classllvm_1_1SelectInst.html#a29a16f32075ee4f23cd769701463952c">llvm::SelectInst::getFalseValue</a></div><div class="ttdeci">const Value * getFalseValue() const </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l01468">Instructions.h:1468</a></div></div>
<div class="ttc" id="classllvm_1_1StringRef_html"><div class="ttname"><a href="classllvm_1_1StringRef.html">llvm::StringRef</a></div><div class="ttdef"><b>Definition:</b> <a href="StringRef_8h_source.html#l00041">StringRef.h:41</a></div></div>
<div class="ttc" id="classllvm_1_1APInt_html_a6142fc5662411269a7ca0217f49f338c"><div class="ttname"><a href="classllvm_1_1APInt.html#a6142fc5662411269a7ca0217f49f338c">llvm::APInt::zext</a></div><div class="ttdeci">APInt LLVM_ATTRIBUTE_UNUSED_RESULT zext(unsigned width) const </div><div class="ttdoc">Zero extend to a new width. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8cpp_source.html#l00983">APInt.cpp:983</a></div></div>
<div class="ttc" id="raw__ostream_8h_html"><div class="ttname"><a href="raw__ostream_8h.html">raw_ostream.h</a></div></div>
<div class="ttc" id="namespacellvm_html_a162c90bc179a6359438d060722bee35f"><div class="ttname"><a href="namespacellvm.html#a162c90bc179a6359438d060722bee35f">llvm::operator==</a></div><div class="ttdeci">bool operator==(uint64_t V1, const APInt &amp;V2)</div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l01684">APInt.h:1684</a></div></div>
<div class="ttc" id="namespacellvm_1_1SPII_html_a11e9b8fca4a074643a6a21f444e51406a36b3dd3b84fde3f8494a9b18af131856"><div class="ttname"><a href="namespacellvm_1_1SPII.html#a11e9b8fca4a074643a6a21f444e51406a36b3dd3b84fde3f8494a9b18af131856">llvm::SPII::Store</a></div><div class="ttdef"><b>Definition:</b> <a href="SparcInstrInfo_8h_source.html#l00032">SparcInstrInfo.h:32</a></div></div>
<div class="ttc" id="classllvm_1_1InstVisitor_html_af7fc294424421c8b8e16185bd9bc7f8f"><div class="ttname"><a href="classllvm_1_1InstVisitor.html#af7fc294424421c8b8e16185bd9bc7f8f">llvm::InstVisitor::visitInstruction</a></div><div class="ttdeci">void visitInstruction(Instruction &amp;I)</div><div class="ttdef"><b>Definition:</b> <a href="InstVisitor_8h_source.html#l00256">InstVisitor.h:256</a></div></div>
<div class="ttc" id="classllvm_1_1DataLayout_html_a9b876cc57d1884621f481b26b0892633"><div class="ttname"><a href="classllvm_1_1DataLayout.html#a9b876cc57d1884621f481b26b0892633">llvm::DataLayout::isBigEndian</a></div><div class="ttdeci">bool isBigEndian() const </div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8h_source.html#l00196">DataLayout.h:196</a></div></div>
<div class="ttc" id="Target_2ARM_2README_8txt_html_a90cca76dd78688687e0d697679dbc799"><div class="ttname"><a href="Target_2ARM_2README_8txt.html#a90cca76dd78688687e0d697679dbc799">B</a></div><div class="ttdeci">compiles ldr LCPI1_0 ldr ldr mov lsr tst moveq r1 ldr LCPI1_1 and r0 bx lr It would be better to do something like to fold the shift into the conditional ldr LCPI1_0 ldr ldr tst movne lsr ldr LCPI1_1 and r0 bx lr it saves an instruction and a register It might be profitable to cse MOVi16 if there are lots of bit immediates with the same bottom half Robert Muth started working on an alternate jump table implementation that does not put the tables in line in the text This is more like the llvm default jump table implementation This might be useful sometime Several revisions of patches are on the mailing beginning while CMP sets them like a subtract Therefore to be able to use CMN for comparisons other than the Z we ll need additional logic to reverse the conditionals associated with the comparison Perhaps a pseudo instruction for the with a post codegen pass to clean up and handle the condition codes See PR5694 for testcase Given the following on int B</div><div class="ttdef"><b>Definition:</b> <a href="Target_2ARM_2README_8txt_source.html#l00592">Target/ARM/README.txt:592</a></div></div>
<div class="ttc" id="classllvm_1_1DbgDeclareInst_html"><div class="ttname"><a href="classllvm_1_1DbgDeclareInst.html">llvm::DbgDeclareInst</a></div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00081">IntrinsicInst.h:81</a></div></div>
<div class="ttc" id="namespacellvm_html_a7dc3e2c002713fec56bdbf16aa704576"><div class="ttname"><a href="namespacellvm.html#a7dc3e2c002713fec56bdbf16aa704576">llvm::tie</a></div><div class="ttdeci">tier&lt; T1, T2 &gt; tie(T1 &amp;f, T2 &amp;s)</div><div class="ttdef"><b>Definition:</b> <a href="STLExtras_8h_source.html#l00216">STLExtras.h:216</a></div></div>
<div class="ttc" id="classllvm_1_1StoreInst_html_ac03c1c093059ea000216af8dd6f2dbf4"><div class="ttname"><a href="classllvm_1_1StoreInst.html#ac03c1c093059ea000216af8dd6f2dbf4">llvm::StoreInst::getPointerOperand</a></div><div class="ttdeci">Value * getPointerOperand()</div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l00346">Instructions.h:346</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_a7ba5de75f50bb4a4ba920698edf39b28"><div class="ttname"><a href="classllvm_1_1Type.html#a7ba5de75f50bb4a4ba920698edf39b28">llvm::Type::getInt8Ty</a></div><div class="ttdeci">static IntegerType * getInt8Ty(LLVMContext &amp;C)</div><div class="ttdef"><b>Definition:</b> <a href="Type_8cpp_source.html#l00239">Type.cpp:239</a></div></div>
<div class="ttc" id="classllvm_1_1Instruction_html_a9cd49851904f15060edb782ef4dd1b2d"><div class="ttname"><a href="classllvm_1_1Instruction.html#a9cd49851904f15060edb782ef4dd1b2d">llvm::Instruction::getParent</a></div><div class="ttdeci">const BasicBlock * getParent() const </div><div class="ttdef"><b>Definition:</b> <a href="Instruction_8h_source.html#l00052">Instruction.h:52</a></div></div>
<div class="ttc" id="namespacellvm_1_1Intrinsic_html_a73349916f7e54a6b988a3646c7a02e90ae365354e47542c51f9bd46e329e3323e"><div class="ttname"><a href="namespacellvm_1_1Intrinsic.html#a73349916f7e54a6b988a3646c7a02e90ae365354e47542c51f9bd46e329e3323e">llvm::Intrinsic::lifetime_start</a></div><div class="ttdef"><b>Definition:</b> <a href="Intrinsics_8h_source.html#l01255">Intrinsics.h:1255</a></div></div>
<div class="ttc" id="classllvm_1_1detail_1_1PtrUseVisitorBase_1_1PtrInfo_html_a9fac5f949c3305a84085a9d37113244a"><div class="ttname"><a href="classllvm_1_1detail_1_1PtrUseVisitorBase_1_1PtrInfo.html#a9fac5f949c3305a84085a9d37113244a">llvm::detail::PtrUseVisitorBase::PtrInfo::isAborted</a></div><div class="ttdeci">bool isAborted() const </div><div class="ttdoc">Did we abort the visit early? </div><div class="ttdef"><b>Definition:</b> <a href="PtrUseVisitor_8h_source.html#l00062">PtrUseVisitor.h:62</a></div></div>
<div class="ttc" id="classllvm_1_1SUnit_html"><div class="ttname"><a href="classllvm_1_1SUnit.html">llvm::SUnit</a></div><div class="ttdoc">SUnit - Scheduling unit. This is a node in the scheduling DAG. </div><div class="ttdef"><b>Definition:</b> <a href="ScheduleDAG_8h_source.html#l00249">ScheduleDAG.h:249</a></div></div>
<div class="ttc" id="classllvm_1_1IntrinsicInst_html"><div class="ttname"><a href="classllvm_1_1IntrinsicInst.html">llvm::IntrinsicInst</a></div><div class="ttdef"><b>Definition:</b> <a href="IntrinsicInst_8h_source.html#l00036">IntrinsicInst.h:36</a></div></div>
<div class="ttc" id="classllvm_1_1AllocaInst_html"><div class="ttname"><a href="classllvm_1_1AllocaInst.html">llvm::AllocaInst</a></div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l00058">Instructions.h:58</a></div></div>
<div class="ttc" id="SROA_8cpp_html_ae51507ca5dff9cd52cd782421e71b45b"><div class="ttname"><a href="SROA_8cpp.html#ae51507ca5dff9cd52cd782421e71b45b">getNaturalGEPWithOffset</a></div><div class="ttdeci">static Value * getNaturalGEPWithOffset(IRBuilderTy &amp;IRB, const DataLayout &amp;DL, Value *Ptr, APInt Offset, Type *TargetTy, SmallVectorImpl&lt; Value * &gt; &amp;Indices)</div><div class="ttdoc">Get a natural GEP from a base pointer to a particular offset and resulting in a particular type...</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l01320">SROA.cpp:1320</a></div></div>
<div class="ttc" id="SROA_8cpp_html_a849bc9de354f140d265e3ff56999ce19"><div class="ttname"><a href="SROA_8cpp.html#a849bc9de354f140d265e3ff56999ce19">foldSelectInst</a></div><div class="ttdeci">static Value * foldSelectInst(SelectInst &amp;SI)</div><div class="ttdef"><b>Definition:</b> <a href="SROA_8cpp_source.html#l00297">SROA.cpp:297</a></div></div>
<div class="ttc" id="Compiler_8h_html_a6881c00738b22a600dfee25a1c32dab3"><div class="ttname"><a href="Compiler_8h.html#a6881c00738b22a600dfee25a1c32dab3">LLVM_ATTRIBUTE_USED</a></div><div class="ttdeci">#define LLVM_ATTRIBUTE_USED</div><div class="ttdef"><b>Definition:</b> <a href="Compiler_8h_source.html#l00179">Compiler.h:179</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<hr>
<p class="footer">
Generated on Sat Nov 10 2018 23:02:30 for <a href="http://llvm.org/">LLVM</a> by
<a href="http://www.doxygen.org"><img src="doxygen.png" alt="Doxygen"
align="middle" border="0"/>1.8.11</a><br>
Copyright &copy; 2003-2013 University of Illinois at Urbana-Champaign.
All Rights Reserved.</p>
<hr>
<!--#include virtual="/attrib.incl" -->
</body>
</html>
